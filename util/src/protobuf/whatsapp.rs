#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppVersion)
pub struct AppVersion {
    // message fields
    // @@protoc_insertion_point(field:AppVersion.primary)
    pub primary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AppVersion.secondary)
    pub secondary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AppVersion.tertiary)
    pub tertiary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AppVersion.quaternary)
    pub quaternary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AppVersion.quinary)
    pub quinary: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:AppVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppVersion {
    fn default() -> &'a AppVersion {
        <AppVersion as ::protobuf::Message>::default_instance()
    }
}

impl AppVersion {
    pub fn new() -> AppVersion {
        ::std::default::Default::default()
    }

    // optional uint32 primary = 1;

    pub fn primary(&self) -> u32 {
        self.primary.unwrap_or(0)
    }

    pub fn clear_primary(&mut self) {
        self.primary = ::std::option::Option::None;
    }

    pub fn has_primary(&self) -> bool {
        self.primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary(&mut self, v: u32) {
        self.primary = ::std::option::Option::Some(v);
    }

    // optional uint32 secondary = 2;

    pub fn secondary(&self) -> u32 {
        self.secondary.unwrap_or(0)
    }

    pub fn clear_secondary(&mut self) {
        self.secondary = ::std::option::Option::None;
    }

    pub fn has_secondary(&self) -> bool {
        self.secondary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondary(&mut self, v: u32) {
        self.secondary = ::std::option::Option::Some(v);
    }

    // optional uint32 tertiary = 3;

    pub fn tertiary(&self) -> u32 {
        self.tertiary.unwrap_or(0)
    }

    pub fn clear_tertiary(&mut self) {
        self.tertiary = ::std::option::Option::None;
    }

    pub fn has_tertiary(&self) -> bool {
        self.tertiary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tertiary(&mut self, v: u32) {
        self.tertiary = ::std::option::Option::Some(v);
    }

    // optional uint32 quaternary = 4;

    pub fn quaternary(&self) -> u32 {
        self.quaternary.unwrap_or(0)
    }

    pub fn clear_quaternary(&mut self) {
        self.quaternary = ::std::option::Option::None;
    }

    pub fn has_quaternary(&self) -> bool {
        self.quaternary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quaternary(&mut self, v: u32) {
        self.quaternary = ::std::option::Option::Some(v);
    }

    // optional uint32 quinary = 5;

    pub fn quinary(&self) -> u32 {
        self.quinary.unwrap_or(0)
    }

    pub fn clear_quinary(&mut self) {
        self.quinary = ::std::option::Option::None;
    }

    pub fn has_quinary(&self) -> bool {
        self.quinary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quinary(&mut self, v: u32) {
        self.quinary = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary",
            |m: &AppVersion| { &m.primary },
            |m: &mut AppVersion| { &mut m.primary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "secondary",
            |m: &AppVersion| { &m.secondary },
            |m: &mut AppVersion| { &mut m.secondary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tertiary",
            |m: &AppVersion| { &m.tertiary },
            |m: &mut AppVersion| { &mut m.tertiary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quaternary",
            |m: &AppVersion| { &m.quaternary },
            |m: &mut AppVersion| { &mut m.quaternary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quinary",
            |m: &AppVersion| { &m.quinary },
            |m: &mut AppVersion| { &mut m.quinary },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppVersion>(
            "AppVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppVersion {
    const NAME: &'static str = "AppVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.primary = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.secondary = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tertiary = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.quaternary = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.quinary = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.primary {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.secondary {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tertiary {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.quaternary {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.quinary {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.primary {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.secondary {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tertiary {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quaternary {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quinary {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppVersion {
        AppVersion::new()
    }

    fn clear(&mut self) {
        self.primary = ::std::option::Option::None;
        self.secondary = ::std::option::Option::None;
        self.tertiary = ::std::option::Option::None;
        self.quaternary = ::std::option::Option::None;
        self.quinary = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppVersion {
        static instance: AppVersion = AppVersion {
            primary: ::std::option::Option::None,
            secondary: ::std::option::Option::None,
            tertiary: ::std::option::Option::None,
            quaternary: ::std::option::Option::None,
            quinary: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UserAgent)
pub struct UserAgent {
    // message fields
    // @@protoc_insertion_point(field:UserAgent.platform)
    pub platform: ::std::option::Option<::protobuf::EnumOrUnknown<user_agent::UserAgentPlatform>>,
    // @@protoc_insertion_point(field:UserAgent.appVersion)
    pub appVersion: ::protobuf::MessageField<AppVersion>,
    // @@protoc_insertion_point(field:UserAgent.mcc)
    pub mcc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.mnc)
    pub mnc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.osVersion)
    pub osVersion: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.manufacturer)
    pub manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.device)
    pub device: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.osBuildNumber)
    pub osBuildNumber: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.phoneId)
    pub phoneId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.releaseChannel)
    pub releaseChannel: ::std::option::Option<::protobuf::EnumOrUnknown<user_agent::UserAgentReleaseChannel>>,
    // @@protoc_insertion_point(field:UserAgent.localeLanguageIso6391)
    pub localeLanguageIso6391: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.localeCountryIso31661Alpha2)
    pub localeCountryIso31661Alpha2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserAgent.deviceBoard)
    pub deviceBoard: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:UserAgent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAgent {
    fn default() -> &'a UserAgent {
        <UserAgent as ::protobuf::Message>::default_instance()
    }
}

impl UserAgent {
    pub fn new() -> UserAgent {
        ::std::default::Default::default()
    }

    // optional .UserAgent.UserAgentPlatform platform = 1;

    pub fn platform(&self) -> user_agent::UserAgentPlatform {
        match self.platform {
            Some(e) => e.enum_value_or(user_agent::UserAgentPlatform::ANDROID),
            None => user_agent::UserAgentPlatform::ANDROID,
        }
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: user_agent::UserAgentPlatform) {
        self.platform = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string mcc = 3;

    pub fn mcc(&self) -> &str {
        match self.mcc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mcc(&mut self) {
        self.mcc = ::std::option::Option::None;
    }

    pub fn has_mcc(&self) -> bool {
        self.mcc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mcc(&mut self, v: ::std::string::String) {
        self.mcc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mcc(&mut self) -> &mut ::std::string::String {
        if self.mcc.is_none() {
            self.mcc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mcc.as_mut().unwrap()
    }

    // Take field
    pub fn take_mcc(&mut self) -> ::std::string::String {
        self.mcc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mnc = 4;

    pub fn mnc(&self) -> &str {
        match self.mnc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mnc(&mut self) {
        self.mnc = ::std::option::Option::None;
    }

    pub fn has_mnc(&self) -> bool {
        self.mnc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mnc(&mut self, v: ::std::string::String) {
        self.mnc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mnc(&mut self) -> &mut ::std::string::String {
        if self.mnc.is_none() {
            self.mnc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mnc.as_mut().unwrap()
    }

    // Take field
    pub fn take_mnc(&mut self) -> ::std::string::String {
        self.mnc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string osVersion = 5;

    pub fn osVersion(&self) -> &str {
        match self.osVersion.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_osVersion(&mut self) {
        self.osVersion = ::std::option::Option::None;
    }

    pub fn has_osVersion(&self) -> bool {
        self.osVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osVersion(&mut self, v: ::std::string::String) {
        self.osVersion = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osVersion(&mut self) -> &mut ::std::string::String {
        if self.osVersion.is_none() {
            self.osVersion = ::std::option::Option::Some(::std::string::String::new());
        }
        self.osVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_osVersion(&mut self) -> ::std::string::String {
        self.osVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string manufacturer = 6;

    pub fn manufacturer(&self) -> &str {
        match self.manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_manufacturer(&mut self) {
        self.manufacturer = ::std::option::Option::None;
    }

    pub fn has_manufacturer(&self) -> bool {
        self.manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manufacturer(&mut self, v: ::std::string::String) {
        self.manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.manufacturer.is_none() {
            self.manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_manufacturer(&mut self) -> ::std::string::String {
        self.manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device = 7;

    pub fn device(&self) -> &str {
        match self.device.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        if self.device.is_none() {
            self.device = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        self.device.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string osBuildNumber = 8;

    pub fn osBuildNumber(&self) -> &str {
        match self.osBuildNumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_osBuildNumber(&mut self) {
        self.osBuildNumber = ::std::option::Option::None;
    }

    pub fn has_osBuildNumber(&self) -> bool {
        self.osBuildNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osBuildNumber(&mut self, v: ::std::string::String) {
        self.osBuildNumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osBuildNumber(&mut self) -> &mut ::std::string::String {
        if self.osBuildNumber.is_none() {
            self.osBuildNumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.osBuildNumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_osBuildNumber(&mut self) -> ::std::string::String {
        self.osBuildNumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string phoneId = 9;

    pub fn phoneId(&self) -> &str {
        match self.phoneId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phoneId(&mut self) {
        self.phoneId = ::std::option::Option::None;
    }

    pub fn has_phoneId(&self) -> bool {
        self.phoneId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phoneId(&mut self, v: ::std::string::String) {
        self.phoneId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phoneId(&mut self) -> &mut ::std::string::String {
        if self.phoneId.is_none() {
            self.phoneId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phoneId.as_mut().unwrap()
    }

    // Take field
    pub fn take_phoneId(&mut self) -> ::std::string::String {
        self.phoneId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .UserAgent.UserAgentReleaseChannel releaseChannel = 10;

    pub fn releaseChannel(&self) -> user_agent::UserAgentReleaseChannel {
        match self.releaseChannel {
            Some(e) => e.enum_value_or(user_agent::UserAgentReleaseChannel::RELEASE),
            None => user_agent::UserAgentReleaseChannel::RELEASE,
        }
    }

    pub fn clear_releaseChannel(&mut self) {
        self.releaseChannel = ::std::option::Option::None;
    }

    pub fn has_releaseChannel(&self) -> bool {
        self.releaseChannel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_releaseChannel(&mut self, v: user_agent::UserAgentReleaseChannel) {
        self.releaseChannel = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string localeLanguageIso6391 = 11;

    pub fn localeLanguageIso6391(&self) -> &str {
        match self.localeLanguageIso6391.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localeLanguageIso6391(&mut self) {
        self.localeLanguageIso6391 = ::std::option::Option::None;
    }

    pub fn has_localeLanguageIso6391(&self) -> bool {
        self.localeLanguageIso6391.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localeLanguageIso6391(&mut self, v: ::std::string::String) {
        self.localeLanguageIso6391 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localeLanguageIso6391(&mut self) -> &mut ::std::string::String {
        if self.localeLanguageIso6391.is_none() {
            self.localeLanguageIso6391 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localeLanguageIso6391.as_mut().unwrap()
    }

    // Take field
    pub fn take_localeLanguageIso6391(&mut self) -> ::std::string::String {
        self.localeLanguageIso6391.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string localeCountryIso31661Alpha2 = 12;

    pub fn localeCountryIso31661Alpha2(&self) -> &str {
        match self.localeCountryIso31661Alpha2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localeCountryIso31661Alpha2(&mut self) {
        self.localeCountryIso31661Alpha2 = ::std::option::Option::None;
    }

    pub fn has_localeCountryIso31661Alpha2(&self) -> bool {
        self.localeCountryIso31661Alpha2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localeCountryIso31661Alpha2(&mut self, v: ::std::string::String) {
        self.localeCountryIso31661Alpha2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localeCountryIso31661Alpha2(&mut self) -> &mut ::std::string::String {
        if self.localeCountryIso31661Alpha2.is_none() {
            self.localeCountryIso31661Alpha2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localeCountryIso31661Alpha2.as_mut().unwrap()
    }

    // Take field
    pub fn take_localeCountryIso31661Alpha2(&mut self) -> ::std::string::String {
        self.localeCountryIso31661Alpha2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string deviceBoard = 13;

    pub fn deviceBoard(&self) -> &str {
        match self.deviceBoard.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deviceBoard(&mut self) {
        self.deviceBoard = ::std::option::Option::None;
    }

    pub fn has_deviceBoard(&self) -> bool {
        self.deviceBoard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceBoard(&mut self, v: ::std::string::String) {
        self.deviceBoard = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceBoard(&mut self) -> &mut ::std::string::String {
        if self.deviceBoard.is_none() {
            self.deviceBoard = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deviceBoard.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceBoard(&mut self) -> ::std::string::String {
        self.deviceBoard.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &UserAgent| { &m.platform },
            |m: &mut UserAgent| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppVersion>(
            "appVersion",
            |m: &UserAgent| { &m.appVersion },
            |m: &mut UserAgent| { &mut m.appVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mcc",
            |m: &UserAgent| { &m.mcc },
            |m: &mut UserAgent| { &mut m.mcc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mnc",
            |m: &UserAgent| { &m.mnc },
            |m: &mut UserAgent| { &mut m.mnc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osVersion",
            |m: &UserAgent| { &m.osVersion },
            |m: &mut UserAgent| { &mut m.osVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manufacturer",
            |m: &UserAgent| { &m.manufacturer },
            |m: &mut UserAgent| { &mut m.manufacturer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &UserAgent| { &m.device },
            |m: &mut UserAgent| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osBuildNumber",
            |m: &UserAgent| { &m.osBuildNumber },
            |m: &mut UserAgent| { &mut m.osBuildNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phoneId",
            |m: &UserAgent| { &m.phoneId },
            |m: &mut UserAgent| { &mut m.phoneId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "releaseChannel",
            |m: &UserAgent| { &m.releaseChannel },
            |m: &mut UserAgent| { &mut m.releaseChannel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localeLanguageIso6391",
            |m: &UserAgent| { &m.localeLanguageIso6391 },
            |m: &mut UserAgent| { &mut m.localeLanguageIso6391 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localeCountryIso31661Alpha2",
            |m: &UserAgent| { &m.localeCountryIso31661Alpha2 },
            |m: &mut UserAgent| { &mut m.localeCountryIso31661Alpha2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceBoard",
            |m: &UserAgent| { &m.deviceBoard },
            |m: &mut UserAgent| { &mut m.deviceBoard },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAgent>(
            "UserAgent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAgent {
    const NAME: &'static str = "UserAgent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.platform = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appVersion)?;
                },
                26 => {
                    self.mcc = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.mnc = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.osVersion = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.device = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.osBuildNumber = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.phoneId = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.releaseChannel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.localeLanguageIso6391 = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.localeCountryIso31661Alpha2 = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.deviceBoard = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.appVersion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mcc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.mnc.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.osVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.device.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.osBuildNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.phoneId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.releaseChannel {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.localeLanguageIso6391.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.localeCountryIso31661Alpha2.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.deviceBoard.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.platform {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appVersion.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.mcc.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.mnc.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.osVersion.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.manufacturer.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.device.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.osBuildNumber.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.phoneId.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.releaseChannel {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.localeLanguageIso6391.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.localeCountryIso31661Alpha2.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.deviceBoard.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAgent {
        UserAgent::new()
    }

    fn clear(&mut self) {
        self.platform = ::std::option::Option::None;
        self.appVersion.clear();
        self.mcc = ::std::option::Option::None;
        self.mnc = ::std::option::Option::None;
        self.osVersion = ::std::option::Option::None;
        self.manufacturer = ::std::option::Option::None;
        self.device = ::std::option::Option::None;
        self.osBuildNumber = ::std::option::Option::None;
        self.phoneId = ::std::option::Option::None;
        self.releaseChannel = ::std::option::Option::None;
        self.localeLanguageIso6391 = ::std::option::Option::None;
        self.localeCountryIso31661Alpha2 = ::std::option::Option::None;
        self.deviceBoard = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAgent {
        static instance: UserAgent = UserAgent {
            platform: ::std::option::Option::None,
            appVersion: ::protobuf::MessageField::none(),
            mcc: ::std::option::Option::None,
            mnc: ::std::option::Option::None,
            osVersion: ::std::option::Option::None,
            manufacturer: ::std::option::Option::None,
            device: ::std::option::Option::None,
            osBuildNumber: ::std::option::Option::None,
            phoneId: ::std::option::Option::None,
            releaseChannel: ::std::option::Option::None,
            localeLanguageIso6391: ::std::option::Option::None,
            localeCountryIso31661Alpha2: ::std::option::Option::None,
            deviceBoard: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAgent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAgent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAgent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAgent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UserAgent`
pub mod user_agent {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:UserAgent.UserAgentPlatform)
    pub enum UserAgentPlatform {
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.ANDROID)
        ANDROID = 0,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.IOS)
        IOS = 1,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.WINDOWS_PHONE)
        WINDOWS_PHONE = 2,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.BLACKBERRY)
        BLACKBERRY = 3,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.BLACKBERRYX)
        BLACKBERRYX = 4,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.S40)
        S40 = 5,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.S60)
        S60 = 6,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.PYTHON_CLIENT)
        PYTHON_CLIENT = 7,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.TIZEN)
        TIZEN = 8,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.ENTERPRISE)
        ENTERPRISE = 9,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.SMB_ANDROID)
        SMB_ANDROID = 10,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.KAIOS)
        KAIOS = 11,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.SMB_IOS)
        SMB_IOS = 12,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.WINDOWS)
        WINDOWS = 13,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.WEB)
        WEB = 14,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.PORTAL)
        PORTAL = 15,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.GREEN_ANDROID)
        GREEN_ANDROID = 16,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.GREEN_IPHONE)
        GREEN_IPHONE = 17,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.BLUE_ANDROID)
        BLUE_ANDROID = 18,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.BLUE_IPHONE)
        BLUE_IPHONE = 19,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.FBLITE_ANDROID)
        FBLITE_ANDROID = 20,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.MLITE_ANDROID)
        MLITE_ANDROID = 21,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.IGLITE_ANDROID)
        IGLITE_ANDROID = 22,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.PAGE)
        PAGE = 23,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.MACOS)
        MACOS = 24,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.OCULUS_MSG)
        OCULUS_MSG = 25,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.OCULUS_CALL)
        OCULUS_CALL = 26,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.MILAN)
        MILAN = 27,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentPlatform.CAPI)
        CAPI = 28,
    }

    impl ::protobuf::Enum for UserAgentPlatform {
        const NAME: &'static str = "UserAgentPlatform";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<UserAgentPlatform> {
            match value {
                0 => ::std::option::Option::Some(UserAgentPlatform::ANDROID),
                1 => ::std::option::Option::Some(UserAgentPlatform::IOS),
                2 => ::std::option::Option::Some(UserAgentPlatform::WINDOWS_PHONE),
                3 => ::std::option::Option::Some(UserAgentPlatform::BLACKBERRY),
                4 => ::std::option::Option::Some(UserAgentPlatform::BLACKBERRYX),
                5 => ::std::option::Option::Some(UserAgentPlatform::S40),
                6 => ::std::option::Option::Some(UserAgentPlatform::S60),
                7 => ::std::option::Option::Some(UserAgentPlatform::PYTHON_CLIENT),
                8 => ::std::option::Option::Some(UserAgentPlatform::TIZEN),
                9 => ::std::option::Option::Some(UserAgentPlatform::ENTERPRISE),
                10 => ::std::option::Option::Some(UserAgentPlatform::SMB_ANDROID),
                11 => ::std::option::Option::Some(UserAgentPlatform::KAIOS),
                12 => ::std::option::Option::Some(UserAgentPlatform::SMB_IOS),
                13 => ::std::option::Option::Some(UserAgentPlatform::WINDOWS),
                14 => ::std::option::Option::Some(UserAgentPlatform::WEB),
                15 => ::std::option::Option::Some(UserAgentPlatform::PORTAL),
                16 => ::std::option::Option::Some(UserAgentPlatform::GREEN_ANDROID),
                17 => ::std::option::Option::Some(UserAgentPlatform::GREEN_IPHONE),
                18 => ::std::option::Option::Some(UserAgentPlatform::BLUE_ANDROID),
                19 => ::std::option::Option::Some(UserAgentPlatform::BLUE_IPHONE),
                20 => ::std::option::Option::Some(UserAgentPlatform::FBLITE_ANDROID),
                21 => ::std::option::Option::Some(UserAgentPlatform::MLITE_ANDROID),
                22 => ::std::option::Option::Some(UserAgentPlatform::IGLITE_ANDROID),
                23 => ::std::option::Option::Some(UserAgentPlatform::PAGE),
                24 => ::std::option::Option::Some(UserAgentPlatform::MACOS),
                25 => ::std::option::Option::Some(UserAgentPlatform::OCULUS_MSG),
                26 => ::std::option::Option::Some(UserAgentPlatform::OCULUS_CALL),
                27 => ::std::option::Option::Some(UserAgentPlatform::MILAN),
                28 => ::std::option::Option::Some(UserAgentPlatform::CAPI),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [UserAgentPlatform] = &[
            UserAgentPlatform::ANDROID,
            UserAgentPlatform::IOS,
            UserAgentPlatform::WINDOWS_PHONE,
            UserAgentPlatform::BLACKBERRY,
            UserAgentPlatform::BLACKBERRYX,
            UserAgentPlatform::S40,
            UserAgentPlatform::S60,
            UserAgentPlatform::PYTHON_CLIENT,
            UserAgentPlatform::TIZEN,
            UserAgentPlatform::ENTERPRISE,
            UserAgentPlatform::SMB_ANDROID,
            UserAgentPlatform::KAIOS,
            UserAgentPlatform::SMB_IOS,
            UserAgentPlatform::WINDOWS,
            UserAgentPlatform::WEB,
            UserAgentPlatform::PORTAL,
            UserAgentPlatform::GREEN_ANDROID,
            UserAgentPlatform::GREEN_IPHONE,
            UserAgentPlatform::BLUE_ANDROID,
            UserAgentPlatform::BLUE_IPHONE,
            UserAgentPlatform::FBLITE_ANDROID,
            UserAgentPlatform::MLITE_ANDROID,
            UserAgentPlatform::IGLITE_ANDROID,
            UserAgentPlatform::PAGE,
            UserAgentPlatform::MACOS,
            UserAgentPlatform::OCULUS_MSG,
            UserAgentPlatform::OCULUS_CALL,
            UserAgentPlatform::MILAN,
            UserAgentPlatform::CAPI,
        ];
    }

    impl ::protobuf::EnumFull for UserAgentPlatform {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("UserAgent.UserAgentPlatform").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for UserAgentPlatform {
        fn default() -> Self {
            UserAgentPlatform::ANDROID
        }
    }

    impl UserAgentPlatform {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UserAgentPlatform>("UserAgent.UserAgentPlatform")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:UserAgent.UserAgentReleaseChannel)
    pub enum UserAgentReleaseChannel {
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentReleaseChannel.RELEASE)
        RELEASE = 0,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentReleaseChannel.BETA)
        BETA = 1,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentReleaseChannel.ALPHA)
        ALPHA = 2,
        // @@protoc_insertion_point(enum_value:UserAgent.UserAgentReleaseChannel.DEBUG)
        DEBUG = 3,
    }

    impl ::protobuf::Enum for UserAgentReleaseChannel {
        const NAME: &'static str = "UserAgentReleaseChannel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<UserAgentReleaseChannel> {
            match value {
                0 => ::std::option::Option::Some(UserAgentReleaseChannel::RELEASE),
                1 => ::std::option::Option::Some(UserAgentReleaseChannel::BETA),
                2 => ::std::option::Option::Some(UserAgentReleaseChannel::ALPHA),
                3 => ::std::option::Option::Some(UserAgentReleaseChannel::DEBUG),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [UserAgentReleaseChannel] = &[
            UserAgentReleaseChannel::RELEASE,
            UserAgentReleaseChannel::BETA,
            UserAgentReleaseChannel::ALPHA,
            UserAgentReleaseChannel::DEBUG,
        ];
    }

    impl ::protobuf::EnumFull for UserAgentReleaseChannel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("UserAgent.UserAgentReleaseChannel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for UserAgentReleaseChannel {
        fn default() -> Self {
            UserAgentReleaseChannel::RELEASE
        }
    }

    impl UserAgentReleaseChannel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UserAgentReleaseChannel>("UserAgent.UserAgentReleaseChannel")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WebdPayload)
pub struct WebdPayload {
    // message fields
    // @@protoc_insertion_point(field:WebdPayload.usesParticipantInKey)
    pub usesParticipantInKey: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsStarredMessages)
    pub supportsStarredMessages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsDocumentMessages)
    pub supportsDocumentMessages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsUrlMessages)
    pub supportsUrlMessages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsMediaRetry)
    pub supportsMediaRetry: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsE2EImage)
    pub supportsE2EImage: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsE2EVideo)
    pub supportsE2EVideo: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsE2EAudio)
    pub supportsE2EAudio: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.supportsE2EDocument)
    pub supportsE2EDocument: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebdPayload.documentTypes)
    pub documentTypes: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WebdPayload.features)
    pub features: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:WebdPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebdPayload {
    fn default() -> &'a WebdPayload {
        <WebdPayload as ::protobuf::Message>::default_instance()
    }
}

impl WebdPayload {
    pub fn new() -> WebdPayload {
        ::std::default::Default::default()
    }

    // optional bool usesParticipantInKey = 1;

    pub fn usesParticipantInKey(&self) -> bool {
        self.usesParticipantInKey.unwrap_or(false)
    }

    pub fn clear_usesParticipantInKey(&mut self) {
        self.usesParticipantInKey = ::std::option::Option::None;
    }

    pub fn has_usesParticipantInKey(&self) -> bool {
        self.usesParticipantInKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usesParticipantInKey(&mut self, v: bool) {
        self.usesParticipantInKey = ::std::option::Option::Some(v);
    }

    // optional bool supportsStarredMessages = 2;

    pub fn supportsStarredMessages(&self) -> bool {
        self.supportsStarredMessages.unwrap_or(false)
    }

    pub fn clear_supportsStarredMessages(&mut self) {
        self.supportsStarredMessages = ::std::option::Option::None;
    }

    pub fn has_supportsStarredMessages(&self) -> bool {
        self.supportsStarredMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsStarredMessages(&mut self, v: bool) {
        self.supportsStarredMessages = ::std::option::Option::Some(v);
    }

    // optional bool supportsDocumentMessages = 3;

    pub fn supportsDocumentMessages(&self) -> bool {
        self.supportsDocumentMessages.unwrap_or(false)
    }

    pub fn clear_supportsDocumentMessages(&mut self) {
        self.supportsDocumentMessages = ::std::option::Option::None;
    }

    pub fn has_supportsDocumentMessages(&self) -> bool {
        self.supportsDocumentMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsDocumentMessages(&mut self, v: bool) {
        self.supportsDocumentMessages = ::std::option::Option::Some(v);
    }

    // optional bool supportsUrlMessages = 4;

    pub fn supportsUrlMessages(&self) -> bool {
        self.supportsUrlMessages.unwrap_or(false)
    }

    pub fn clear_supportsUrlMessages(&mut self) {
        self.supportsUrlMessages = ::std::option::Option::None;
    }

    pub fn has_supportsUrlMessages(&self) -> bool {
        self.supportsUrlMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsUrlMessages(&mut self, v: bool) {
        self.supportsUrlMessages = ::std::option::Option::Some(v);
    }

    // optional bool supportsMediaRetry = 5;

    pub fn supportsMediaRetry(&self) -> bool {
        self.supportsMediaRetry.unwrap_or(false)
    }

    pub fn clear_supportsMediaRetry(&mut self) {
        self.supportsMediaRetry = ::std::option::Option::None;
    }

    pub fn has_supportsMediaRetry(&self) -> bool {
        self.supportsMediaRetry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsMediaRetry(&mut self, v: bool) {
        self.supportsMediaRetry = ::std::option::Option::Some(v);
    }

    // optional bool supportsE2EImage = 6;

    pub fn supportsE2EImage(&self) -> bool {
        self.supportsE2EImage.unwrap_or(false)
    }

    pub fn clear_supportsE2EImage(&mut self) {
        self.supportsE2EImage = ::std::option::Option::None;
    }

    pub fn has_supportsE2EImage(&self) -> bool {
        self.supportsE2EImage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsE2EImage(&mut self, v: bool) {
        self.supportsE2EImage = ::std::option::Option::Some(v);
    }

    // optional bool supportsE2EVideo = 7;

    pub fn supportsE2EVideo(&self) -> bool {
        self.supportsE2EVideo.unwrap_or(false)
    }

    pub fn clear_supportsE2EVideo(&mut self) {
        self.supportsE2EVideo = ::std::option::Option::None;
    }

    pub fn has_supportsE2EVideo(&self) -> bool {
        self.supportsE2EVideo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsE2EVideo(&mut self, v: bool) {
        self.supportsE2EVideo = ::std::option::Option::Some(v);
    }

    // optional bool supportsE2EAudio = 8;

    pub fn supportsE2EAudio(&self) -> bool {
        self.supportsE2EAudio.unwrap_or(false)
    }

    pub fn clear_supportsE2EAudio(&mut self) {
        self.supportsE2EAudio = ::std::option::Option::None;
    }

    pub fn has_supportsE2EAudio(&self) -> bool {
        self.supportsE2EAudio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsE2EAudio(&mut self, v: bool) {
        self.supportsE2EAudio = ::std::option::Option::Some(v);
    }

    // optional bool supportsE2EDocument = 9;

    pub fn supportsE2EDocument(&self) -> bool {
        self.supportsE2EDocument.unwrap_or(false)
    }

    pub fn clear_supportsE2EDocument(&mut self) {
        self.supportsE2EDocument = ::std::option::Option::None;
    }

    pub fn has_supportsE2EDocument(&self) -> bool {
        self.supportsE2EDocument.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsE2EDocument(&mut self, v: bool) {
        self.supportsE2EDocument = ::std::option::Option::Some(v);
    }

    // optional string documentTypes = 10;

    pub fn documentTypes(&self) -> &str {
        match self.documentTypes.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_documentTypes(&mut self) {
        self.documentTypes = ::std::option::Option::None;
    }

    pub fn has_documentTypes(&self) -> bool {
        self.documentTypes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_documentTypes(&mut self, v: ::std::string::String) {
        self.documentTypes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentTypes(&mut self) -> &mut ::std::string::String {
        if self.documentTypes.is_none() {
            self.documentTypes = ::std::option::Option::Some(::std::string::String::new());
        }
        self.documentTypes.as_mut().unwrap()
    }

    // Take field
    pub fn take_documentTypes(&mut self) -> ::std::string::String {
        self.documentTypes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes features = 11;

    pub fn features(&self) -> &[u8] {
        match self.features.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_features(&mut self) {
        self.features = ::std::option::Option::None;
    }

    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: ::std::vec::Vec<u8>) {
        self.features = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_features(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.features.is_none() {
            self.features = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.features.as_mut().unwrap()
    }

    // Take field
    pub fn take_features(&mut self) -> ::std::vec::Vec<u8> {
        self.features.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usesParticipantInKey",
            |m: &WebdPayload| { &m.usesParticipantInKey },
            |m: &mut WebdPayload| { &mut m.usesParticipantInKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsStarredMessages",
            |m: &WebdPayload| { &m.supportsStarredMessages },
            |m: &mut WebdPayload| { &mut m.supportsStarredMessages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsDocumentMessages",
            |m: &WebdPayload| { &m.supportsDocumentMessages },
            |m: &mut WebdPayload| { &mut m.supportsDocumentMessages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsUrlMessages",
            |m: &WebdPayload| { &m.supportsUrlMessages },
            |m: &mut WebdPayload| { &mut m.supportsUrlMessages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsMediaRetry",
            |m: &WebdPayload| { &m.supportsMediaRetry },
            |m: &mut WebdPayload| { &mut m.supportsMediaRetry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsE2EImage",
            |m: &WebdPayload| { &m.supportsE2EImage },
            |m: &mut WebdPayload| { &mut m.supportsE2EImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsE2EVideo",
            |m: &WebdPayload| { &m.supportsE2EVideo },
            |m: &mut WebdPayload| { &mut m.supportsE2EVideo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsE2EAudio",
            |m: &WebdPayload| { &m.supportsE2EAudio },
            |m: &mut WebdPayload| { &mut m.supportsE2EAudio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supportsE2EDocument",
            |m: &WebdPayload| { &m.supportsE2EDocument },
            |m: &mut WebdPayload| { &mut m.supportsE2EDocument },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "documentTypes",
            |m: &WebdPayload| { &m.documentTypes },
            |m: &mut WebdPayload| { &mut m.documentTypes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "features",
            |m: &WebdPayload| { &m.features },
            |m: &mut WebdPayload| { &mut m.features },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebdPayload>(
            "WebdPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebdPayload {
    const NAME: &'static str = "WebdPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.usesParticipantInKey = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.supportsStarredMessages = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.supportsDocumentMessages = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.supportsUrlMessages = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.supportsMediaRetry = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.supportsE2EImage = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.supportsE2EVideo = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.supportsE2EAudio = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.supportsE2EDocument = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.documentTypes = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.features = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.usesParticipantInKey {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsStarredMessages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsDocumentMessages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsUrlMessages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsMediaRetry {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsE2EImage {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsE2EVideo {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsE2EAudio {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supportsE2EDocument {
            my_size += 1 + 1;
        }
        if let Some(v) = self.documentTypes.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.features.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.usesParticipantInKey {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.supportsStarredMessages {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.supportsDocumentMessages {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.supportsUrlMessages {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.supportsMediaRetry {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.supportsE2EImage {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.supportsE2EVideo {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.supportsE2EAudio {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.supportsE2EDocument {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.documentTypes.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.features.as_ref() {
            os.write_bytes(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebdPayload {
        WebdPayload::new()
    }

    fn clear(&mut self) {
        self.usesParticipantInKey = ::std::option::Option::None;
        self.supportsStarredMessages = ::std::option::Option::None;
        self.supportsDocumentMessages = ::std::option::Option::None;
        self.supportsUrlMessages = ::std::option::Option::None;
        self.supportsMediaRetry = ::std::option::Option::None;
        self.supportsE2EImage = ::std::option::Option::None;
        self.supportsE2EVideo = ::std::option::Option::None;
        self.supportsE2EAudio = ::std::option::Option::None;
        self.supportsE2EDocument = ::std::option::Option::None;
        self.documentTypes = ::std::option::Option::None;
        self.features = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebdPayload {
        static instance: WebdPayload = WebdPayload {
            usesParticipantInKey: ::std::option::Option::None,
            supportsStarredMessages: ::std::option::Option::None,
            supportsDocumentMessages: ::std::option::Option::None,
            supportsUrlMessages: ::std::option::Option::None,
            supportsMediaRetry: ::std::option::Option::None,
            supportsE2EImage: ::std::option::Option::None,
            supportsE2EVideo: ::std::option::Option::None,
            supportsE2EAudio: ::std::option::Option::None,
            supportsE2EDocument: ::std::option::Option::None,
            documentTypes: ::std::option::Option::None,
            features: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebdPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebdPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebdPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebdPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WebInfo)
pub struct WebInfo {
    // message fields
    // @@protoc_insertion_point(field:WebInfo.refToken)
    pub refToken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WebInfo.version)
    pub version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WebInfo.webdPayload)
    pub webdPayload: ::protobuf::MessageField<WebdPayload>,
    // @@protoc_insertion_point(field:WebInfo.webSubPlatform)
    pub webSubPlatform: ::std::option::Option<::protobuf::EnumOrUnknown<web_info::WebInfoWebSubPlatform>>,
    // special fields
    // @@protoc_insertion_point(special_field:WebInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebInfo {
    fn default() -> &'a WebInfo {
        <WebInfo as ::protobuf::Message>::default_instance()
    }
}

impl WebInfo {
    pub fn new() -> WebInfo {
        ::std::default::Default::default()
    }

    // optional string refToken = 1;

    pub fn refToken(&self) -> &str {
        match self.refToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_refToken(&mut self) {
        self.refToken = ::std::option::Option::None;
    }

    pub fn has_refToken(&self) -> bool {
        self.refToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refToken(&mut self, v: ::std::string::String) {
        self.refToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refToken(&mut self) -> &mut ::std::string::String {
        if self.refToken.is_none() {
            self.refToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.refToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_refToken(&mut self) -> ::std::string::String {
        self.refToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .WebInfo.WebInfoWebSubPlatform webSubPlatform = 4;

    pub fn webSubPlatform(&self) -> web_info::WebInfoWebSubPlatform {
        match self.webSubPlatform {
            Some(e) => e.enum_value_or(web_info::WebInfoWebSubPlatform::WEB_BROWSER),
            None => web_info::WebInfoWebSubPlatform::WEB_BROWSER,
        }
    }

    pub fn clear_webSubPlatform(&mut self) {
        self.webSubPlatform = ::std::option::Option::None;
    }

    pub fn has_webSubPlatform(&self) -> bool {
        self.webSubPlatform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webSubPlatform(&mut self, v: web_info::WebInfoWebSubPlatform) {
        self.webSubPlatform = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "refToken",
            |m: &WebInfo| { &m.refToken },
            |m: &mut WebInfo| { &mut m.refToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &WebInfo| { &m.version },
            |m: &mut WebInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebdPayload>(
            "webdPayload",
            |m: &WebInfo| { &m.webdPayload },
            |m: &mut WebInfo| { &mut m.webdPayload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "webSubPlatform",
            |m: &WebInfo| { &m.webSubPlatform },
            |m: &mut WebInfo| { &mut m.webSubPlatform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebInfo>(
            "WebInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebInfo {
    const NAME: &'static str = "WebInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.refToken = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webdPayload)?;
                },
                32 => {
                    self.webSubPlatform = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.refToken.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.webdPayload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.webSubPlatform {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.refToken.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.webdPayload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.webSubPlatform {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebInfo {
        WebInfo::new()
    }

    fn clear(&mut self) {
        self.refToken = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.webdPayload.clear();
        self.webSubPlatform = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebInfo {
        static instance: WebInfo = WebInfo {
            refToken: ::std::option::Option::None,
            version: ::std::option::Option::None,
            webdPayload: ::protobuf::MessageField::none(),
            webSubPlatform: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebInfo`
pub mod web_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WebInfo.WebInfoWebSubPlatform)
    pub enum WebInfoWebSubPlatform {
        // @@protoc_insertion_point(enum_value:WebInfo.WebInfoWebSubPlatform.WEB_BROWSER)
        WEB_BROWSER = 0,
        // @@protoc_insertion_point(enum_value:WebInfo.WebInfoWebSubPlatform.APP_STORE)
        APP_STORE = 1,
        // @@protoc_insertion_point(enum_value:WebInfo.WebInfoWebSubPlatform.WIN_STORE)
        WIN_STORE = 2,
        // @@protoc_insertion_point(enum_value:WebInfo.WebInfoWebSubPlatform.DARWIN)
        DARWIN = 3,
        // @@protoc_insertion_point(enum_value:WebInfo.WebInfoWebSubPlatform.WIN32)
        WIN32 = 4,
    }

    impl ::protobuf::Enum for WebInfoWebSubPlatform {
        const NAME: &'static str = "WebInfoWebSubPlatform";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WebInfoWebSubPlatform> {
            match value {
                0 => ::std::option::Option::Some(WebInfoWebSubPlatform::WEB_BROWSER),
                1 => ::std::option::Option::Some(WebInfoWebSubPlatform::APP_STORE),
                2 => ::std::option::Option::Some(WebInfoWebSubPlatform::WIN_STORE),
                3 => ::std::option::Option::Some(WebInfoWebSubPlatform::DARWIN),
                4 => ::std::option::Option::Some(WebInfoWebSubPlatform::WIN32),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WebInfoWebSubPlatform] = &[
            WebInfoWebSubPlatform::WEB_BROWSER,
            WebInfoWebSubPlatform::APP_STORE,
            WebInfoWebSubPlatform::WIN_STORE,
            WebInfoWebSubPlatform::DARWIN,
            WebInfoWebSubPlatform::WIN32,
        ];
    }

    impl ::protobuf::EnumFull for WebInfoWebSubPlatform {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebInfo.WebInfoWebSubPlatform").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WebInfoWebSubPlatform {
        fn default() -> Self {
            WebInfoWebSubPlatform::WEB_BROWSER
        }
    }

    impl WebInfoWebSubPlatform {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebInfoWebSubPlatform>("WebInfo.WebInfoWebSubPlatform")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DNSSource)
pub struct DNSSource {
    // message fields
    // @@protoc_insertion_point(field:DNSSource.dnsMethod)
    pub dnsMethod: ::std::option::Option<::protobuf::EnumOrUnknown<dnssource::DNSSourceDNSResolutionMethod>>,
    // @@protoc_insertion_point(field:DNSSource.appCached)
    pub appCached: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:DNSSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DNSSource {
    fn default() -> &'a DNSSource {
        <DNSSource as ::protobuf::Message>::default_instance()
    }
}

impl DNSSource {
    pub fn new() -> DNSSource {
        ::std::default::Default::default()
    }

    // optional .DNSSource.DNSSourceDNSResolutionMethod dnsMethod = 15;

    pub fn dnsMethod(&self) -> dnssource::DNSSourceDNSResolutionMethod {
        match self.dnsMethod {
            Some(e) => e.enum_value_or(dnssource::DNSSourceDNSResolutionMethod::SYSTEM),
            None => dnssource::DNSSourceDNSResolutionMethod::SYSTEM,
        }
    }

    pub fn clear_dnsMethod(&mut self) {
        self.dnsMethod = ::std::option::Option::None;
    }

    pub fn has_dnsMethod(&self) -> bool {
        self.dnsMethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dnsMethod(&mut self, v: dnssource::DNSSourceDNSResolutionMethod) {
        self.dnsMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool appCached = 16;

    pub fn appCached(&self) -> bool {
        self.appCached.unwrap_or(false)
    }

    pub fn clear_appCached(&mut self) {
        self.appCached = ::std::option::Option::None;
    }

    pub fn has_appCached(&self) -> bool {
        self.appCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appCached(&mut self, v: bool) {
        self.appCached = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dnsMethod",
            |m: &DNSSource| { &m.dnsMethod },
            |m: &mut DNSSource| { &mut m.dnsMethod },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appCached",
            |m: &DNSSource| { &m.appCached },
            |m: &mut DNSSource| { &mut m.appCached },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DNSSource>(
            "DNSSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DNSSource {
    const NAME: &'static str = "DNSSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                120 => {
                    self.dnsMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                128 => {
                    self.appCached = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dnsMethod {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.appCached {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dnsMethod {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appCached {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DNSSource {
        DNSSource::new()
    }

    fn clear(&mut self) {
        self.dnsMethod = ::std::option::Option::None;
        self.appCached = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DNSSource {
        static instance: DNSSource = DNSSource {
            dnsMethod: ::std::option::Option::None,
            appCached: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DNSSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DNSSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DNSSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DNSSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DNSSource`
pub mod dnssource {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:DNSSource.DNSSourceDNSResolutionMethod)
    pub enum DNSSourceDNSResolutionMethod {
        // @@protoc_insertion_point(enum_value:DNSSource.DNSSourceDNSResolutionMethod.SYSTEM)
        SYSTEM = 0,
        // @@protoc_insertion_point(enum_value:DNSSource.DNSSourceDNSResolutionMethod.GOOGLE)
        GOOGLE = 1,
        // @@protoc_insertion_point(enum_value:DNSSource.DNSSourceDNSResolutionMethod.HARDCODED)
        HARDCODED = 2,
        // @@protoc_insertion_point(enum_value:DNSSource.DNSSourceDNSResolutionMethod.OVERRIDE)
        OVERRIDE = 3,
        // @@protoc_insertion_point(enum_value:DNSSource.DNSSourceDNSResolutionMethod.FALLBACK)
        FALLBACK = 4,
    }

    impl ::protobuf::Enum for DNSSourceDNSResolutionMethod {
        const NAME: &'static str = "DNSSourceDNSResolutionMethod";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DNSSourceDNSResolutionMethod> {
            match value {
                0 => ::std::option::Option::Some(DNSSourceDNSResolutionMethod::SYSTEM),
                1 => ::std::option::Option::Some(DNSSourceDNSResolutionMethod::GOOGLE),
                2 => ::std::option::Option::Some(DNSSourceDNSResolutionMethod::HARDCODED),
                3 => ::std::option::Option::Some(DNSSourceDNSResolutionMethod::OVERRIDE),
                4 => ::std::option::Option::Some(DNSSourceDNSResolutionMethod::FALLBACK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DNSSourceDNSResolutionMethod] = &[
            DNSSourceDNSResolutionMethod::SYSTEM,
            DNSSourceDNSResolutionMethod::GOOGLE,
            DNSSourceDNSResolutionMethod::HARDCODED,
            DNSSourceDNSResolutionMethod::OVERRIDE,
            DNSSourceDNSResolutionMethod::FALLBACK,
        ];
    }

    impl ::protobuf::EnumFull for DNSSourceDNSResolutionMethod {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DNSSource.DNSSourceDNSResolutionMethod").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DNSSourceDNSResolutionMethod {
        fn default() -> Self {
            DNSSourceDNSResolutionMethod::SYSTEM
        }
    }

    impl DNSSourceDNSResolutionMethod {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DNSSourceDNSResolutionMethod>("DNSSource.DNSSourceDNSResolutionMethod")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CompanionRegData)
pub struct CompanionRegData {
    // message fields
    // @@protoc_insertion_point(field:CompanionRegData.eRegid)
    pub eRegid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CompanionRegData.eKeytype)
    pub eKeytype: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CompanionRegData.eIdent)
    pub eIdent: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CompanionRegData.eSkeyId)
    pub eSkeyId: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CompanionRegData.eSkeyVal)
    pub eSkeyVal: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CompanionRegData.eSkeySig)
    pub eSkeySig: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CompanionRegData.buildHash)
    pub buildHash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CompanionRegData.companionProps)
    pub companionProps: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CompanionRegData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CompanionRegData {
    fn default() -> &'a CompanionRegData {
        <CompanionRegData as ::protobuf::Message>::default_instance()
    }
}

impl CompanionRegData {
    pub fn new() -> CompanionRegData {
        ::std::default::Default::default()
    }

    // optional bytes eRegid = 1;

    pub fn eRegid(&self) -> &[u8] {
        match self.eRegid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_eRegid(&mut self) {
        self.eRegid = ::std::option::Option::None;
    }

    pub fn has_eRegid(&self) -> bool {
        self.eRegid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eRegid(&mut self, v: ::std::vec::Vec<u8>) {
        self.eRegid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eRegid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.eRegid.is_none() {
            self.eRegid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.eRegid.as_mut().unwrap()
    }

    // Take field
    pub fn take_eRegid(&mut self) -> ::std::vec::Vec<u8> {
        self.eRegid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes eKeytype = 2;

    pub fn eKeytype(&self) -> &[u8] {
        match self.eKeytype.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_eKeytype(&mut self) {
        self.eKeytype = ::std::option::Option::None;
    }

    pub fn has_eKeytype(&self) -> bool {
        self.eKeytype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eKeytype(&mut self, v: ::std::vec::Vec<u8>) {
        self.eKeytype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eKeytype(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.eKeytype.is_none() {
            self.eKeytype = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.eKeytype.as_mut().unwrap()
    }

    // Take field
    pub fn take_eKeytype(&mut self) -> ::std::vec::Vec<u8> {
        self.eKeytype.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes eIdent = 3;

    pub fn eIdent(&self) -> &[u8] {
        match self.eIdent.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_eIdent(&mut self) {
        self.eIdent = ::std::option::Option::None;
    }

    pub fn has_eIdent(&self) -> bool {
        self.eIdent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eIdent(&mut self, v: ::std::vec::Vec<u8>) {
        self.eIdent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eIdent(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.eIdent.is_none() {
            self.eIdent = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.eIdent.as_mut().unwrap()
    }

    // Take field
    pub fn take_eIdent(&mut self) -> ::std::vec::Vec<u8> {
        self.eIdent.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes eSkeyId = 4;

    pub fn eSkeyId(&self) -> &[u8] {
        match self.eSkeyId.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_eSkeyId(&mut self) {
        self.eSkeyId = ::std::option::Option::None;
    }

    pub fn has_eSkeyId(&self) -> bool {
        self.eSkeyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eSkeyId(&mut self, v: ::std::vec::Vec<u8>) {
        self.eSkeyId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eSkeyId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.eSkeyId.is_none() {
            self.eSkeyId = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.eSkeyId.as_mut().unwrap()
    }

    // Take field
    pub fn take_eSkeyId(&mut self) -> ::std::vec::Vec<u8> {
        self.eSkeyId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes eSkeyVal = 5;

    pub fn eSkeyVal(&self) -> &[u8] {
        match self.eSkeyVal.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_eSkeyVal(&mut self) {
        self.eSkeyVal = ::std::option::Option::None;
    }

    pub fn has_eSkeyVal(&self) -> bool {
        self.eSkeyVal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eSkeyVal(&mut self, v: ::std::vec::Vec<u8>) {
        self.eSkeyVal = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eSkeyVal(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.eSkeyVal.is_none() {
            self.eSkeyVal = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.eSkeyVal.as_mut().unwrap()
    }

    // Take field
    pub fn take_eSkeyVal(&mut self) -> ::std::vec::Vec<u8> {
        self.eSkeyVal.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes eSkeySig = 6;

    pub fn eSkeySig(&self) -> &[u8] {
        match self.eSkeySig.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_eSkeySig(&mut self) {
        self.eSkeySig = ::std::option::Option::None;
    }

    pub fn has_eSkeySig(&self) -> bool {
        self.eSkeySig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eSkeySig(&mut self, v: ::std::vec::Vec<u8>) {
        self.eSkeySig = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eSkeySig(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.eSkeySig.is_none() {
            self.eSkeySig = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.eSkeySig.as_mut().unwrap()
    }

    // Take field
    pub fn take_eSkeySig(&mut self) -> ::std::vec::Vec<u8> {
        self.eSkeySig.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes buildHash = 7;

    pub fn buildHash(&self) -> &[u8] {
        match self.buildHash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_buildHash(&mut self) {
        self.buildHash = ::std::option::Option::None;
    }

    pub fn has_buildHash(&self) -> bool {
        self.buildHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buildHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.buildHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buildHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.buildHash.is_none() {
            self.buildHash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.buildHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_buildHash(&mut self) -> ::std::vec::Vec<u8> {
        self.buildHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes companionProps = 8;

    pub fn companionProps(&self) -> &[u8] {
        match self.companionProps.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_companionProps(&mut self) {
        self.companionProps = ::std::option::Option::None;
    }

    pub fn has_companionProps(&self) -> bool {
        self.companionProps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_companionProps(&mut self, v: ::std::vec::Vec<u8>) {
        self.companionProps = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_companionProps(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.companionProps.is_none() {
            self.companionProps = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.companionProps.as_mut().unwrap()
    }

    // Take field
    pub fn take_companionProps(&mut self) -> ::std::vec::Vec<u8> {
        self.companionProps.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eRegid",
            |m: &CompanionRegData| { &m.eRegid },
            |m: &mut CompanionRegData| { &mut m.eRegid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eKeytype",
            |m: &CompanionRegData| { &m.eKeytype },
            |m: &mut CompanionRegData| { &mut m.eKeytype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eIdent",
            |m: &CompanionRegData| { &m.eIdent },
            |m: &mut CompanionRegData| { &mut m.eIdent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eSkeyId",
            |m: &CompanionRegData| { &m.eSkeyId },
            |m: &mut CompanionRegData| { &mut m.eSkeyId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eSkeyVal",
            |m: &CompanionRegData| { &m.eSkeyVal },
            |m: &mut CompanionRegData| { &mut m.eSkeyVal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eSkeySig",
            |m: &CompanionRegData| { &m.eSkeySig },
            |m: &mut CompanionRegData| { &mut m.eSkeySig },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buildHash",
            |m: &CompanionRegData| { &m.buildHash },
            |m: &mut CompanionRegData| { &mut m.buildHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "companionProps",
            |m: &CompanionRegData| { &m.companionProps },
            |m: &mut CompanionRegData| { &mut m.companionProps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompanionRegData>(
            "CompanionRegData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CompanionRegData {
    const NAME: &'static str = "CompanionRegData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.eRegid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.eKeytype = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.eIdent = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.eSkeyId = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.eSkeyVal = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.eSkeySig = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.buildHash = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.companionProps = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eRegid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.eKeytype.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.eIdent.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.eSkeyId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.eSkeyVal.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.eSkeySig.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.buildHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.companionProps.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eRegid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.eKeytype.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.eIdent.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.eSkeyId.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.eSkeyVal.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.eSkeySig.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.buildHash.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.companionProps.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CompanionRegData {
        CompanionRegData::new()
    }

    fn clear(&mut self) {
        self.eRegid = ::std::option::Option::None;
        self.eKeytype = ::std::option::Option::None;
        self.eIdent = ::std::option::Option::None;
        self.eSkeyId = ::std::option::Option::None;
        self.eSkeyVal = ::std::option::Option::None;
        self.eSkeySig = ::std::option::Option::None;
        self.buildHash = ::std::option::Option::None;
        self.companionProps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CompanionRegData {
        static instance: CompanionRegData = CompanionRegData {
            eRegid: ::std::option::Option::None,
            eKeytype: ::std::option::Option::None,
            eIdent: ::std::option::Option::None,
            eSkeyId: ::std::option::Option::None,
            eSkeyVal: ::std::option::Option::None,
            eSkeySig: ::std::option::Option::None,
            buildHash: ::std::option::Option::None,
            companionProps: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CompanionRegData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CompanionRegData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CompanionRegData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompanionRegData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ClientPayload)
pub struct ClientPayload {
    // message fields
    // @@protoc_insertion_point(field:ClientPayload.username)
    pub username: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ClientPayload.passive)
    pub passive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ClientPayload.userAgent)
    pub userAgent: ::protobuf::MessageField<UserAgent>,
    // @@protoc_insertion_point(field:ClientPayload.webInfo)
    pub webInfo: ::protobuf::MessageField<WebInfo>,
    // @@protoc_insertion_point(field:ClientPayload.pushName)
    pub pushName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ClientPayload.sessionId)
    pub sessionId: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ClientPayload.shortConnect)
    pub shortConnect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ClientPayload.connectType)
    pub connectType: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::ClientPayloadConnectType>>,
    // @@protoc_insertion_point(field:ClientPayload.connectReason)
    pub connectReason: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::ClientPayloadConnectReason>>,
    // @@protoc_insertion_point(field:ClientPayload.shards)
    pub shards: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:ClientPayload.dnsSource)
    pub dnsSource: ::protobuf::MessageField<DNSSource>,
    // @@protoc_insertion_point(field:ClientPayload.connectAttemptCount)
    pub connectAttemptCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ClientPayload.device)
    pub device: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ClientPayload.regData)
    pub regData: ::protobuf::MessageField<CompanionRegData>,
    // @@protoc_insertion_point(field:ClientPayload.product)
    pub product: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::ClientPayloadProduct>>,
    // @@protoc_insertion_point(field:ClientPayload.fbCat)
    pub fbCat: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ClientPayload.fbUserAgent)
    pub fbUserAgent: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ClientPayload.oc)
    pub oc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ClientPayload.lc)
    pub lc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ClientPayload.iosAppExtension)
    pub iosAppExtension: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::ClientPayloadIOSAppExtension>>,
    // @@protoc_insertion_point(field:ClientPayload.fbAppId)
    pub fbAppId: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ClientPayload.fbDeviceId)
    pub fbDeviceId: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientPayload {
    fn default() -> &'a ClientPayload {
        <ClientPayload as ::protobuf::Message>::default_instance()
    }
}

impl ClientPayload {
    pub fn new() -> ClientPayload {
        ::std::default::Default::default()
    }

    // optional uint64 username = 1;

    pub fn username(&self) -> u64 {
        self.username.unwrap_or(0)
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: u64) {
        self.username = ::std::option::Option::Some(v);
    }

    // optional bool passive = 3;

    pub fn passive(&self) -> bool {
        self.passive.unwrap_or(false)
    }

    pub fn clear_passive(&mut self) {
        self.passive = ::std::option::Option::None;
    }

    pub fn has_passive(&self) -> bool {
        self.passive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passive(&mut self, v: bool) {
        self.passive = ::std::option::Option::Some(v);
    }

    // optional string pushName = 7;

    pub fn pushName(&self) -> &str {
        match self.pushName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pushName(&mut self) {
        self.pushName = ::std::option::Option::None;
    }

    pub fn has_pushName(&self) -> bool {
        self.pushName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pushName(&mut self, v: ::std::string::String) {
        self.pushName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pushName(&mut self) -> &mut ::std::string::String {
        if self.pushName.is_none() {
            self.pushName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pushName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pushName(&mut self) -> ::std::string::String {
        self.pushName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sfixed32 sessionId = 9;

    pub fn sessionId(&self) -> i32 {
        self.sessionId.unwrap_or(0)
    }

    pub fn clear_sessionId(&mut self) {
        self.sessionId = ::std::option::Option::None;
    }

    pub fn has_sessionId(&self) -> bool {
        self.sessionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionId(&mut self, v: i32) {
        self.sessionId = ::std::option::Option::Some(v);
    }

    // optional bool shortConnect = 10;

    pub fn shortConnect(&self) -> bool {
        self.shortConnect.unwrap_or(false)
    }

    pub fn clear_shortConnect(&mut self) {
        self.shortConnect = ::std::option::Option::None;
    }

    pub fn has_shortConnect(&self) -> bool {
        self.shortConnect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortConnect(&mut self, v: bool) {
        self.shortConnect = ::std::option::Option::Some(v);
    }

    // optional .ClientPayload.ClientPayloadConnectType connectType = 12;

    pub fn connectType(&self) -> client_payload::ClientPayloadConnectType {
        match self.connectType {
            Some(e) => e.enum_value_or(client_payload::ClientPayloadConnectType::CELLULAR_UNKNOWN),
            None => client_payload::ClientPayloadConnectType::CELLULAR_UNKNOWN,
        }
    }

    pub fn clear_connectType(&mut self) {
        self.connectType = ::std::option::Option::None;
    }

    pub fn has_connectType(&self) -> bool {
        self.connectType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectType(&mut self, v: client_payload::ClientPayloadConnectType) {
        self.connectType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ClientPayload.ClientPayloadConnectReason connectReason = 13;

    pub fn connectReason(&self) -> client_payload::ClientPayloadConnectReason {
        match self.connectReason {
            Some(e) => e.enum_value_or(client_payload::ClientPayloadConnectReason::PUSH),
            None => client_payload::ClientPayloadConnectReason::PUSH,
        }
    }

    pub fn clear_connectReason(&mut self) {
        self.connectReason = ::std::option::Option::None;
    }

    pub fn has_connectReason(&self) -> bool {
        self.connectReason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectReason(&mut self, v: client_payload::ClientPayloadConnectReason) {
        self.connectReason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 connectAttemptCount = 16;

    pub fn connectAttemptCount(&self) -> u32 {
        self.connectAttemptCount.unwrap_or(0)
    }

    pub fn clear_connectAttemptCount(&mut self) {
        self.connectAttemptCount = ::std::option::Option::None;
    }

    pub fn has_connectAttemptCount(&self) -> bool {
        self.connectAttemptCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectAttemptCount(&mut self, v: u32) {
        self.connectAttemptCount = ::std::option::Option::Some(v);
    }

    // optional uint32 device = 18;

    pub fn device(&self) -> u32 {
        self.device.unwrap_or(0)
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: u32) {
        self.device = ::std::option::Option::Some(v);
    }

    // optional .ClientPayload.ClientPayloadProduct product = 20;

    pub fn product(&self) -> client_payload::ClientPayloadProduct {
        match self.product {
            Some(e) => e.enum_value_or(client_payload::ClientPayloadProduct::WHATSAPP),
            None => client_payload::ClientPayloadProduct::WHATSAPP,
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: client_payload::ClientPayloadProduct) {
        self.product = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes fbCat = 21;

    pub fn fbCat(&self) -> &[u8] {
        match self.fbCat.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fbCat(&mut self) {
        self.fbCat = ::std::option::Option::None;
    }

    pub fn has_fbCat(&self) -> bool {
        self.fbCat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbCat(&mut self, v: ::std::vec::Vec<u8>) {
        self.fbCat = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fbCat(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fbCat.is_none() {
            self.fbCat = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fbCat.as_mut().unwrap()
    }

    // Take field
    pub fn take_fbCat(&mut self) -> ::std::vec::Vec<u8> {
        self.fbCat.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fbUserAgent = 22;

    pub fn fbUserAgent(&self) -> &[u8] {
        match self.fbUserAgent.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fbUserAgent(&mut self) {
        self.fbUserAgent = ::std::option::Option::None;
    }

    pub fn has_fbUserAgent(&self) -> bool {
        self.fbUserAgent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbUserAgent(&mut self, v: ::std::vec::Vec<u8>) {
        self.fbUserAgent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fbUserAgent(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fbUserAgent.is_none() {
            self.fbUserAgent = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fbUserAgent.as_mut().unwrap()
    }

    // Take field
    pub fn take_fbUserAgent(&mut self) -> ::std::vec::Vec<u8> {
        self.fbUserAgent.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool oc = 23;

    pub fn oc(&self) -> bool {
        self.oc.unwrap_or(false)
    }

    pub fn clear_oc(&mut self) {
        self.oc = ::std::option::Option::None;
    }

    pub fn has_oc(&self) -> bool {
        self.oc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oc(&mut self, v: bool) {
        self.oc = ::std::option::Option::Some(v);
    }

    // optional int32 lc = 24;

    pub fn lc(&self) -> i32 {
        self.lc.unwrap_or(0)
    }

    pub fn clear_lc(&mut self) {
        self.lc = ::std::option::Option::None;
    }

    pub fn has_lc(&self) -> bool {
        self.lc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lc(&mut self, v: i32) {
        self.lc = ::std::option::Option::Some(v);
    }

    // optional .ClientPayload.ClientPayloadIOSAppExtension iosAppExtension = 30;

    pub fn iosAppExtension(&self) -> client_payload::ClientPayloadIOSAppExtension {
        match self.iosAppExtension {
            Some(e) => e.enum_value_or(client_payload::ClientPayloadIOSAppExtension::SHARE_EXTENSION),
            None => client_payload::ClientPayloadIOSAppExtension::SHARE_EXTENSION,
        }
    }

    pub fn clear_iosAppExtension(&mut self) {
        self.iosAppExtension = ::std::option::Option::None;
    }

    pub fn has_iosAppExtension(&self) -> bool {
        self.iosAppExtension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iosAppExtension(&mut self, v: client_payload::ClientPayloadIOSAppExtension) {
        self.iosAppExtension = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 fbAppId = 31;

    pub fn fbAppId(&self) -> u64 {
        self.fbAppId.unwrap_or(0)
    }

    pub fn clear_fbAppId(&mut self) {
        self.fbAppId = ::std::option::Option::None;
    }

    pub fn has_fbAppId(&self) -> bool {
        self.fbAppId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbAppId(&mut self, v: u64) {
        self.fbAppId = ::std::option::Option::Some(v);
    }

    // optional bytes fbDeviceId = 32;

    pub fn fbDeviceId(&self) -> &[u8] {
        match self.fbDeviceId.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fbDeviceId(&mut self) {
        self.fbDeviceId = ::std::option::Option::None;
    }

    pub fn has_fbDeviceId(&self) -> bool {
        self.fbDeviceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbDeviceId(&mut self, v: ::std::vec::Vec<u8>) {
        self.fbDeviceId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fbDeviceId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fbDeviceId.is_none() {
            self.fbDeviceId = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fbDeviceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_fbDeviceId(&mut self) -> ::std::vec::Vec<u8> {
        self.fbDeviceId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &ClientPayload| { &m.username },
            |m: &mut ClientPayload| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passive",
            |m: &ClientPayload| { &m.passive },
            |m: &mut ClientPayload| { &mut m.passive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserAgent>(
            "userAgent",
            |m: &ClientPayload| { &m.userAgent },
            |m: &mut ClientPayload| { &mut m.userAgent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebInfo>(
            "webInfo",
            |m: &ClientPayload| { &m.webInfo },
            |m: &mut ClientPayload| { &mut m.webInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pushName",
            |m: &ClientPayload| { &m.pushName },
            |m: &mut ClientPayload| { &mut m.pushName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionId",
            |m: &ClientPayload| { &m.sessionId },
            |m: &mut ClientPayload| { &mut m.sessionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shortConnect",
            |m: &ClientPayload| { &m.shortConnect },
            |m: &mut ClientPayload| { &mut m.shortConnect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectType",
            |m: &ClientPayload| { &m.connectType },
            |m: &mut ClientPayload| { &mut m.connectType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectReason",
            |m: &ClientPayload| { &m.connectReason },
            |m: &mut ClientPayload| { &mut m.connectReason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shards",
            |m: &ClientPayload| { &m.shards },
            |m: &mut ClientPayload| { &mut m.shards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DNSSource>(
            "dnsSource",
            |m: &ClientPayload| { &m.dnsSource },
            |m: &mut ClientPayload| { &mut m.dnsSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectAttemptCount",
            |m: &ClientPayload| { &m.connectAttemptCount },
            |m: &mut ClientPayload| { &mut m.connectAttemptCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &ClientPayload| { &m.device },
            |m: &mut ClientPayload| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CompanionRegData>(
            "regData",
            |m: &ClientPayload| { &m.regData },
            |m: &mut ClientPayload| { &mut m.regData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &ClientPayload| { &m.product },
            |m: &mut ClientPayload| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbCat",
            |m: &ClientPayload| { &m.fbCat },
            |m: &mut ClientPayload| { &mut m.fbCat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbUserAgent",
            |m: &ClientPayload| { &m.fbUserAgent },
            |m: &mut ClientPayload| { &mut m.fbUserAgent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oc",
            |m: &ClientPayload| { &m.oc },
            |m: &mut ClientPayload| { &mut m.oc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lc",
            |m: &ClientPayload| { &m.lc },
            |m: &mut ClientPayload| { &mut m.lc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iosAppExtension",
            |m: &ClientPayload| { &m.iosAppExtension },
            |m: &mut ClientPayload| { &mut m.iosAppExtension },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbAppId",
            |m: &ClientPayload| { &m.fbAppId },
            |m: &mut ClientPayload| { &mut m.fbAppId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbDeviceId",
            |m: &ClientPayload| { &m.fbDeviceId },
            |m: &mut ClientPayload| { &mut m.fbDeviceId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientPayload>(
            "ClientPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientPayload {
    const NAME: &'static str = "ClientPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.username = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.passive = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userAgent)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webInfo)?;
                },
                58 => {
                    self.pushName = ::std::option::Option::Some(is.read_string()?);
                },
                77 => {
                    self.sessionId = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                80 => {
                    self.shortConnect = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.connectType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.connectReason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                114 => {
                    is.read_repeated_packed_int32_into(&mut self.shards)?;
                },
                112 => {
                    self.shards.push(is.read_int32()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dnsSource)?;
                },
                128 => {
                    self.connectAttemptCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.device = ::std::option::Option::Some(is.read_uint32()?);
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.regData)?;
                },
                160 => {
                    self.product = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                170 => {
                    self.fbCat = ::std::option::Option::Some(is.read_bytes()?);
                },
                178 => {
                    self.fbUserAgent = ::std::option::Option::Some(is.read_bytes()?);
                },
                184 => {
                    self.oc = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.lc = ::std::option::Option::Some(is.read_int32()?);
                },
                240 => {
                    self.iosAppExtension = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                248 => {
                    self.fbAppId = ::std::option::Option::Some(is.read_uint64()?);
                },
                258 => {
                    self.fbDeviceId = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.username {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.passive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.userAgent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.webInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pushName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.sessionId {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shortConnect {
            my_size += 1 + 1;
        }
        if let Some(v) = self.connectType {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.connectReason {
            my_size += ::protobuf::rt::int32_size(13, v.value());
        }
        for value in &self.shards {
            my_size += ::protobuf::rt::int32_size(14, *value);
        };
        if let Some(v) = self.dnsSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.connectAttemptCount {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.device {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.regData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.product {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.fbCat.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.fbUserAgent.as_ref() {
            my_size += ::protobuf::rt::bytes_size(22, &v);
        }
        if let Some(v) = self.oc {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lc {
            my_size += ::protobuf::rt::int32_size(24, v);
        }
        if let Some(v) = self.iosAppExtension {
            my_size += ::protobuf::rt::int32_size(30, v.value());
        }
        if let Some(v) = self.fbAppId {
            my_size += ::protobuf::rt::uint64_size(31, v);
        }
        if let Some(v) = self.fbDeviceId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(32, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.username {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.passive {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.userAgent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.webInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.pushName.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.sessionId {
            os.write_sfixed32(9, v)?;
        }
        if let Some(v) = self.shortConnect {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.connectType {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connectReason {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.shards {
            os.write_int32(14, *v)?;
        };
        if let Some(v) = self.dnsSource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.connectAttemptCount {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.device {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.regData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.product {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.fbCat.as_ref() {
            os.write_bytes(21, v)?;
        }
        if let Some(v) = self.fbUserAgent.as_ref() {
            os.write_bytes(22, v)?;
        }
        if let Some(v) = self.oc {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.lc {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.iosAppExtension {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.fbAppId {
            os.write_uint64(31, v)?;
        }
        if let Some(v) = self.fbDeviceId.as_ref() {
            os.write_bytes(32, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientPayload {
        ClientPayload::new()
    }

    fn clear(&mut self) {
        self.username = ::std::option::Option::None;
        self.passive = ::std::option::Option::None;
        self.userAgent.clear();
        self.webInfo.clear();
        self.pushName = ::std::option::Option::None;
        self.sessionId = ::std::option::Option::None;
        self.shortConnect = ::std::option::Option::None;
        self.connectType = ::std::option::Option::None;
        self.connectReason = ::std::option::Option::None;
        self.shards.clear();
        self.dnsSource.clear();
        self.connectAttemptCount = ::std::option::Option::None;
        self.device = ::std::option::Option::None;
        self.regData.clear();
        self.product = ::std::option::Option::None;
        self.fbCat = ::std::option::Option::None;
        self.fbUserAgent = ::std::option::Option::None;
        self.oc = ::std::option::Option::None;
        self.lc = ::std::option::Option::None;
        self.iosAppExtension = ::std::option::Option::None;
        self.fbAppId = ::std::option::Option::None;
        self.fbDeviceId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientPayload {
        static instance: ClientPayload = ClientPayload {
            username: ::std::option::Option::None,
            passive: ::std::option::Option::None,
            userAgent: ::protobuf::MessageField::none(),
            webInfo: ::protobuf::MessageField::none(),
            pushName: ::std::option::Option::None,
            sessionId: ::std::option::Option::None,
            shortConnect: ::std::option::Option::None,
            connectType: ::std::option::Option::None,
            connectReason: ::std::option::Option::None,
            shards: ::std::vec::Vec::new(),
            dnsSource: ::protobuf::MessageField::none(),
            connectAttemptCount: ::std::option::Option::None,
            device: ::std::option::Option::None,
            regData: ::protobuf::MessageField::none(),
            product: ::std::option::Option::None,
            fbCat: ::std::option::Option::None,
            fbUserAgent: ::std::option::Option::None,
            oc: ::std::option::Option::None,
            lc: ::std::option::Option::None,
            iosAppExtension: ::std::option::Option::None,
            fbAppId: ::std::option::Option::None,
            fbDeviceId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClientPayload`
pub mod client_payload {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ClientPayload.ClientPayloadConnectType)
    pub enum ClientPayloadConnectType {
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_UNKNOWN)
        CELLULAR_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.WIFI_UNKNOWN)
        WIFI_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_EDGE)
        CELLULAR_EDGE = 100,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_IDEN)
        CELLULAR_IDEN = 101,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_UMTS)
        CELLULAR_UMTS = 102,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_EVDO)
        CELLULAR_EVDO = 103,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_GPRS)
        CELLULAR_GPRS = 104,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_HSDPA)
        CELLULAR_HSDPA = 105,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_HSUPA)
        CELLULAR_HSUPA = 106,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_HSPA)
        CELLULAR_HSPA = 107,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_CDMA)
        CELLULAR_CDMA = 108,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_1XRTT)
        CELLULAR_1XRTT = 109,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_EHRPD)
        CELLULAR_EHRPD = 110,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_LTE)
        CELLULAR_LTE = 111,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectType.CELLULAR_HSPAP)
        CELLULAR_HSPAP = 112,
    }

    impl ::protobuf::Enum for ClientPayloadConnectType {
        const NAME: &'static str = "ClientPayloadConnectType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ClientPayloadConnectType> {
            match value {
                0 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_UNKNOWN),
                1 => ::std::option::Option::Some(ClientPayloadConnectType::WIFI_UNKNOWN),
                100 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_EDGE),
                101 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_IDEN),
                102 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_UMTS),
                103 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_EVDO),
                104 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_GPRS),
                105 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_HSDPA),
                106 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_HSUPA),
                107 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_HSPA),
                108 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_CDMA),
                109 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_1XRTT),
                110 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_EHRPD),
                111 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_LTE),
                112 => ::std::option::Option::Some(ClientPayloadConnectType::CELLULAR_HSPAP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ClientPayloadConnectType] = &[
            ClientPayloadConnectType::CELLULAR_UNKNOWN,
            ClientPayloadConnectType::WIFI_UNKNOWN,
            ClientPayloadConnectType::CELLULAR_EDGE,
            ClientPayloadConnectType::CELLULAR_IDEN,
            ClientPayloadConnectType::CELLULAR_UMTS,
            ClientPayloadConnectType::CELLULAR_EVDO,
            ClientPayloadConnectType::CELLULAR_GPRS,
            ClientPayloadConnectType::CELLULAR_HSDPA,
            ClientPayloadConnectType::CELLULAR_HSUPA,
            ClientPayloadConnectType::CELLULAR_HSPA,
            ClientPayloadConnectType::CELLULAR_CDMA,
            ClientPayloadConnectType::CELLULAR_1XRTT,
            ClientPayloadConnectType::CELLULAR_EHRPD,
            ClientPayloadConnectType::CELLULAR_LTE,
            ClientPayloadConnectType::CELLULAR_HSPAP,
        ];
    }

    impl ::protobuf::EnumFull for ClientPayloadConnectType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.ClientPayloadConnectType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ClientPayloadConnectType::CELLULAR_UNKNOWN => 0,
                ClientPayloadConnectType::WIFI_UNKNOWN => 1,
                ClientPayloadConnectType::CELLULAR_EDGE => 2,
                ClientPayloadConnectType::CELLULAR_IDEN => 3,
                ClientPayloadConnectType::CELLULAR_UMTS => 4,
                ClientPayloadConnectType::CELLULAR_EVDO => 5,
                ClientPayloadConnectType::CELLULAR_GPRS => 6,
                ClientPayloadConnectType::CELLULAR_HSDPA => 7,
                ClientPayloadConnectType::CELLULAR_HSUPA => 8,
                ClientPayloadConnectType::CELLULAR_HSPA => 9,
                ClientPayloadConnectType::CELLULAR_CDMA => 10,
                ClientPayloadConnectType::CELLULAR_1XRTT => 11,
                ClientPayloadConnectType::CELLULAR_EHRPD => 12,
                ClientPayloadConnectType::CELLULAR_LTE => 13,
                ClientPayloadConnectType::CELLULAR_HSPAP => 14,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ClientPayloadConnectType {
        fn default() -> Self {
            ClientPayloadConnectType::CELLULAR_UNKNOWN
        }
    }

    impl ClientPayloadConnectType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClientPayloadConnectType>("ClientPayload.ClientPayloadConnectType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ClientPayload.ClientPayloadConnectReason)
    pub enum ClientPayloadConnectReason {
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectReason.PUSH)
        PUSH = 0,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectReason.USER_ACTIVATED)
        USER_ACTIVATED = 1,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectReason.SCHEDULED)
        SCHEDULED = 2,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectReason.ERROR_RECONNECT)
        ERROR_RECONNECT = 3,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectReason.NETWORK_SWITCH)
        NETWORK_SWITCH = 4,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadConnectReason.PING_RECONNECT)
        PING_RECONNECT = 5,
    }

    impl ::protobuf::Enum for ClientPayloadConnectReason {
        const NAME: &'static str = "ClientPayloadConnectReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ClientPayloadConnectReason> {
            match value {
                0 => ::std::option::Option::Some(ClientPayloadConnectReason::PUSH),
                1 => ::std::option::Option::Some(ClientPayloadConnectReason::USER_ACTIVATED),
                2 => ::std::option::Option::Some(ClientPayloadConnectReason::SCHEDULED),
                3 => ::std::option::Option::Some(ClientPayloadConnectReason::ERROR_RECONNECT),
                4 => ::std::option::Option::Some(ClientPayloadConnectReason::NETWORK_SWITCH),
                5 => ::std::option::Option::Some(ClientPayloadConnectReason::PING_RECONNECT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ClientPayloadConnectReason] = &[
            ClientPayloadConnectReason::PUSH,
            ClientPayloadConnectReason::USER_ACTIVATED,
            ClientPayloadConnectReason::SCHEDULED,
            ClientPayloadConnectReason::ERROR_RECONNECT,
            ClientPayloadConnectReason::NETWORK_SWITCH,
            ClientPayloadConnectReason::PING_RECONNECT,
        ];
    }

    impl ::protobuf::EnumFull for ClientPayloadConnectReason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.ClientPayloadConnectReason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ClientPayloadConnectReason {
        fn default() -> Self {
            ClientPayloadConnectReason::PUSH
        }
    }

    impl ClientPayloadConnectReason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClientPayloadConnectReason>("ClientPayload.ClientPayloadConnectReason")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ClientPayload.ClientPayloadProduct)
    pub enum ClientPayloadProduct {
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadProduct.WHATSAPP)
        WHATSAPP = 0,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadProduct.MESSENGER)
        MESSENGER = 1,
    }

    impl ::protobuf::Enum for ClientPayloadProduct {
        const NAME: &'static str = "ClientPayloadProduct";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ClientPayloadProduct> {
            match value {
                0 => ::std::option::Option::Some(ClientPayloadProduct::WHATSAPP),
                1 => ::std::option::Option::Some(ClientPayloadProduct::MESSENGER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ClientPayloadProduct] = &[
            ClientPayloadProduct::WHATSAPP,
            ClientPayloadProduct::MESSENGER,
        ];
    }

    impl ::protobuf::EnumFull for ClientPayloadProduct {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.ClientPayloadProduct").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ClientPayloadProduct {
        fn default() -> Self {
            ClientPayloadProduct::WHATSAPP
        }
    }

    impl ClientPayloadProduct {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClientPayloadProduct>("ClientPayload.ClientPayloadProduct")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ClientPayload.ClientPayloadIOSAppExtension)
    pub enum ClientPayloadIOSAppExtension {
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadIOSAppExtension.SHARE_EXTENSION)
        SHARE_EXTENSION = 0,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadIOSAppExtension.SERVICE_EXTENSION)
        SERVICE_EXTENSION = 1,
        // @@protoc_insertion_point(enum_value:ClientPayload.ClientPayloadIOSAppExtension.INTENTS_EXTENSION)
        INTENTS_EXTENSION = 2,
    }

    impl ::protobuf::Enum for ClientPayloadIOSAppExtension {
        const NAME: &'static str = "ClientPayloadIOSAppExtension";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ClientPayloadIOSAppExtension> {
            match value {
                0 => ::std::option::Option::Some(ClientPayloadIOSAppExtension::SHARE_EXTENSION),
                1 => ::std::option::Option::Some(ClientPayloadIOSAppExtension::SERVICE_EXTENSION),
                2 => ::std::option::Option::Some(ClientPayloadIOSAppExtension::INTENTS_EXTENSION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ClientPayloadIOSAppExtension] = &[
            ClientPayloadIOSAppExtension::SHARE_EXTENSION,
            ClientPayloadIOSAppExtension::SERVICE_EXTENSION,
            ClientPayloadIOSAppExtension::INTENTS_EXTENSION,
        ];
    }

    impl ::protobuf::EnumFull for ClientPayloadIOSAppExtension {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.ClientPayloadIOSAppExtension").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ClientPayloadIOSAppExtension {
        fn default() -> Self {
            ClientPayloadIOSAppExtension::SHARE_EXTENSION
        }
    }

    impl ClientPayloadIOSAppExtension {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClientPayloadIOSAppExtension>("ClientPayload.ClientPayloadIOSAppExtension")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NoiseCertificateDetails)
pub struct NoiseCertificateDetails {
    // message fields
    // @@protoc_insertion_point(field:NoiseCertificateDetails.serial)
    pub serial: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:NoiseCertificateDetails.issuer)
    pub issuer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NoiseCertificateDetails.expires)
    pub expires: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:NoiseCertificateDetails.subject)
    pub subject: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NoiseCertificateDetails.key)
    pub key: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:NoiseCertificateDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoiseCertificateDetails {
    fn default() -> &'a NoiseCertificateDetails {
        <NoiseCertificateDetails as ::protobuf::Message>::default_instance()
    }
}

impl NoiseCertificateDetails {
    pub fn new() -> NoiseCertificateDetails {
        ::std::default::Default::default()
    }

    // optional uint32 serial = 1;

    pub fn serial(&self) -> u32 {
        self.serial.unwrap_or(0)
    }

    pub fn clear_serial(&mut self) {
        self.serial = ::std::option::Option::None;
    }

    pub fn has_serial(&self) -> bool {
        self.serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial(&mut self, v: u32) {
        self.serial = ::std::option::Option::Some(v);
    }

    // optional string issuer = 2;

    pub fn issuer(&self) -> &str {
        match self.issuer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuer(&mut self) {
        self.issuer = ::std::option::Option::None;
    }

    pub fn has_issuer(&self) -> bool {
        self.issuer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuer(&mut self, v: ::std::string::String) {
        self.issuer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
        if self.issuer.is_none() {
            self.issuer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuer.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuer(&mut self) -> ::std::string::String {
        self.issuer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 expires = 3;

    pub fn expires(&self) -> u64 {
        self.expires.unwrap_or(0)
    }

    pub fn clear_expires(&mut self) {
        self.expires = ::std::option::Option::None;
    }

    pub fn has_expires(&self) -> bool {
        self.expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expires(&mut self, v: u64) {
        self.expires = ::std::option::Option::Some(v);
    }

    // optional string subject = 4;

    pub fn subject(&self) -> &str {
        match self.subject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subject(&mut self) {
        self.subject = ::std::option::Option::None;
    }

    pub fn has_subject(&self) -> bool {
        self.subject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        if self.subject.is_none() {
            self.subject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subject.as_mut().unwrap()
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        self.subject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes key = 5;

    pub fn key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serial",
            |m: &NoiseCertificateDetails| { &m.serial },
            |m: &mut NoiseCertificateDetails| { &mut m.serial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuer",
            |m: &NoiseCertificateDetails| { &m.issuer },
            |m: &mut NoiseCertificateDetails| { &mut m.issuer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expires",
            |m: &NoiseCertificateDetails| { &m.expires },
            |m: &mut NoiseCertificateDetails| { &mut m.expires },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject",
            |m: &NoiseCertificateDetails| { &m.subject },
            |m: &mut NoiseCertificateDetails| { &mut m.subject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &NoiseCertificateDetails| { &m.key },
            |m: &mut NoiseCertificateDetails| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoiseCertificateDetails>(
            "NoiseCertificateDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoiseCertificateDetails {
    const NAME: &'static str = "NoiseCertificateDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serial = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.issuer = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.expires = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.subject = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.key = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serial {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.issuer.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expires {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.subject.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serial {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.issuer.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.expires {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.subject.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoiseCertificateDetails {
        NoiseCertificateDetails::new()
    }

    fn clear(&mut self) {
        self.serial = ::std::option::Option::None;
        self.issuer = ::std::option::Option::None;
        self.expires = ::std::option::Option::None;
        self.subject = ::std::option::Option::None;
        self.key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoiseCertificateDetails {
        static instance: NoiseCertificateDetails = NoiseCertificateDetails {
            serial: ::std::option::Option::None,
            issuer: ::std::option::Option::None,
            expires: ::std::option::Option::None,
            subject: ::std::option::Option::None,
            key: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoiseCertificateDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoiseCertificateDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoiseCertificateDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoiseCertificateDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NoiseCertificate)
pub struct NoiseCertificate {
    // message fields
    // @@protoc_insertion_point(field:NoiseCertificate.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:NoiseCertificate.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:NoiseCertificate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoiseCertificate {
    fn default() -> &'a NoiseCertificate {
        <NoiseCertificate as ::protobuf::Message>::default_instance()
    }
}

impl NoiseCertificate {
    pub fn new() -> NoiseCertificate {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &NoiseCertificate| { &m.details },
            |m: &mut NoiseCertificate| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &NoiseCertificate| { &m.signature },
            |m: &mut NoiseCertificate| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoiseCertificate>(
            "NoiseCertificate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoiseCertificate {
    const NAME: &'static str = "NoiseCertificate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoiseCertificate {
        NoiseCertificate::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoiseCertificate {
        static instance: NoiseCertificate = NoiseCertificate {
            details: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoiseCertificate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoiseCertificate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoiseCertificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoiseCertificate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ClientHello)
pub struct ClientHello {
    // message fields
    // @@protoc_insertion_point(field:ClientHello.ephemeral)
    pub ephemeral: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ClientHello.static)
    pub static_: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ClientHello.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientHello {
    fn default() -> &'a ClientHello {
        <ClientHello as ::protobuf::Message>::default_instance()
    }
}

impl ClientHello {
    pub fn new() -> ClientHello {
        ::std::default::Default::default()
    }

    // optional bytes ephemeral = 1;

    pub fn ephemeral(&self) -> &[u8] {
        match self.ephemeral.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ephemeral(&mut self) {
        self.ephemeral = ::std::option::Option::None;
    }

    pub fn has_ephemeral(&self) -> bool {
        self.ephemeral.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral(&mut self, v: ::std::vec::Vec<u8>) {
        self.ephemeral = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeral(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ephemeral.is_none() {
            self.ephemeral = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ephemeral.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeral(&mut self) -> ::std::vec::Vec<u8> {
        self.ephemeral.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes static = 2;

    pub fn static_(&self) -> &[u8] {
        match self.static_.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_static_(&mut self) {
        self.static_ = ::std::option::Option::None;
    }

    pub fn has_static(&self) -> bool {
        self.static_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static(&mut self, v: ::std::vec::Vec<u8>) {
        self.static_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.static_.is_none() {
            self.static_ = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.static_.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_(&mut self) -> ::std::vec::Vec<u8> {
        self.static_.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeral",
            |m: &ClientHello| { &m.ephemeral },
            |m: &mut ClientHello| { &mut m.ephemeral },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "static",
            |m: &ClientHello| { &m.static_ },
            |m: &mut ClientHello| { &mut m.static_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &ClientHello| { &m.payload },
            |m: &mut ClientHello| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientHello>(
            "ClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientHello {
    const NAME: &'static str = "ClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ephemeral = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.static_ = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ephemeral.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.static_.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ephemeral.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.static_.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientHello {
        ClientHello::new()
    }

    fn clear(&mut self) {
        self.ephemeral = ::std::option::Option::None;
        self.static_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientHello {
        static instance: ClientHello = ClientHello {
            ephemeral: ::std::option::Option::None,
            static_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ServerHello)
pub struct ServerHello {
    // message fields
    // @@protoc_insertion_point(field:ServerHello.ephemeral)
    pub ephemeral: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ServerHello.static)
    pub static_: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ServerHello.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ServerHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerHello {
    fn default() -> &'a ServerHello {
        <ServerHello as ::protobuf::Message>::default_instance()
    }
}

impl ServerHello {
    pub fn new() -> ServerHello {
        ::std::default::Default::default()
    }

    // optional bytes ephemeral = 1;

    pub fn ephemeral(&self) -> &[u8] {
        match self.ephemeral.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ephemeral(&mut self) {
        self.ephemeral = ::std::option::Option::None;
    }

    pub fn has_ephemeral(&self) -> bool {
        self.ephemeral.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral(&mut self, v: ::std::vec::Vec<u8>) {
        self.ephemeral = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeral(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ephemeral.is_none() {
            self.ephemeral = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ephemeral.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeral(&mut self) -> ::std::vec::Vec<u8> {
        self.ephemeral.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes static = 2;

    pub fn static_(&self) -> &[u8] {
        match self.static_.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_static_(&mut self) {
        self.static_ = ::std::option::Option::None;
    }

    pub fn has_static(&self) -> bool {
        self.static_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static(&mut self, v: ::std::vec::Vec<u8>) {
        self.static_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.static_.is_none() {
            self.static_ = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.static_.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_(&mut self) -> ::std::vec::Vec<u8> {
        self.static_.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeral",
            |m: &ServerHello| { &m.ephemeral },
            |m: &mut ServerHello| { &mut m.ephemeral },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "static",
            |m: &ServerHello| { &m.static_ },
            |m: &mut ServerHello| { &mut m.static_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &ServerHello| { &m.payload },
            |m: &mut ServerHello| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerHello>(
            "ServerHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerHello {
    const NAME: &'static str = "ServerHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ephemeral = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.static_ = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ephemeral.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.static_.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ephemeral.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.static_.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerHello {
        ServerHello::new()
    }

    fn clear(&mut self) {
        self.ephemeral = ::std::option::Option::None;
        self.static_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerHello {
        static instance: ServerHello = ServerHello {
            ephemeral: ::std::option::Option::None,
            static_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ClientFinish)
pub struct ClientFinish {
    // message fields
    // @@protoc_insertion_point(field:ClientFinish.static)
    pub static_: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ClientFinish.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ClientFinish.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientFinish {
    fn default() -> &'a ClientFinish {
        <ClientFinish as ::protobuf::Message>::default_instance()
    }
}

impl ClientFinish {
    pub fn new() -> ClientFinish {
        ::std::default::Default::default()
    }

    // optional bytes static = 1;

    pub fn static_(&self) -> &[u8] {
        match self.static_.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_static_(&mut self) {
        self.static_ = ::std::option::Option::None;
    }

    pub fn has_static(&self) -> bool {
        self.static_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static(&mut self, v: ::std::vec::Vec<u8>) {
        self.static_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.static_.is_none() {
            self.static_ = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.static_.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_(&mut self) -> ::std::vec::Vec<u8> {
        self.static_.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "static",
            |m: &ClientFinish| { &m.static_ },
            |m: &mut ClientFinish| { &mut m.static_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &ClientFinish| { &m.payload },
            |m: &mut ClientFinish| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientFinish>(
            "ClientFinish",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientFinish {
    const NAME: &'static str = "ClientFinish";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.static_ = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.static_.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.static_.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientFinish {
        ClientFinish::new()
    }

    fn clear(&mut self) {
        self.static_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientFinish {
        static instance: ClientFinish = ClientFinish {
            static_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientFinish {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientFinish").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientFinish {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientFinish {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HandshakeMessage)
pub struct HandshakeMessage {
    // message fields
    // @@protoc_insertion_point(field:HandshakeMessage.clientHello)
    pub clientHello: ::protobuf::MessageField<ClientHello>,
    // @@protoc_insertion_point(field:HandshakeMessage.serverHello)
    pub serverHello: ::protobuf::MessageField<ServerHello>,
    // @@protoc_insertion_point(field:HandshakeMessage.clientFinish)
    pub clientFinish: ::protobuf::MessageField<ClientFinish>,
    // special fields
    // @@protoc_insertion_point(special_field:HandshakeMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeMessage {
    fn default() -> &'a HandshakeMessage {
        <HandshakeMessage as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeMessage {
    pub fn new() -> HandshakeMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientHello>(
            "clientHello",
            |m: &HandshakeMessage| { &m.clientHello },
            |m: &mut HandshakeMessage| { &mut m.clientHello },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServerHello>(
            "serverHello",
            |m: &HandshakeMessage| { &m.serverHello },
            |m: &mut HandshakeMessage| { &mut m.serverHello },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClientFinish>(
            "clientFinish",
            |m: &HandshakeMessage| { &m.clientFinish },
            |m: &mut HandshakeMessage| { &mut m.clientFinish },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeMessage>(
            "HandshakeMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeMessage {
    const NAME: &'static str = "HandshakeMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientHello)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.serverHello)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientFinish)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clientHello.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.serverHello.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clientFinish.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clientHello.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.serverHello.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.clientFinish.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeMessage {
        HandshakeMessage::new()
    }

    fn clear(&mut self) {
        self.clientHello.clear();
        self.serverHello.clear();
        self.clientFinish.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeMessage {
        static instance: HandshakeMessage = HandshakeMessage {
            clientHello: ::protobuf::MessageField::none(),
            serverHello: ::protobuf::MessageField::none(),
            clientFinish: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BizIdentityInfo)
pub struct BizIdentityInfo {
    // message fields
    // @@protoc_insertion_point(field:BizIdentityInfo.vlevel)
    pub vlevel: ::std::option::Option<::protobuf::EnumOrUnknown<biz_identity_info::BizIdentityInfoVerifiedLevelValue>>,
    // @@protoc_insertion_point(field:BizIdentityInfo.vnameCert)
    pub vnameCert: ::protobuf::MessageField<VerifiedNameCertificate>,
    // @@protoc_insertion_point(field:BizIdentityInfo.signed)
    pub signed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:BizIdentityInfo.revoked)
    pub revoked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:BizIdentityInfo.hostStorage)
    pub hostStorage: ::std::option::Option<::protobuf::EnumOrUnknown<biz_identity_info::BizIdentityInfoHostStorageType>>,
    // @@protoc_insertion_point(field:BizIdentityInfo.actualActors)
    pub actualActors: ::std::option::Option<::protobuf::EnumOrUnknown<biz_identity_info::BizIdentityInfoActualActorsType>>,
    // @@protoc_insertion_point(field:BizIdentityInfo.privacyModeTs)
    pub privacyModeTs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:BizIdentityInfo.featureControls)
    pub featureControls: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:BizIdentityInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BizIdentityInfo {
    fn default() -> &'a BizIdentityInfo {
        <BizIdentityInfo as ::protobuf::Message>::default_instance()
    }
}

impl BizIdentityInfo {
    pub fn new() -> BizIdentityInfo {
        ::std::default::Default::default()
    }

    // optional .BizIdentityInfo.BizIdentityInfoVerifiedLevelValue vlevel = 1;

    pub fn vlevel(&self) -> biz_identity_info::BizIdentityInfoVerifiedLevelValue {
        match self.vlevel {
            Some(e) => e.enum_value_or(biz_identity_info::BizIdentityInfoVerifiedLevelValue::UNKNOWN),
            None => biz_identity_info::BizIdentityInfoVerifiedLevelValue::UNKNOWN,
        }
    }

    pub fn clear_vlevel(&mut self) {
        self.vlevel = ::std::option::Option::None;
    }

    pub fn has_vlevel(&self) -> bool {
        self.vlevel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vlevel(&mut self, v: biz_identity_info::BizIdentityInfoVerifiedLevelValue) {
        self.vlevel = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool signed = 3;

    pub fn signed(&self) -> bool {
        self.signed.unwrap_or(false)
    }

    pub fn clear_signed(&mut self) {
        self.signed = ::std::option::Option::None;
    }

    pub fn has_signed(&self) -> bool {
        self.signed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signed(&mut self, v: bool) {
        self.signed = ::std::option::Option::Some(v);
    }

    // optional bool revoked = 4;

    pub fn revoked(&self) -> bool {
        self.revoked.unwrap_or(false)
    }

    pub fn clear_revoked(&mut self) {
        self.revoked = ::std::option::Option::None;
    }

    pub fn has_revoked(&self) -> bool {
        self.revoked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revoked(&mut self, v: bool) {
        self.revoked = ::std::option::Option::Some(v);
    }

    // optional .BizIdentityInfo.BizIdentityInfoHostStorageType hostStorage = 5;

    pub fn hostStorage(&self) -> biz_identity_info::BizIdentityInfoHostStorageType {
        match self.hostStorage {
            Some(e) => e.enum_value_or(biz_identity_info::BizIdentityInfoHostStorageType::ON_PREMISE),
            None => biz_identity_info::BizIdentityInfoHostStorageType::ON_PREMISE,
        }
    }

    pub fn clear_hostStorage(&mut self) {
        self.hostStorage = ::std::option::Option::None;
    }

    pub fn has_hostStorage(&self) -> bool {
        self.hostStorage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostStorage(&mut self, v: biz_identity_info::BizIdentityInfoHostStorageType) {
        self.hostStorage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .BizIdentityInfo.BizIdentityInfoActualActorsType actualActors = 6;

    pub fn actualActors(&self) -> biz_identity_info::BizIdentityInfoActualActorsType {
        match self.actualActors {
            Some(e) => e.enum_value_or(biz_identity_info::BizIdentityInfoActualActorsType::SELF),
            None => biz_identity_info::BizIdentityInfoActualActorsType::SELF,
        }
    }

    pub fn clear_actualActors(&mut self) {
        self.actualActors = ::std::option::Option::None;
    }

    pub fn has_actualActors(&self) -> bool {
        self.actualActors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actualActors(&mut self, v: biz_identity_info::BizIdentityInfoActualActorsType) {
        self.actualActors = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 privacyModeTs = 7;

    pub fn privacyModeTs(&self) -> u64 {
        self.privacyModeTs.unwrap_or(0)
    }

    pub fn clear_privacyModeTs(&mut self) {
        self.privacyModeTs = ::std::option::Option::None;
    }

    pub fn has_privacyModeTs(&self) -> bool {
        self.privacyModeTs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacyModeTs(&mut self, v: u64) {
        self.privacyModeTs = ::std::option::Option::Some(v);
    }

    // optional uint64 featureControls = 8;

    pub fn featureControls(&self) -> u64 {
        self.featureControls.unwrap_or(0)
    }

    pub fn clear_featureControls(&mut self) {
        self.featureControls = ::std::option::Option::None;
    }

    pub fn has_featureControls(&self) -> bool {
        self.featureControls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featureControls(&mut self, v: u64) {
        self.featureControls = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vlevel",
            |m: &BizIdentityInfo| { &m.vlevel },
            |m: &mut BizIdentityInfo| { &mut m.vlevel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VerifiedNameCertificate>(
            "vnameCert",
            |m: &BizIdentityInfo| { &m.vnameCert },
            |m: &mut BizIdentityInfo| { &mut m.vnameCert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signed",
            |m: &BizIdentityInfo| { &m.signed },
            |m: &mut BizIdentityInfo| { &mut m.signed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revoked",
            |m: &BizIdentityInfo| { &m.revoked },
            |m: &mut BizIdentityInfo| { &mut m.revoked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostStorage",
            |m: &BizIdentityInfo| { &m.hostStorage },
            |m: &mut BizIdentityInfo| { &mut m.hostStorage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actualActors",
            |m: &BizIdentityInfo| { &m.actualActors },
            |m: &mut BizIdentityInfo| { &mut m.actualActors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "privacyModeTs",
            |m: &BizIdentityInfo| { &m.privacyModeTs },
            |m: &mut BizIdentityInfo| { &mut m.privacyModeTs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featureControls",
            |m: &BizIdentityInfo| { &m.featureControls },
            |m: &mut BizIdentityInfo| { &mut m.featureControls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BizIdentityInfo>(
            "BizIdentityInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BizIdentityInfo {
    const NAME: &'static str = "BizIdentityInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.vlevel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vnameCert)?;
                },
                24 => {
                    self.signed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.revoked = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.hostStorage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.actualActors = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.privacyModeTs = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.featureControls = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vlevel {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.vnameCert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.signed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.revoked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hostStorage {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.actualActors {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.privacyModeTs {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.featureControls {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vlevel {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.vnameCert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.signed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.revoked {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.hostStorage {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.actualActors {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.privacyModeTs {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.featureControls {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BizIdentityInfo {
        BizIdentityInfo::new()
    }

    fn clear(&mut self) {
        self.vlevel = ::std::option::Option::None;
        self.vnameCert.clear();
        self.signed = ::std::option::Option::None;
        self.revoked = ::std::option::Option::None;
        self.hostStorage = ::std::option::Option::None;
        self.actualActors = ::std::option::Option::None;
        self.privacyModeTs = ::std::option::Option::None;
        self.featureControls = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BizIdentityInfo {
        static instance: BizIdentityInfo = BizIdentityInfo {
            vlevel: ::std::option::Option::None,
            vnameCert: ::protobuf::MessageField::none(),
            signed: ::std::option::Option::None,
            revoked: ::std::option::Option::None,
            hostStorage: ::std::option::Option::None,
            actualActors: ::std::option::Option::None,
            privacyModeTs: ::std::option::Option::None,
            featureControls: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BizIdentityInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BizIdentityInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BizIdentityInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BizIdentityInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BizIdentityInfo`
pub mod biz_identity_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:BizIdentityInfo.BizIdentityInfoVerifiedLevelValue)
    pub enum BizIdentityInfoVerifiedLevelValue {
        // @@protoc_insertion_point(enum_value:BizIdentityInfo.BizIdentityInfoVerifiedLevelValue.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:BizIdentityInfo.BizIdentityInfoVerifiedLevelValue.LOW)
        LOW = 1,
        // @@protoc_insertion_point(enum_value:BizIdentityInfo.BizIdentityInfoVerifiedLevelValue.HIGH)
        HIGH = 2,
    }

    impl ::protobuf::Enum for BizIdentityInfoVerifiedLevelValue {
        const NAME: &'static str = "BizIdentityInfoVerifiedLevelValue";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BizIdentityInfoVerifiedLevelValue> {
            match value {
                0 => ::std::option::Option::Some(BizIdentityInfoVerifiedLevelValue::UNKNOWN),
                1 => ::std::option::Option::Some(BizIdentityInfoVerifiedLevelValue::LOW),
                2 => ::std::option::Option::Some(BizIdentityInfoVerifiedLevelValue::HIGH),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BizIdentityInfoVerifiedLevelValue] = &[
            BizIdentityInfoVerifiedLevelValue::UNKNOWN,
            BizIdentityInfoVerifiedLevelValue::LOW,
            BizIdentityInfoVerifiedLevelValue::HIGH,
        ];
    }

    impl ::protobuf::EnumFull for BizIdentityInfoVerifiedLevelValue {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizIdentityInfo.BizIdentityInfoVerifiedLevelValue").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BizIdentityInfoVerifiedLevelValue {
        fn default() -> Self {
            BizIdentityInfoVerifiedLevelValue::UNKNOWN
        }
    }

    impl BizIdentityInfoVerifiedLevelValue {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BizIdentityInfoVerifiedLevelValue>("BizIdentityInfo.BizIdentityInfoVerifiedLevelValue")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:BizIdentityInfo.BizIdentityInfoHostStorageType)
    pub enum BizIdentityInfoHostStorageType {
        // @@protoc_insertion_point(enum_value:BizIdentityInfo.BizIdentityInfoHostStorageType.ON_PREMISE)
        ON_PREMISE = 0,
        // @@protoc_insertion_point(enum_value:BizIdentityInfo.BizIdentityInfoHostStorageType.FACEBOOK)
        FACEBOOK = 1,
    }

    impl ::protobuf::Enum for BizIdentityInfoHostStorageType {
        const NAME: &'static str = "BizIdentityInfoHostStorageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BizIdentityInfoHostStorageType> {
            match value {
                0 => ::std::option::Option::Some(BizIdentityInfoHostStorageType::ON_PREMISE),
                1 => ::std::option::Option::Some(BizIdentityInfoHostStorageType::FACEBOOK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BizIdentityInfoHostStorageType] = &[
            BizIdentityInfoHostStorageType::ON_PREMISE,
            BizIdentityInfoHostStorageType::FACEBOOK,
        ];
    }

    impl ::protobuf::EnumFull for BizIdentityInfoHostStorageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizIdentityInfo.BizIdentityInfoHostStorageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BizIdentityInfoHostStorageType {
        fn default() -> Self {
            BizIdentityInfoHostStorageType::ON_PREMISE
        }
    }

    impl BizIdentityInfoHostStorageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BizIdentityInfoHostStorageType>("BizIdentityInfo.BizIdentityInfoHostStorageType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:BizIdentityInfo.BizIdentityInfoActualActorsType)
    pub enum BizIdentityInfoActualActorsType {
        // @@protoc_insertion_point(enum_value:BizIdentityInfo.BizIdentityInfoActualActorsType.SELF)
        SELF = 0,
        // @@protoc_insertion_point(enum_value:BizIdentityInfo.BizIdentityInfoActualActorsType.BSP)
        BSP = 1,
    }

    impl ::protobuf::Enum for BizIdentityInfoActualActorsType {
        const NAME: &'static str = "BizIdentityInfoActualActorsType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BizIdentityInfoActualActorsType> {
            match value {
                0 => ::std::option::Option::Some(BizIdentityInfoActualActorsType::SELF),
                1 => ::std::option::Option::Some(BizIdentityInfoActualActorsType::BSP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BizIdentityInfoActualActorsType] = &[
            BizIdentityInfoActualActorsType::SELF,
            BizIdentityInfoActualActorsType::BSP,
        ];
    }

    impl ::protobuf::EnumFull for BizIdentityInfoActualActorsType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizIdentityInfo.BizIdentityInfoActualActorsType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BizIdentityInfoActualActorsType {
        fn default() -> Self {
            BizIdentityInfoActualActorsType::SELF
        }
    }

    impl BizIdentityInfoActualActorsType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BizIdentityInfoActualActorsType>("BizIdentityInfo.BizIdentityInfoActualActorsType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BizAccountLinkInfo)
pub struct BizAccountLinkInfo {
    // message fields
    // @@protoc_insertion_point(field:BizAccountLinkInfo.whatsappBizAcctFbid)
    pub whatsappBizAcctFbid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:BizAccountLinkInfo.whatsappAcctNumber)
    pub whatsappAcctNumber: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:BizAccountLinkInfo.issueTime)
    pub issueTime: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:BizAccountLinkInfo.hostStorage)
    pub hostStorage: ::std::option::Option<::protobuf::EnumOrUnknown<biz_account_link_info::BizAccountLinkInfoHostStorageType>>,
    // @@protoc_insertion_point(field:BizAccountLinkInfo.accountType)
    pub accountType: ::std::option::Option<::protobuf::EnumOrUnknown<biz_account_link_info::BizAccountLinkInfoAccountType>>,
    // special fields
    // @@protoc_insertion_point(special_field:BizAccountLinkInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BizAccountLinkInfo {
    fn default() -> &'a BizAccountLinkInfo {
        <BizAccountLinkInfo as ::protobuf::Message>::default_instance()
    }
}

impl BizAccountLinkInfo {
    pub fn new() -> BizAccountLinkInfo {
        ::std::default::Default::default()
    }

    // optional uint64 whatsappBizAcctFbid = 1;

    pub fn whatsappBizAcctFbid(&self) -> u64 {
        self.whatsappBizAcctFbid.unwrap_or(0)
    }

    pub fn clear_whatsappBizAcctFbid(&mut self) {
        self.whatsappBizAcctFbid = ::std::option::Option::None;
    }

    pub fn has_whatsappBizAcctFbid(&self) -> bool {
        self.whatsappBizAcctFbid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whatsappBizAcctFbid(&mut self, v: u64) {
        self.whatsappBizAcctFbid = ::std::option::Option::Some(v);
    }

    // optional string whatsappAcctNumber = 2;

    pub fn whatsappAcctNumber(&self) -> &str {
        match self.whatsappAcctNumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whatsappAcctNumber(&mut self) {
        self.whatsappAcctNumber = ::std::option::Option::None;
    }

    pub fn has_whatsappAcctNumber(&self) -> bool {
        self.whatsappAcctNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whatsappAcctNumber(&mut self, v: ::std::string::String) {
        self.whatsappAcctNumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whatsappAcctNumber(&mut self) -> &mut ::std::string::String {
        if self.whatsappAcctNumber.is_none() {
            self.whatsappAcctNumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whatsappAcctNumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_whatsappAcctNumber(&mut self) -> ::std::string::String {
        self.whatsappAcctNumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 issueTime = 3;

    pub fn issueTime(&self) -> u64 {
        self.issueTime.unwrap_or(0)
    }

    pub fn clear_issueTime(&mut self) {
        self.issueTime = ::std::option::Option::None;
    }

    pub fn has_issueTime(&self) -> bool {
        self.issueTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issueTime(&mut self, v: u64) {
        self.issueTime = ::std::option::Option::Some(v);
    }

    // optional .BizAccountLinkInfo.BizAccountLinkInfoHostStorageType hostStorage = 4;

    pub fn hostStorage(&self) -> biz_account_link_info::BizAccountLinkInfoHostStorageType {
        match self.hostStorage {
            Some(e) => e.enum_value_or(biz_account_link_info::BizAccountLinkInfoHostStorageType::ON_PREMISE),
            None => biz_account_link_info::BizAccountLinkInfoHostStorageType::ON_PREMISE,
        }
    }

    pub fn clear_hostStorage(&mut self) {
        self.hostStorage = ::std::option::Option::None;
    }

    pub fn has_hostStorage(&self) -> bool {
        self.hostStorage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostStorage(&mut self, v: biz_account_link_info::BizAccountLinkInfoHostStorageType) {
        self.hostStorage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .BizAccountLinkInfo.BizAccountLinkInfoAccountType accountType = 5;

    pub fn accountType(&self) -> biz_account_link_info::BizAccountLinkInfoAccountType {
        match self.accountType {
            Some(e) => e.enum_value_or(biz_account_link_info::BizAccountLinkInfoAccountType::ENTERPRISE),
            None => biz_account_link_info::BizAccountLinkInfoAccountType::ENTERPRISE,
        }
    }

    pub fn clear_accountType(&mut self) {
        self.accountType = ::std::option::Option::None;
    }

    pub fn has_accountType(&self) -> bool {
        self.accountType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountType(&mut self, v: biz_account_link_info::BizAccountLinkInfoAccountType) {
        self.accountType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whatsappBizAcctFbid",
            |m: &BizAccountLinkInfo| { &m.whatsappBizAcctFbid },
            |m: &mut BizAccountLinkInfo| { &mut m.whatsappBizAcctFbid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whatsappAcctNumber",
            |m: &BizAccountLinkInfo| { &m.whatsappAcctNumber },
            |m: &mut BizAccountLinkInfo| { &mut m.whatsappAcctNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issueTime",
            |m: &BizAccountLinkInfo| { &m.issueTime },
            |m: &mut BizAccountLinkInfo| { &mut m.issueTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostStorage",
            |m: &BizAccountLinkInfo| { &m.hostStorage },
            |m: &mut BizAccountLinkInfo| { &mut m.hostStorage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountType",
            |m: &BizAccountLinkInfo| { &m.accountType },
            |m: &mut BizAccountLinkInfo| { &mut m.accountType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BizAccountLinkInfo>(
            "BizAccountLinkInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BizAccountLinkInfo {
    const NAME: &'static str = "BizAccountLinkInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.whatsappBizAcctFbid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.whatsappAcctNumber = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.issueTime = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.hostStorage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.accountType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.whatsappBizAcctFbid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.whatsappAcctNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.issueTime {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.hostStorage {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.accountType {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.whatsappBizAcctFbid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.whatsappAcctNumber.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.issueTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.hostStorage {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.accountType {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BizAccountLinkInfo {
        BizAccountLinkInfo::new()
    }

    fn clear(&mut self) {
        self.whatsappBizAcctFbid = ::std::option::Option::None;
        self.whatsappAcctNumber = ::std::option::Option::None;
        self.issueTime = ::std::option::Option::None;
        self.hostStorage = ::std::option::Option::None;
        self.accountType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BizAccountLinkInfo {
        static instance: BizAccountLinkInfo = BizAccountLinkInfo {
            whatsappBizAcctFbid: ::std::option::Option::None,
            whatsappAcctNumber: ::std::option::Option::None,
            issueTime: ::std::option::Option::None,
            hostStorage: ::std::option::Option::None,
            accountType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BizAccountLinkInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BizAccountLinkInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BizAccountLinkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BizAccountLinkInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BizAccountLinkInfo`
pub mod biz_account_link_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:BizAccountLinkInfo.BizAccountLinkInfoHostStorageType)
    pub enum BizAccountLinkInfoHostStorageType {
        // @@protoc_insertion_point(enum_value:BizAccountLinkInfo.BizAccountLinkInfoHostStorageType.ON_PREMISE)
        ON_PREMISE = 0,
        // @@protoc_insertion_point(enum_value:BizAccountLinkInfo.BizAccountLinkInfoHostStorageType.FACEBOOK)
        FACEBOOK = 1,
    }

    impl ::protobuf::Enum for BizAccountLinkInfoHostStorageType {
        const NAME: &'static str = "BizAccountLinkInfoHostStorageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BizAccountLinkInfoHostStorageType> {
            match value {
                0 => ::std::option::Option::Some(BizAccountLinkInfoHostStorageType::ON_PREMISE),
                1 => ::std::option::Option::Some(BizAccountLinkInfoHostStorageType::FACEBOOK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BizAccountLinkInfoHostStorageType] = &[
            BizAccountLinkInfoHostStorageType::ON_PREMISE,
            BizAccountLinkInfoHostStorageType::FACEBOOK,
        ];
    }

    impl ::protobuf::EnumFull for BizAccountLinkInfoHostStorageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizAccountLinkInfo.BizAccountLinkInfoHostStorageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BizAccountLinkInfoHostStorageType {
        fn default() -> Self {
            BizAccountLinkInfoHostStorageType::ON_PREMISE
        }
    }

    impl BizAccountLinkInfoHostStorageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BizAccountLinkInfoHostStorageType>("BizAccountLinkInfo.BizAccountLinkInfoHostStorageType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:BizAccountLinkInfo.BizAccountLinkInfoAccountType)
    pub enum BizAccountLinkInfoAccountType {
        // @@protoc_insertion_point(enum_value:BizAccountLinkInfo.BizAccountLinkInfoAccountType.ENTERPRISE)
        ENTERPRISE = 0,
    }

    impl ::protobuf::Enum for BizAccountLinkInfoAccountType {
        const NAME: &'static str = "BizAccountLinkInfoAccountType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BizAccountLinkInfoAccountType> {
            match value {
                0 => ::std::option::Option::Some(BizAccountLinkInfoAccountType::ENTERPRISE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BizAccountLinkInfoAccountType] = &[
            BizAccountLinkInfoAccountType::ENTERPRISE,
        ];
    }

    impl ::protobuf::EnumFull for BizAccountLinkInfoAccountType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizAccountLinkInfo.BizAccountLinkInfoAccountType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BizAccountLinkInfoAccountType {
        fn default() -> Self {
            BizAccountLinkInfoAccountType::ENTERPRISE
        }
    }

    impl BizAccountLinkInfoAccountType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BizAccountLinkInfoAccountType>("BizAccountLinkInfo.BizAccountLinkInfoAccountType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BizAccountPayload)
pub struct BizAccountPayload {
    // message fields
    // @@protoc_insertion_point(field:BizAccountPayload.vnameCert)
    pub vnameCert: ::protobuf::MessageField<VerifiedNameCertificate>,
    // @@protoc_insertion_point(field:BizAccountPayload.bizAcctLinkInfo)
    pub bizAcctLinkInfo: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:BizAccountPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BizAccountPayload {
    fn default() -> &'a BizAccountPayload {
        <BizAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl BizAccountPayload {
    pub fn new() -> BizAccountPayload {
        ::std::default::Default::default()
    }

    // optional bytes bizAcctLinkInfo = 2;

    pub fn bizAcctLinkInfo(&self) -> &[u8] {
        match self.bizAcctLinkInfo.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bizAcctLinkInfo(&mut self) {
        self.bizAcctLinkInfo = ::std::option::Option::None;
    }

    pub fn has_bizAcctLinkInfo(&self) -> bool {
        self.bizAcctLinkInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bizAcctLinkInfo(&mut self, v: ::std::vec::Vec<u8>) {
        self.bizAcctLinkInfo = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bizAcctLinkInfo(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bizAcctLinkInfo.is_none() {
            self.bizAcctLinkInfo = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bizAcctLinkInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_bizAcctLinkInfo(&mut self) -> ::std::vec::Vec<u8> {
        self.bizAcctLinkInfo.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VerifiedNameCertificate>(
            "vnameCert",
            |m: &BizAccountPayload| { &m.vnameCert },
            |m: &mut BizAccountPayload| { &mut m.vnameCert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bizAcctLinkInfo",
            |m: &BizAccountPayload| { &m.bizAcctLinkInfo },
            |m: &mut BizAccountPayload| { &mut m.bizAcctLinkInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BizAccountPayload>(
            "BizAccountPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BizAccountPayload {
    const NAME: &'static str = "BizAccountPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vnameCert)?;
                },
                18 => {
                    self.bizAcctLinkInfo = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vnameCert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bizAcctLinkInfo.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vnameCert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bizAcctLinkInfo.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BizAccountPayload {
        BizAccountPayload::new()
    }

    fn clear(&mut self) {
        self.vnameCert.clear();
        self.bizAcctLinkInfo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BizAccountPayload {
        static instance: BizAccountPayload = BizAccountPayload {
            vnameCert: ::protobuf::MessageField::none(),
            bizAcctLinkInfo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BizAccountPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BizAccountPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BizAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BizAccountPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:VerifiedNameDetails)
pub struct VerifiedNameDetails {
    // message fields
    // @@protoc_insertion_point(field:VerifiedNameDetails.serial)
    pub serial: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:VerifiedNameDetails.issuer)
    pub issuer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VerifiedNameDetails.verifiedName)
    pub verifiedName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VerifiedNameDetails.localizedNames)
    pub localizedNames: ::std::vec::Vec<LocalizedName>,
    // @@protoc_insertion_point(field:VerifiedNameDetails.issueTime)
    pub issueTime: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:VerifiedNameDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VerifiedNameDetails {
    fn default() -> &'a VerifiedNameDetails {
        <VerifiedNameDetails as ::protobuf::Message>::default_instance()
    }
}

impl VerifiedNameDetails {
    pub fn new() -> VerifiedNameDetails {
        ::std::default::Default::default()
    }

    // optional uint64 serial = 1;

    pub fn serial(&self) -> u64 {
        self.serial.unwrap_or(0)
    }

    pub fn clear_serial(&mut self) {
        self.serial = ::std::option::Option::None;
    }

    pub fn has_serial(&self) -> bool {
        self.serial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial(&mut self, v: u64) {
        self.serial = ::std::option::Option::Some(v);
    }

    // optional string issuer = 2;

    pub fn issuer(&self) -> &str {
        match self.issuer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_issuer(&mut self) {
        self.issuer = ::std::option::Option::None;
    }

    pub fn has_issuer(&self) -> bool {
        self.issuer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuer(&mut self, v: ::std::string::String) {
        self.issuer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
        if self.issuer.is_none() {
            self.issuer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.issuer.as_mut().unwrap()
    }

    // Take field
    pub fn take_issuer(&mut self) -> ::std::string::String {
        self.issuer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string verifiedName = 4;

    pub fn verifiedName(&self) -> &str {
        match self.verifiedName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_verifiedName(&mut self) {
        self.verifiedName = ::std::option::Option::None;
    }

    pub fn has_verifiedName(&self) -> bool {
        self.verifiedName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verifiedName(&mut self, v: ::std::string::String) {
        self.verifiedName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verifiedName(&mut self) -> &mut ::std::string::String {
        if self.verifiedName.is_none() {
            self.verifiedName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.verifiedName.as_mut().unwrap()
    }

    // Take field
    pub fn take_verifiedName(&mut self) -> ::std::string::String {
        self.verifiedName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 issueTime = 10;

    pub fn issueTime(&self) -> u64 {
        self.issueTime.unwrap_or(0)
    }

    pub fn clear_issueTime(&mut self) {
        self.issueTime = ::std::option::Option::None;
    }

    pub fn has_issueTime(&self) -> bool {
        self.issueTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issueTime(&mut self, v: u64) {
        self.issueTime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serial",
            |m: &VerifiedNameDetails| { &m.serial },
            |m: &mut VerifiedNameDetails| { &mut m.serial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuer",
            |m: &VerifiedNameDetails| { &m.issuer },
            |m: &mut VerifiedNameDetails| { &mut m.issuer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verifiedName",
            |m: &VerifiedNameDetails| { &m.verifiedName },
            |m: &mut VerifiedNameDetails| { &mut m.verifiedName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "localizedNames",
            |m: &VerifiedNameDetails| { &m.localizedNames },
            |m: &mut VerifiedNameDetails| { &mut m.localizedNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issueTime",
            |m: &VerifiedNameDetails| { &m.issueTime },
            |m: &mut VerifiedNameDetails| { &mut m.issueTime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VerifiedNameDetails>(
            "VerifiedNameDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VerifiedNameDetails {
    const NAME: &'static str = "VerifiedNameDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serial = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.issuer = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.verifiedName = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.localizedNames.push(is.read_message()?);
                },
                80 => {
                    self.issueTime = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serial {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.issuer.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.verifiedName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.localizedNames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.issueTime {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serial {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.issuer.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.verifiedName.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.localizedNames {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.issueTime {
            os.write_uint64(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VerifiedNameDetails {
        VerifiedNameDetails::new()
    }

    fn clear(&mut self) {
        self.serial = ::std::option::Option::None;
        self.issuer = ::std::option::Option::None;
        self.verifiedName = ::std::option::Option::None;
        self.localizedNames.clear();
        self.issueTime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VerifiedNameDetails {
        static instance: VerifiedNameDetails = VerifiedNameDetails {
            serial: ::std::option::Option::None,
            issuer: ::std::option::Option::None,
            verifiedName: ::std::option::Option::None,
            localizedNames: ::std::vec::Vec::new(),
            issueTime: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VerifiedNameDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VerifiedNameDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VerifiedNameDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifiedNameDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:VerifiedNameCertificate)
pub struct VerifiedNameCertificate {
    // message fields
    // @@protoc_insertion_point(field:VerifiedNameCertificate.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VerifiedNameCertificate.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VerifiedNameCertificate.serverSignature)
    pub serverSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:VerifiedNameCertificate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VerifiedNameCertificate {
    fn default() -> &'a VerifiedNameCertificate {
        <VerifiedNameCertificate as ::protobuf::Message>::default_instance()
    }
}

impl VerifiedNameCertificate {
    pub fn new() -> VerifiedNameCertificate {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes serverSignature = 3;

    pub fn serverSignature(&self) -> &[u8] {
        match self.serverSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serverSignature(&mut self) {
        self.serverSignature = ::std::option::Option::None;
    }

    pub fn has_serverSignature(&self) -> bool {
        self.serverSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.serverSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serverSignature.is_none() {
            self.serverSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serverSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.serverSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &VerifiedNameCertificate| { &m.details },
            |m: &mut VerifiedNameCertificate| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &VerifiedNameCertificate| { &m.signature },
            |m: &mut VerifiedNameCertificate| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverSignature",
            |m: &VerifiedNameCertificate| { &m.serverSignature },
            |m: &mut VerifiedNameCertificate| { &mut m.serverSignature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VerifiedNameCertificate>(
            "VerifiedNameCertificate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VerifiedNameCertificate {
    const NAME: &'static str = "VerifiedNameCertificate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.serverSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.serverSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.serverSignature.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VerifiedNameCertificate {
        VerifiedNameCertificate::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.serverSignature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VerifiedNameCertificate {
        static instance: VerifiedNameCertificate = VerifiedNameCertificate {
            details: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            serverSignature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VerifiedNameCertificate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VerifiedNameCertificate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VerifiedNameCertificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifiedNameCertificate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LocalizedName)
pub struct LocalizedName {
    // message fields
    // @@protoc_insertion_point(field:LocalizedName.lg)
    pub lg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LocalizedName.lc)
    pub lc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LocalizedName.verifiedName)
    pub verifiedName: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:LocalizedName.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocalizedName {
    fn default() -> &'a LocalizedName {
        <LocalizedName as ::protobuf::Message>::default_instance()
    }
}

impl LocalizedName {
    pub fn new() -> LocalizedName {
        ::std::default::Default::default()
    }

    // optional string lg = 1;

    pub fn lg(&self) -> &str {
        match self.lg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lg(&mut self) {
        self.lg = ::std::option::Option::None;
    }

    pub fn has_lg(&self) -> bool {
        self.lg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lg(&mut self, v: ::std::string::String) {
        self.lg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lg(&mut self) -> &mut ::std::string::String {
        if self.lg.is_none() {
            self.lg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lg.as_mut().unwrap()
    }

    // Take field
    pub fn take_lg(&mut self) -> ::std::string::String {
        self.lg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string lc = 2;

    pub fn lc(&self) -> &str {
        match self.lc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lc(&mut self) {
        self.lc = ::std::option::Option::None;
    }

    pub fn has_lc(&self) -> bool {
        self.lc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lc(&mut self, v: ::std::string::String) {
        self.lc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lc(&mut self) -> &mut ::std::string::String {
        if self.lc.is_none() {
            self.lc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lc.as_mut().unwrap()
    }

    // Take field
    pub fn take_lc(&mut self) -> ::std::string::String {
        self.lc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string verifiedName = 3;

    pub fn verifiedName(&self) -> &str {
        match self.verifiedName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_verifiedName(&mut self) {
        self.verifiedName = ::std::option::Option::None;
    }

    pub fn has_verifiedName(&self) -> bool {
        self.verifiedName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verifiedName(&mut self, v: ::std::string::String) {
        self.verifiedName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verifiedName(&mut self) -> &mut ::std::string::String {
        if self.verifiedName.is_none() {
            self.verifiedName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.verifiedName.as_mut().unwrap()
    }

    // Take field
    pub fn take_verifiedName(&mut self) -> ::std::string::String {
        self.verifiedName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lg",
            |m: &LocalizedName| { &m.lg },
            |m: &mut LocalizedName| { &mut m.lg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lc",
            |m: &LocalizedName| { &m.lc },
            |m: &mut LocalizedName| { &mut m.lc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verifiedName",
            |m: &LocalizedName| { &m.verifiedName },
            |m: &mut LocalizedName| { &mut m.verifiedName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalizedName>(
            "LocalizedName",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocalizedName {
    const NAME: &'static str = "LocalizedName";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lg = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.lc = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.verifiedName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.lc.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.verifiedName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lg.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.lc.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.verifiedName.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocalizedName {
        LocalizedName::new()
    }

    fn clear(&mut self) {
        self.lg = ::std::option::Option::None;
        self.lc = ::std::option::Option::None;
        self.verifiedName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocalizedName {
        static instance: LocalizedName = LocalizedName {
            lg: ::std::option::Option::None,
            lc: ::std::option::Option::None,
            verifiedName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocalizedName {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocalizedName").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocalizedName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalizedName {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncActionData)
pub struct SyncActionData {
    // message fields
    // @@protoc_insertion_point(field:SyncActionData.index)
    pub index: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:SyncActionData.value)
    pub value: ::protobuf::MessageField<SyncActionValue>,
    // @@protoc_insertion_point(field:SyncActionData.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:SyncActionData.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncActionData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionData {
    fn default() -> &'a SyncActionData {
        <SyncActionData as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionData {
    pub fn new() -> SyncActionData {
        ::std::default::Default::default()
    }

    // optional bytes index = 1;

    pub fn index(&self) -> &[u8] {
        match self.index.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<u8>) {
        self.index = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.index.is_none() {
            self.index = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<u8> {
        self.index.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes padding = 3;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 version = 4;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &SyncActionData| { &m.index },
            |m: &mut SyncActionData| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionValue>(
            "value",
            |m: &SyncActionData| { &m.value },
            |m: &mut SyncActionData| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &SyncActionData| { &m.padding },
            |m: &mut SyncActionData| { &mut m.padding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &SyncActionData| { &m.version },
            |m: &mut SyncActionData| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionData>(
            "SyncActionData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionData {
    const NAME: &'static str = "SyncActionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.index = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                26 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionData {
        SyncActionData::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.value.clear();
        self.padding = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionData {
        static instance: SyncActionData = SyncActionData {
            index: ::std::option::Option::None,
            value: ::protobuf::MessageField::none(),
            padding: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:StarAction)
pub struct StarAction {
    // message fields
    // @@protoc_insertion_point(field:StarAction.starred)
    pub starred: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:StarAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StarAction {
    fn default() -> &'a StarAction {
        <StarAction as ::protobuf::Message>::default_instance()
    }
}

impl StarAction {
    pub fn new() -> StarAction {
        ::std::default::Default::default()
    }

    // optional bool starred = 1;

    pub fn starred(&self) -> bool {
        self.starred.unwrap_or(false)
    }

    pub fn clear_starred(&mut self) {
        self.starred = ::std::option::Option::None;
    }

    pub fn has_starred(&self) -> bool {
        self.starred.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starred(&mut self, v: bool) {
        self.starred = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "starred",
            |m: &StarAction| { &m.starred },
            |m: &mut StarAction| { &mut m.starred },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StarAction>(
            "StarAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StarAction {
    const NAME: &'static str = "StarAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.starred = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.starred {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.starred {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StarAction {
        StarAction::new()
    }

    fn clear(&mut self) {
        self.starred = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StarAction {
        static instance: StarAction = StarAction {
            starred: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StarAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StarAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StarAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StarAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ContactAction)
pub struct ContactAction {
    // message fields
    // @@protoc_insertion_point(field:ContactAction.fullName)
    pub fullName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContactAction.firstName)
    pub firstName: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ContactAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactAction {
    fn default() -> &'a ContactAction {
        <ContactAction as ::protobuf::Message>::default_instance()
    }
}

impl ContactAction {
    pub fn new() -> ContactAction {
        ::std::default::Default::default()
    }

    // optional string fullName = 1;

    pub fn fullName(&self) -> &str {
        match self.fullName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fullName(&mut self) {
        self.fullName = ::std::option::Option::None;
    }

    pub fn has_fullName(&self) -> bool {
        self.fullName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullName(&mut self, v: ::std::string::String) {
        self.fullName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullName(&mut self) -> &mut ::std::string::String {
        if self.fullName.is_none() {
            self.fullName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fullName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullName(&mut self) -> ::std::string::String {
        self.fullName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string firstName = 2;

    pub fn firstName(&self) -> &str {
        match self.firstName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_firstName(&mut self) {
        self.firstName = ::std::option::Option::None;
    }

    pub fn has_firstName(&self) -> bool {
        self.firstName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstName(&mut self, v: ::std::string::String) {
        self.firstName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstName(&mut self) -> &mut ::std::string::String {
        if self.firstName.is_none() {
            self.firstName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.firstName.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstName(&mut self) -> ::std::string::String {
        self.firstName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fullName",
            |m: &ContactAction| { &m.fullName },
            |m: &mut ContactAction| { &mut m.fullName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstName",
            |m: &ContactAction| { &m.firstName },
            |m: &mut ContactAction| { &mut m.firstName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactAction>(
            "ContactAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactAction {
    const NAME: &'static str = "ContactAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fullName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.firstName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fullName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.firstName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fullName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.firstName.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactAction {
        ContactAction::new()
    }

    fn clear(&mut self) {
        self.fullName = ::std::option::Option::None;
        self.firstName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactAction {
        static instance: ContactAction = ContactAction {
            fullName: ::std::option::Option::None,
            firstName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MuteAction)
pub struct MuteAction {
    // message fields
    // @@protoc_insertion_point(field:MuteAction.muted)
    pub muted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MuteAction.muteEndTimestamp)
    pub muteEndTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:MuteAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MuteAction {
    fn default() -> &'a MuteAction {
        <MuteAction as ::protobuf::Message>::default_instance()
    }
}

impl MuteAction {
    pub fn new() -> MuteAction {
        ::std::default::Default::default()
    }

    // optional bool muted = 1;

    pub fn muted(&self) -> bool {
        self.muted.unwrap_or(false)
    }

    pub fn clear_muted(&mut self) {
        self.muted = ::std::option::Option::None;
    }

    pub fn has_muted(&self) -> bool {
        self.muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muted(&mut self, v: bool) {
        self.muted = ::std::option::Option::Some(v);
    }

    // optional int64 muteEndTimestamp = 2;

    pub fn muteEndTimestamp(&self) -> i64 {
        self.muteEndTimestamp.unwrap_or(0)
    }

    pub fn clear_muteEndTimestamp(&mut self) {
        self.muteEndTimestamp = ::std::option::Option::None;
    }

    pub fn has_muteEndTimestamp(&self) -> bool {
        self.muteEndTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muteEndTimestamp(&mut self, v: i64) {
        self.muteEndTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muted",
            |m: &MuteAction| { &m.muted },
            |m: &mut MuteAction| { &mut m.muted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muteEndTimestamp",
            |m: &MuteAction| { &m.muteEndTimestamp },
            |m: &mut MuteAction| { &mut m.muteEndTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MuteAction>(
            "MuteAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MuteAction {
    const NAME: &'static str = "MuteAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.muted = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.muteEndTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.muted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.muteEndTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.muted {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.muteEndTimestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MuteAction {
        MuteAction::new()
    }

    fn clear(&mut self) {
        self.muted = ::std::option::Option::None;
        self.muteEndTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MuteAction {
        static instance: MuteAction = MuteAction {
            muted: ::std::option::Option::None,
            muteEndTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MuteAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MuteAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MuteAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MuteAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PinAction)
pub struct PinAction {
    // message fields
    // @@protoc_insertion_point(field:PinAction.pinned)
    pub pinned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:PinAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PinAction {
    fn default() -> &'a PinAction {
        <PinAction as ::protobuf::Message>::default_instance()
    }
}

impl PinAction {
    pub fn new() -> PinAction {
        ::std::default::Default::default()
    }

    // optional bool pinned = 1;

    pub fn pinned(&self) -> bool {
        self.pinned.unwrap_or(false)
    }

    pub fn clear_pinned(&mut self) {
        self.pinned = ::std::option::Option::None;
    }

    pub fn has_pinned(&self) -> bool {
        self.pinned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinned(&mut self, v: bool) {
        self.pinned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pinned",
            |m: &PinAction| { &m.pinned },
            |m: &mut PinAction| { &mut m.pinned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PinAction>(
            "PinAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PinAction {
    const NAME: &'static str = "PinAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pinned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pinned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pinned {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PinAction {
        PinAction::new()
    }

    fn clear(&mut self) {
        self.pinned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PinAction {
        static instance: PinAction = PinAction {
            pinned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PinAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PinAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PinAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SecurityNotificationSetting)
pub struct SecurityNotificationSetting {
    // message fields
    // @@protoc_insertion_point(field:SecurityNotificationSetting.showNotification)
    pub showNotification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SecurityNotificationSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecurityNotificationSetting {
    fn default() -> &'a SecurityNotificationSetting {
        <SecurityNotificationSetting as ::protobuf::Message>::default_instance()
    }
}

impl SecurityNotificationSetting {
    pub fn new() -> SecurityNotificationSetting {
        ::std::default::Default::default()
    }

    // optional bool showNotification = 1;

    pub fn showNotification(&self) -> bool {
        self.showNotification.unwrap_or(false)
    }

    pub fn clear_showNotification(&mut self) {
        self.showNotification = ::std::option::Option::None;
    }

    pub fn has_showNotification(&self) -> bool {
        self.showNotification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showNotification(&mut self, v: bool) {
        self.showNotification = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "showNotification",
            |m: &SecurityNotificationSetting| { &m.showNotification },
            |m: &mut SecurityNotificationSetting| { &mut m.showNotification },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityNotificationSetting>(
            "SecurityNotificationSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecurityNotificationSetting {
    const NAME: &'static str = "SecurityNotificationSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.showNotification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.showNotification {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.showNotification {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecurityNotificationSetting {
        SecurityNotificationSetting::new()
    }

    fn clear(&mut self) {
        self.showNotification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecurityNotificationSetting {
        static instance: SecurityNotificationSetting = SecurityNotificationSetting {
            showNotification: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecurityNotificationSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecurityNotificationSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecurityNotificationSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityNotificationSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PushNameSetting)
pub struct PushNameSetting {
    // message fields
    // @@protoc_insertion_point(field:PushNameSetting.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:PushNameSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PushNameSetting {
    fn default() -> &'a PushNameSetting {
        <PushNameSetting as ::protobuf::Message>::default_instance()
    }
}

impl PushNameSetting {
    pub fn new() -> PushNameSetting {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PushNameSetting| { &m.name },
            |m: &mut PushNameSetting| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PushNameSetting>(
            "PushNameSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PushNameSetting {
    const NAME: &'static str = "PushNameSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PushNameSetting {
        PushNameSetting::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PushNameSetting {
        static instance: PushNameSetting = PushNameSetting {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PushNameSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PushNameSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PushNameSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushNameSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LocaleSetting)
pub struct LocaleSetting {
    // message fields
    // @@protoc_insertion_point(field:LocaleSetting.locale)
    pub locale: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:LocaleSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocaleSetting {
    fn default() -> &'a LocaleSetting {
        <LocaleSetting as ::protobuf::Message>::default_instance()
    }
}

impl LocaleSetting {
    pub fn new() -> LocaleSetting {
        ::std::default::Default::default()
    }

    // optional string locale = 1;

    pub fn locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_locale(&mut self) {
        self.locale = ::std::option::Option::None;
    }

    pub fn has_locale(&self) -> bool {
        self.locale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locale(&mut self, v: ::std::string::String) {
        self.locale = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locale(&mut self) -> &mut ::std::string::String {
        if self.locale.is_none() {
            self.locale = ::std::option::Option::Some(::std::string::String::new());
        }
        self.locale.as_mut().unwrap()
    }

    // Take field
    pub fn take_locale(&mut self) -> ::std::string::String {
        self.locale.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "locale",
            |m: &LocaleSetting| { &m.locale },
            |m: &mut LocaleSetting| { &mut m.locale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocaleSetting>(
            "LocaleSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocaleSetting {
    const NAME: &'static str = "LocaleSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.locale = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.locale.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocaleSetting {
        LocaleSetting::new()
    }

    fn clear(&mut self) {
        self.locale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocaleSetting {
        static instance: LocaleSetting = LocaleSetting {
            locale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocaleSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocaleSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocaleSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocaleSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:QuickReplyAction)
pub struct QuickReplyAction {
    // message fields
    // @@protoc_insertion_point(field:QuickReplyAction.shortcut)
    pub shortcut: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:QuickReplyAction.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:QuickReplyAction.keywords)
    pub keywords: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:QuickReplyAction.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:QuickReplyAction.deleted)
    pub deleted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:QuickReplyAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuickReplyAction {
    fn default() -> &'a QuickReplyAction {
        <QuickReplyAction as ::protobuf::Message>::default_instance()
    }
}

impl QuickReplyAction {
    pub fn new() -> QuickReplyAction {
        ::std::default::Default::default()
    }

    // optional string shortcut = 1;

    pub fn shortcut(&self) -> &str {
        match self.shortcut.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shortcut(&mut self) {
        self.shortcut = ::std::option::Option::None;
    }

    pub fn has_shortcut(&self) -> bool {
        self.shortcut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcut(&mut self, v: ::std::string::String) {
        self.shortcut = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcut(&mut self) -> &mut ::std::string::String {
        if self.shortcut.is_none() {
            self.shortcut = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shortcut.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcut(&mut self) -> ::std::string::String {
        self.shortcut.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 count = 4;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 5;

    pub fn deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shortcut",
            |m: &QuickReplyAction| { &m.shortcut },
            |m: &mut QuickReplyAction| { &mut m.shortcut },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &QuickReplyAction| { &m.message },
            |m: &mut QuickReplyAction| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keywords",
            |m: &QuickReplyAction| { &m.keywords },
            |m: &mut QuickReplyAction| { &mut m.keywords },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &QuickReplyAction| { &m.count },
            |m: &mut QuickReplyAction| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted",
            |m: &QuickReplyAction| { &m.deleted },
            |m: &mut QuickReplyAction| { &mut m.deleted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuickReplyAction>(
            "QuickReplyAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuickReplyAction {
    const NAME: &'static str = "QuickReplyAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shortcut = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.keywords.push(is.read_string()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shortcut.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.keywords {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.deleted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shortcut.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.keywords {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuickReplyAction {
        QuickReplyAction::new()
    }

    fn clear(&mut self) {
        self.shortcut = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.keywords.clear();
        self.count = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuickReplyAction {
        static instance: QuickReplyAction = QuickReplyAction {
            shortcut: ::std::option::Option::None,
            message: ::std::option::Option::None,
            keywords: ::std::vec::Vec::new(),
            count: ::std::option::Option::None,
            deleted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuickReplyAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuickReplyAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuickReplyAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuickReplyAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LabelAssociationAction)
pub struct LabelAssociationAction {
    // message fields
    // @@protoc_insertion_point(field:LabelAssociationAction.labeled)
    pub labeled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:LabelAssociationAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelAssociationAction {
    fn default() -> &'a LabelAssociationAction {
        <LabelAssociationAction as ::protobuf::Message>::default_instance()
    }
}

impl LabelAssociationAction {
    pub fn new() -> LabelAssociationAction {
        ::std::default::Default::default()
    }

    // optional bool labeled = 1;

    pub fn labeled(&self) -> bool {
        self.labeled.unwrap_or(false)
    }

    pub fn clear_labeled(&mut self) {
        self.labeled = ::std::option::Option::None;
    }

    pub fn has_labeled(&self) -> bool {
        self.labeled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labeled(&mut self, v: bool) {
        self.labeled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labeled",
            |m: &LabelAssociationAction| { &m.labeled },
            |m: &mut LabelAssociationAction| { &mut m.labeled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelAssociationAction>(
            "LabelAssociationAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelAssociationAction {
    const NAME: &'static str = "LabelAssociationAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.labeled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.labeled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.labeled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelAssociationAction {
        LabelAssociationAction::new()
    }

    fn clear(&mut self) {
        self.labeled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelAssociationAction {
        static instance: LabelAssociationAction = LabelAssociationAction {
            labeled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelAssociationAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelAssociationAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelAssociationAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelAssociationAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LabelEditAction)
pub struct LabelEditAction {
    // message fields
    // @@protoc_insertion_point(field:LabelEditAction.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LabelEditAction.color)
    pub color: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:LabelEditAction.predefinedId)
    pub predefinedId: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:LabelEditAction.deleted)
    pub deleted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:LabelEditAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelEditAction {
    fn default() -> &'a LabelEditAction {
        <LabelEditAction as ::protobuf::Message>::default_instance()
    }
}

impl LabelEditAction {
    pub fn new() -> LabelEditAction {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 color = 2;

    pub fn color(&self) -> i32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: i32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional int32 predefinedId = 3;

    pub fn predefinedId(&self) -> i32 {
        self.predefinedId.unwrap_or(0)
    }

    pub fn clear_predefinedId(&mut self) {
        self.predefinedId = ::std::option::Option::None;
    }

    pub fn has_predefinedId(&self) -> bool {
        self.predefinedId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predefinedId(&mut self, v: i32) {
        self.predefinedId = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 4;

    pub fn deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &LabelEditAction| { &m.name },
            |m: &mut LabelEditAction| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &LabelEditAction| { &m.color },
            |m: &mut LabelEditAction| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "predefinedId",
            |m: &LabelEditAction| { &m.predefinedId },
            |m: &mut LabelEditAction| { &mut m.predefinedId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted",
            |m: &LabelEditAction| { &m.deleted },
            |m: &mut LabelEditAction| { &mut m.deleted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelEditAction>(
            "LabelEditAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelEditAction {
    const NAME: &'static str = "LabelEditAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.color = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.predefinedId = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.predefinedId {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.deleted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.predefinedId {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelEditAction {
        LabelEditAction::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.predefinedId = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelEditAction {
        static instance: LabelEditAction = LabelEditAction {
            name: ::std::option::Option::None,
            color: ::std::option::Option::None,
            predefinedId: ::std::option::Option::None,
            deleted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelEditAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelEditAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelEditAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelEditAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RecentStickerWeightsAction)
pub struct RecentStickerWeightsAction {
    // message fields
    // @@protoc_insertion_point(field:RecentStickerWeightsAction.weights)
    pub weights: ::std::vec::Vec<RecentStickerWeight>,
    // special fields
    // @@protoc_insertion_point(special_field:RecentStickerWeightsAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecentStickerWeightsAction {
    fn default() -> &'a RecentStickerWeightsAction {
        <RecentStickerWeightsAction as ::protobuf::Message>::default_instance()
    }
}

impl RecentStickerWeightsAction {
    pub fn new() -> RecentStickerWeightsAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weights",
            |m: &RecentStickerWeightsAction| { &m.weights },
            |m: &mut RecentStickerWeightsAction| { &mut m.weights },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecentStickerWeightsAction>(
            "RecentStickerWeightsAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecentStickerWeightsAction {
    const NAME: &'static str = "RecentStickerWeightsAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.weights.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.weights {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.weights {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecentStickerWeightsAction {
        RecentStickerWeightsAction::new()
    }

    fn clear(&mut self) {
        self.weights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecentStickerWeightsAction {
        static instance: RecentStickerWeightsAction = RecentStickerWeightsAction {
            weights: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecentStickerWeightsAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecentStickerWeightsAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecentStickerWeightsAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecentStickerWeightsAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RecentStickerMetadata)
pub struct RecentStickerMetadata {
    // message fields
    // @@protoc_insertion_point(field:RecentStickerMetadata.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentStickerMetadata.encFilehash)
    pub encFilehash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentStickerMetadata.mediaKey)
    pub mediaKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentStickerMetadata.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentStickerMetadata.chatJid)
    pub chatJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentStickerMetadata.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentStickerMetadata.isSentByMe)
    pub isSentByMe: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:RecentStickerMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecentStickerMetadata {
    fn default() -> &'a RecentStickerMetadata {
        <RecentStickerMetadata as ::protobuf::Message>::default_instance()
    }
}

impl RecentStickerMetadata {
    pub fn new() -> RecentStickerMetadata {
        ::std::default::Default::default()
    }

    // optional string directPath = 1;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string encFilehash = 2;

    pub fn encFilehash(&self) -> &str {
        match self.encFilehash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encFilehash(&mut self) {
        self.encFilehash = ::std::option::Option::None;
    }

    pub fn has_encFilehash(&self) -> bool {
        self.encFilehash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encFilehash(&mut self, v: ::std::string::String) {
        self.encFilehash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encFilehash(&mut self) -> &mut ::std::string::String {
        if self.encFilehash.is_none() {
            self.encFilehash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encFilehash.as_mut().unwrap()
    }

    // Take field
    pub fn take_encFilehash(&mut self) -> ::std::string::String {
        self.encFilehash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mediaKey = 3;

    pub fn mediaKey(&self) -> &str {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::string::String) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::string::String {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::string::String {
        self.mediaKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stanzaId = 4;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chatJid = 5;

    pub fn chatJid(&self) -> &str {
        match self.chatJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chatJid(&mut self) {
        self.chatJid = ::std::option::Option::None;
    }

    pub fn has_chatJid(&self) -> bool {
        self.chatJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatJid(&mut self, v: ::std::string::String) {
        self.chatJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chatJid(&mut self) -> &mut ::std::string::String {
        if self.chatJid.is_none() {
            self.chatJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chatJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_chatJid(&mut self) -> ::std::string::String {
        self.chatJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string participant = 6;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool isSentByMe = 7;

    pub fn isSentByMe(&self) -> bool {
        self.isSentByMe.unwrap_or(false)
    }

    pub fn clear_isSentByMe(&mut self) {
        self.isSentByMe = ::std::option::Option::None;
    }

    pub fn has_isSentByMe(&self) -> bool {
        self.isSentByMe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isSentByMe(&mut self, v: bool) {
        self.isSentByMe = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &RecentStickerMetadata| { &m.directPath },
            |m: &mut RecentStickerMetadata| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encFilehash",
            |m: &RecentStickerMetadata| { &m.encFilehash },
            |m: &mut RecentStickerMetadata| { &mut m.encFilehash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &RecentStickerMetadata| { &m.mediaKey },
            |m: &mut RecentStickerMetadata| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &RecentStickerMetadata| { &m.stanzaId },
            |m: &mut RecentStickerMetadata| { &mut m.stanzaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chatJid",
            |m: &RecentStickerMetadata| { &m.chatJid },
            |m: &mut RecentStickerMetadata| { &mut m.chatJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &RecentStickerMetadata| { &m.participant },
            |m: &mut RecentStickerMetadata| { &mut m.participant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isSentByMe",
            |m: &RecentStickerMetadata| { &m.isSentByMe },
            |m: &mut RecentStickerMetadata| { &mut m.isSentByMe },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecentStickerMetadata>(
            "RecentStickerMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecentStickerMetadata {
    const NAME: &'static str = "RecentStickerMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.encFilehash = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.chatJid = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.isSentByMe = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.encFilehash.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.chatJid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.isSentByMe {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.encFilehash.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.chatJid.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.isSentByMe {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecentStickerMetadata {
        RecentStickerMetadata::new()
    }

    fn clear(&mut self) {
        self.directPath = ::std::option::Option::None;
        self.encFilehash = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.stanzaId = ::std::option::Option::None;
        self.chatJid = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.isSentByMe = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecentStickerMetadata {
        static instance: RecentStickerMetadata = RecentStickerMetadata {
            directPath: ::std::option::Option::None,
            encFilehash: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            stanzaId: ::std::option::Option::None,
            chatJid: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            isSentByMe: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecentStickerMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecentStickerMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecentStickerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecentStickerMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RecentEmojiWeightsAction)
pub struct RecentEmojiWeightsAction {
    // message fields
    // @@protoc_insertion_point(field:RecentEmojiWeightsAction.weights)
    pub weights: ::std::vec::Vec<RecentEmojiWeight>,
    // special fields
    // @@protoc_insertion_point(special_field:RecentEmojiWeightsAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecentEmojiWeightsAction {
    fn default() -> &'a RecentEmojiWeightsAction {
        <RecentEmojiWeightsAction as ::protobuf::Message>::default_instance()
    }
}

impl RecentEmojiWeightsAction {
    pub fn new() -> RecentEmojiWeightsAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weights",
            |m: &RecentEmojiWeightsAction| { &m.weights },
            |m: &mut RecentEmojiWeightsAction| { &mut m.weights },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecentEmojiWeightsAction>(
            "RecentEmojiWeightsAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecentEmojiWeightsAction {
    const NAME: &'static str = "RecentEmojiWeightsAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.weights.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.weights {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.weights {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecentEmojiWeightsAction {
        RecentEmojiWeightsAction::new()
    }

    fn clear(&mut self) {
        self.weights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecentEmojiWeightsAction {
        static instance: RecentEmojiWeightsAction = RecentEmojiWeightsAction {
            weights: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecentEmojiWeightsAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecentEmojiWeightsAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecentEmojiWeightsAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecentEmojiWeightsAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:FavoriteStickerAction)
pub struct FavoriteStickerAction {
    // message fields
    // @@protoc_insertion_point(field:FavoriteStickerAction.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:FavoriteStickerAction.lastUploadTimestamp)
    pub lastUploadTimestamp: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:FavoriteStickerAction.handle)
    pub handle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:FavoriteStickerAction.encFilehash)
    pub encFilehash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:FavoriteStickerAction.stickerHashWithoutMeta)
    pub stickerHashWithoutMeta: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:FavoriteStickerAction.mediaKey)
    pub mediaKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:FavoriteStickerAction.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:FavoriteStickerAction.isFavorite)
    pub isFavorite: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:FavoriteStickerAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FavoriteStickerAction {
    fn default() -> &'a FavoriteStickerAction {
        <FavoriteStickerAction as ::protobuf::Message>::default_instance()
    }
}

impl FavoriteStickerAction {
    pub fn new() -> FavoriteStickerAction {
        ::std::default::Default::default()
    }

    // optional string directPath = 1;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string lastUploadTimestamp = 2;

    pub fn lastUploadTimestamp(&self) -> &str {
        match self.lastUploadTimestamp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lastUploadTimestamp(&mut self) {
        self.lastUploadTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastUploadTimestamp(&self) -> bool {
        self.lastUploadTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUploadTimestamp(&mut self, v: ::std::string::String) {
        self.lastUploadTimestamp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastUploadTimestamp(&mut self) -> &mut ::std::string::String {
        if self.lastUploadTimestamp.is_none() {
            self.lastUploadTimestamp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lastUploadTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastUploadTimestamp(&mut self) -> ::std::string::String {
        self.lastUploadTimestamp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string handle = 3;

    pub fn handle(&self) -> &str {
        match self.handle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        if self.handle.is_none() {
            self.handle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        self.handle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string encFilehash = 4;

    pub fn encFilehash(&self) -> &str {
        match self.encFilehash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encFilehash(&mut self) {
        self.encFilehash = ::std::option::Option::None;
    }

    pub fn has_encFilehash(&self) -> bool {
        self.encFilehash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encFilehash(&mut self, v: ::std::string::String) {
        self.encFilehash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encFilehash(&mut self) -> &mut ::std::string::String {
        if self.encFilehash.is_none() {
            self.encFilehash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encFilehash.as_mut().unwrap()
    }

    // Take field
    pub fn take_encFilehash(&mut self) -> ::std::string::String {
        self.encFilehash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stickerHashWithoutMeta = 5;

    pub fn stickerHashWithoutMeta(&self) -> &str {
        match self.stickerHashWithoutMeta.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stickerHashWithoutMeta(&mut self) {
        self.stickerHashWithoutMeta = ::std::option::Option::None;
    }

    pub fn has_stickerHashWithoutMeta(&self) -> bool {
        self.stickerHashWithoutMeta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stickerHashWithoutMeta(&mut self, v: ::std::string::String) {
        self.stickerHashWithoutMeta = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stickerHashWithoutMeta(&mut self) -> &mut ::std::string::String {
        if self.stickerHashWithoutMeta.is_none() {
            self.stickerHashWithoutMeta = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stickerHashWithoutMeta.as_mut().unwrap()
    }

    // Take field
    pub fn take_stickerHashWithoutMeta(&mut self) -> ::std::string::String {
        self.stickerHashWithoutMeta.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mediaKey = 6;

    pub fn mediaKey(&self) -> &str {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::string::String) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::string::String {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::string::String {
        self.mediaKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 7;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool isFavorite = 8;

    pub fn isFavorite(&self) -> bool {
        self.isFavorite.unwrap_or(false)
    }

    pub fn clear_isFavorite(&mut self) {
        self.isFavorite = ::std::option::Option::None;
    }

    pub fn has_isFavorite(&self) -> bool {
        self.isFavorite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isFavorite(&mut self, v: bool) {
        self.isFavorite = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &FavoriteStickerAction| { &m.directPath },
            |m: &mut FavoriteStickerAction| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastUploadTimestamp",
            |m: &FavoriteStickerAction| { &m.lastUploadTimestamp },
            |m: &mut FavoriteStickerAction| { &mut m.lastUploadTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &FavoriteStickerAction| { &m.handle },
            |m: &mut FavoriteStickerAction| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encFilehash",
            |m: &FavoriteStickerAction| { &m.encFilehash },
            |m: &mut FavoriteStickerAction| { &mut m.encFilehash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stickerHashWithoutMeta",
            |m: &FavoriteStickerAction| { &m.stickerHashWithoutMeta },
            |m: &mut FavoriteStickerAction| { &mut m.stickerHashWithoutMeta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &FavoriteStickerAction| { &m.mediaKey },
            |m: &mut FavoriteStickerAction| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &FavoriteStickerAction| { &m.mediaKeyTimestamp },
            |m: &mut FavoriteStickerAction| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isFavorite",
            |m: &FavoriteStickerAction| { &m.isFavorite },
            |m: &mut FavoriteStickerAction| { &mut m.isFavorite },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FavoriteStickerAction>(
            "FavoriteStickerAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FavoriteStickerAction {
    const NAME: &'static str = "FavoriteStickerAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.lastUploadTimestamp = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.handle = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.encFilehash = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.stickerHashWithoutMeta = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.isFavorite = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.lastUploadTimestamp.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.handle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.encFilehash.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.stickerHashWithoutMeta.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.isFavorite {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.lastUploadTimestamp.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.handle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.encFilehash.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.stickerHashWithoutMeta.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.isFavorite {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FavoriteStickerAction {
        FavoriteStickerAction::new()
    }

    fn clear(&mut self) {
        self.directPath = ::std::option::Option::None;
        self.lastUploadTimestamp = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.encFilehash = ::std::option::Option::None;
        self.stickerHashWithoutMeta = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.isFavorite = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FavoriteStickerAction {
        static instance: FavoriteStickerAction = FavoriteStickerAction {
            directPath: ::std::option::Option::None,
            lastUploadTimestamp: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            encFilehash: ::std::option::Option::None,
            stickerHashWithoutMeta: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            isFavorite: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FavoriteStickerAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FavoriteStickerAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FavoriteStickerAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FavoriteStickerAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ArchiveChatAction)
pub struct ArchiveChatAction {
    // message fields
    // @@protoc_insertion_point(field:ArchiveChatAction.archived)
    pub archived: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ArchiveChatAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:ArchiveChatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArchiveChatAction {
    fn default() -> &'a ArchiveChatAction {
        <ArchiveChatAction as ::protobuf::Message>::default_instance()
    }
}

impl ArchiveChatAction {
    pub fn new() -> ArchiveChatAction {
        ::std::default::Default::default()
    }

    // optional bool archived = 1;

    pub fn archived(&self) -> bool {
        self.archived.unwrap_or(false)
    }

    pub fn clear_archived(&mut self) {
        self.archived = ::std::option::Option::None;
    }

    pub fn has_archived(&self) -> bool {
        self.archived.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archived(&mut self, v: bool) {
        self.archived = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "archived",
            |m: &ArchiveChatAction| { &m.archived },
            |m: &mut ArchiveChatAction| { &mut m.archived },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &ArchiveChatAction| { &m.messageRange },
            |m: &mut ArchiveChatAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArchiveChatAction>(
            "ArchiveChatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArchiveChatAction {
    const NAME: &'static str = "ArchiveChatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.archived = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.archived {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.archived {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArchiveChatAction {
        ArchiveChatAction::new()
    }

    fn clear(&mut self) {
        self.archived = ::std::option::Option::None;
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArchiveChatAction {
        static instance: ArchiveChatAction = ArchiveChatAction {
            archived: ::std::option::Option::None,
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArchiveChatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArchiveChatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArchiveChatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArchiveChatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteMessageForMeAction)
pub struct DeleteMessageForMeAction {
    // message fields
    // @@protoc_insertion_point(field:DeleteMessageForMeAction.deleteMedia)
    pub deleteMedia: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DeleteMessageForMeAction.messageTimestamp)
    pub messageTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteMessageForMeAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteMessageForMeAction {
    fn default() -> &'a DeleteMessageForMeAction {
        <DeleteMessageForMeAction as ::protobuf::Message>::default_instance()
    }
}

impl DeleteMessageForMeAction {
    pub fn new() -> DeleteMessageForMeAction {
        ::std::default::Default::default()
    }

    // optional bool deleteMedia = 1;

    pub fn deleteMedia(&self) -> bool {
        self.deleteMedia.unwrap_or(false)
    }

    pub fn clear_deleteMedia(&mut self) {
        self.deleteMedia = ::std::option::Option::None;
    }

    pub fn has_deleteMedia(&self) -> bool {
        self.deleteMedia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleteMedia(&mut self, v: bool) {
        self.deleteMedia = ::std::option::Option::Some(v);
    }

    // optional int64 messageTimestamp = 2;

    pub fn messageTimestamp(&self) -> i64 {
        self.messageTimestamp.unwrap_or(0)
    }

    pub fn clear_messageTimestamp(&mut self) {
        self.messageTimestamp = ::std::option::Option::None;
    }

    pub fn has_messageTimestamp(&self) -> bool {
        self.messageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageTimestamp(&mut self, v: i64) {
        self.messageTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleteMedia",
            |m: &DeleteMessageForMeAction| { &m.deleteMedia },
            |m: &mut DeleteMessageForMeAction| { &mut m.deleteMedia },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageTimestamp",
            |m: &DeleteMessageForMeAction| { &m.messageTimestamp },
            |m: &mut DeleteMessageForMeAction| { &mut m.messageTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteMessageForMeAction>(
            "DeleteMessageForMeAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteMessageForMeAction {
    const NAME: &'static str = "DeleteMessageForMeAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deleteMedia = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.messageTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deleteMedia {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messageTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deleteMedia {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.messageTimestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteMessageForMeAction {
        DeleteMessageForMeAction::new()
    }

    fn clear(&mut self) {
        self.deleteMedia = ::std::option::Option::None;
        self.messageTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteMessageForMeAction {
        static instance: DeleteMessageForMeAction = DeleteMessageForMeAction {
            deleteMedia: ::std::option::Option::None,
            messageTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteMessageForMeAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteMessageForMeAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteMessageForMeAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteMessageForMeAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MarkChatAsReadAction)
pub struct MarkChatAsReadAction {
    // message fields
    // @@protoc_insertion_point(field:MarkChatAsReadAction.read)
    pub read: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MarkChatAsReadAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:MarkChatAsReadAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarkChatAsReadAction {
    fn default() -> &'a MarkChatAsReadAction {
        <MarkChatAsReadAction as ::protobuf::Message>::default_instance()
    }
}

impl MarkChatAsReadAction {
    pub fn new() -> MarkChatAsReadAction {
        ::std::default::Default::default()
    }

    // optional bool read = 1;

    pub fn read(&self) -> bool {
        self.read.unwrap_or(false)
    }

    pub fn clear_read(&mut self) {
        self.read = ::std::option::Option::None;
    }

    pub fn has_read(&self) -> bool {
        self.read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: bool) {
        self.read = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "read",
            |m: &MarkChatAsReadAction| { &m.read },
            |m: &mut MarkChatAsReadAction| { &mut m.read },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &MarkChatAsReadAction| { &m.messageRange },
            |m: &mut MarkChatAsReadAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarkChatAsReadAction>(
            "MarkChatAsReadAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarkChatAsReadAction {
    const NAME: &'static str = "MarkChatAsReadAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.read = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.read {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.read {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarkChatAsReadAction {
        MarkChatAsReadAction::new()
    }

    fn clear(&mut self) {
        self.read = ::std::option::Option::None;
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarkChatAsReadAction {
        static instance: MarkChatAsReadAction = MarkChatAsReadAction {
            read: ::std::option::Option::None,
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarkChatAsReadAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarkChatAsReadAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarkChatAsReadAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkChatAsReadAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ClearChatAction)
pub struct ClearChatAction {
    // message fields
    // @@protoc_insertion_point(field:ClearChatAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:ClearChatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClearChatAction {
    fn default() -> &'a ClearChatAction {
        <ClearChatAction as ::protobuf::Message>::default_instance()
    }
}

impl ClearChatAction {
    pub fn new() -> ClearChatAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &ClearChatAction| { &m.messageRange },
            |m: &mut ClearChatAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClearChatAction>(
            "ClearChatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClearChatAction {
    const NAME: &'static str = "ClearChatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClearChatAction {
        ClearChatAction::new()
    }

    fn clear(&mut self) {
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClearChatAction {
        static instance: ClearChatAction = ClearChatAction {
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClearChatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClearChatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClearChatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearChatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteChatAction)
pub struct DeleteChatAction {
    // message fields
    // @@protoc_insertion_point(field:DeleteChatAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteChatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteChatAction {
    fn default() -> &'a DeleteChatAction {
        <DeleteChatAction as ::protobuf::Message>::default_instance()
    }
}

impl DeleteChatAction {
    pub fn new() -> DeleteChatAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &DeleteChatAction| { &m.messageRange },
            |m: &mut DeleteChatAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteChatAction>(
            "DeleteChatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteChatAction {
    const NAME: &'static str = "DeleteChatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteChatAction {
        DeleteChatAction::new()
    }

    fn clear(&mut self) {
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteChatAction {
        static instance: DeleteChatAction = DeleteChatAction {
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteChatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteChatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteChatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteChatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UnarchiveChatsSetting)
pub struct UnarchiveChatsSetting {
    // message fields
    // @@protoc_insertion_point(field:UnarchiveChatsSetting.unarchiveChats)
    pub unarchiveChats: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:UnarchiveChatsSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnarchiveChatsSetting {
    fn default() -> &'a UnarchiveChatsSetting {
        <UnarchiveChatsSetting as ::protobuf::Message>::default_instance()
    }
}

impl UnarchiveChatsSetting {
    pub fn new() -> UnarchiveChatsSetting {
        ::std::default::Default::default()
    }

    // optional bool unarchiveChats = 1;

    pub fn unarchiveChats(&self) -> bool {
        self.unarchiveChats.unwrap_or(false)
    }

    pub fn clear_unarchiveChats(&mut self) {
        self.unarchiveChats = ::std::option::Option::None;
    }

    pub fn has_unarchiveChats(&self) -> bool {
        self.unarchiveChats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unarchiveChats(&mut self, v: bool) {
        self.unarchiveChats = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unarchiveChats",
            |m: &UnarchiveChatsSetting| { &m.unarchiveChats },
            |m: &mut UnarchiveChatsSetting| { &mut m.unarchiveChats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnarchiveChatsSetting>(
            "UnarchiveChatsSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnarchiveChatsSetting {
    const NAME: &'static str = "UnarchiveChatsSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unarchiveChats = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unarchiveChats {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unarchiveChats {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnarchiveChatsSetting {
        UnarchiveChatsSetting::new()
    }

    fn clear(&mut self) {
        self.unarchiveChats = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnarchiveChatsSetting {
        static instance: UnarchiveChatsSetting = UnarchiveChatsSetting {
            unarchiveChats: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnarchiveChatsSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnarchiveChatsSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnarchiveChatsSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnarchiveChatsSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncActionMessageRange)
pub struct SyncActionMessageRange {
    // message fields
    // @@protoc_insertion_point(field:SyncActionMessageRange.lastMessageTimestamp)
    pub lastMessageTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:SyncActionMessageRange.lastSystemMessageTimestamp)
    pub lastSystemMessageTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:SyncActionMessageRange.messages)
    pub messages: ::std::vec::Vec<SyncActionMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncActionMessageRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionMessageRange {
    fn default() -> &'a SyncActionMessageRange {
        <SyncActionMessageRange as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionMessageRange {
    pub fn new() -> SyncActionMessageRange {
        ::std::default::Default::default()
    }

    // optional int64 lastMessageTimestamp = 1;

    pub fn lastMessageTimestamp(&self) -> i64 {
        self.lastMessageTimestamp.unwrap_or(0)
    }

    pub fn clear_lastMessageTimestamp(&mut self) {
        self.lastMessageTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastMessageTimestamp(&self) -> bool {
        self.lastMessageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastMessageTimestamp(&mut self, v: i64) {
        self.lastMessageTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 lastSystemMessageTimestamp = 2;

    pub fn lastSystemMessageTimestamp(&self) -> i64 {
        self.lastSystemMessageTimestamp.unwrap_or(0)
    }

    pub fn clear_lastSystemMessageTimestamp(&mut self) {
        self.lastSystemMessageTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastSystemMessageTimestamp(&self) -> bool {
        self.lastSystemMessageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastSystemMessageTimestamp(&mut self, v: i64) {
        self.lastSystemMessageTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastMessageTimestamp",
            |m: &SyncActionMessageRange| { &m.lastMessageTimestamp },
            |m: &mut SyncActionMessageRange| { &mut m.lastMessageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastSystemMessageTimestamp",
            |m: &SyncActionMessageRange| { &m.lastSystemMessageTimestamp },
            |m: &mut SyncActionMessageRange| { &mut m.lastSystemMessageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &SyncActionMessageRange| { &m.messages },
            |m: &mut SyncActionMessageRange| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionMessageRange>(
            "SyncActionMessageRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionMessageRange {
    const NAME: &'static str = "SyncActionMessageRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lastMessageTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.lastSystemMessageTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lastMessageTimestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.lastSystemMessageTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lastMessageTimestamp {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.lastSystemMessageTimestamp {
            os.write_int64(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionMessageRange {
        SyncActionMessageRange::new()
    }

    fn clear(&mut self) {
        self.lastMessageTimestamp = ::std::option::Option::None;
        self.lastSystemMessageTimestamp = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionMessageRange {
        static instance: SyncActionMessageRange = SyncActionMessageRange {
            lastMessageTimestamp: ::std::option::Option::None,
            lastSystemMessageTimestamp: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionMessageRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionMessageRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionMessageRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionMessageRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncActionMessage)
pub struct SyncActionMessage {
    // message fields
    // @@protoc_insertion_point(field:SyncActionMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:SyncActionMessage.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncActionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionMessage {
    fn default() -> &'a SyncActionMessage {
        <SyncActionMessage as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionMessage {
    pub fn new() -> SyncActionMessage {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &SyncActionMessage| { &m.key },
            |m: &mut SyncActionMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &SyncActionMessage| { &m.timestamp },
            |m: &mut SyncActionMessage| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionMessage>(
            "SyncActionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionMessage {
    const NAME: &'static str = "SyncActionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionMessage {
        SyncActionMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionMessage {
        static instance: SyncActionMessage = SyncActionMessage {
            key: ::protobuf::MessageField::none(),
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:KeyExpiration)
pub struct KeyExpiration {
    // message fields
    // @@protoc_insertion_point(field:KeyExpiration.expiredKeyEpoch)
    pub expiredKeyEpoch: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:KeyExpiration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyExpiration {
    fn default() -> &'a KeyExpiration {
        <KeyExpiration as ::protobuf::Message>::default_instance()
    }
}

impl KeyExpiration {
    pub fn new() -> KeyExpiration {
        ::std::default::Default::default()
    }

    // optional int32 expiredKeyEpoch = 1;

    pub fn expiredKeyEpoch(&self) -> i32 {
        self.expiredKeyEpoch.unwrap_or(0)
    }

    pub fn clear_expiredKeyEpoch(&mut self) {
        self.expiredKeyEpoch = ::std::option::Option::None;
    }

    pub fn has_expiredKeyEpoch(&self) -> bool {
        self.expiredKeyEpoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiredKeyEpoch(&mut self, v: i32) {
        self.expiredKeyEpoch = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiredKeyEpoch",
            |m: &KeyExpiration| { &m.expiredKeyEpoch },
            |m: &mut KeyExpiration| { &mut m.expiredKeyEpoch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyExpiration>(
            "KeyExpiration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyExpiration {
    const NAME: &'static str = "KeyExpiration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.expiredKeyEpoch = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.expiredKeyEpoch {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.expiredKeyEpoch {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyExpiration {
        KeyExpiration::new()
    }

    fn clear(&mut self) {
        self.expiredKeyEpoch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyExpiration {
        static instance: KeyExpiration = KeyExpiration {
            expiredKeyEpoch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyExpiration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyExpiration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyExpiration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyExpiration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PrimaryFeature)
pub struct PrimaryFeature {
    // message fields
    // @@protoc_insertion_point(field:PrimaryFeature.flags)
    pub flags: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:PrimaryFeature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrimaryFeature {
    fn default() -> &'a PrimaryFeature {
        <PrimaryFeature as ::protobuf::Message>::default_instance()
    }
}

impl PrimaryFeature {
    pub fn new() -> PrimaryFeature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flags",
            |m: &PrimaryFeature| { &m.flags },
            |m: &mut PrimaryFeature| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrimaryFeature>(
            "PrimaryFeature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrimaryFeature {
    const NAME: &'static str = "PrimaryFeature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.flags.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.flags {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.flags {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrimaryFeature {
        PrimaryFeature::new()
    }

    fn clear(&mut self) {
        self.flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrimaryFeature {
        static instance: PrimaryFeature = PrimaryFeature {
            flags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrimaryFeature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrimaryFeature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrimaryFeature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimaryFeature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AndroidUnsupportedActions)
pub struct AndroidUnsupportedActions {
    // message fields
    // @@protoc_insertion_point(field:AndroidUnsupportedActions.allowed)
    pub allowed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:AndroidUnsupportedActions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AndroidUnsupportedActions {
    fn default() -> &'a AndroidUnsupportedActions {
        <AndroidUnsupportedActions as ::protobuf::Message>::default_instance()
    }
}

impl AndroidUnsupportedActions {
    pub fn new() -> AndroidUnsupportedActions {
        ::std::default::Default::default()
    }

    // optional bool allowed = 1;

    pub fn allowed(&self) -> bool {
        self.allowed.unwrap_or(false)
    }

    pub fn clear_allowed(&mut self) {
        self.allowed = ::std::option::Option::None;
    }

    pub fn has_allowed(&self) -> bool {
        self.allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed(&mut self, v: bool) {
        self.allowed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allowed",
            |m: &AndroidUnsupportedActions| { &m.allowed },
            |m: &mut AndroidUnsupportedActions| { &mut m.allowed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AndroidUnsupportedActions>(
            "AndroidUnsupportedActions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AndroidUnsupportedActions {
    const NAME: &'static str = "AndroidUnsupportedActions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allowed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allowed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AndroidUnsupportedActions {
        AndroidUnsupportedActions::new()
    }

    fn clear(&mut self) {
        self.allowed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AndroidUnsupportedActions {
        static instance: AndroidUnsupportedActions = AndroidUnsupportedActions {
            allowed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AndroidUnsupportedActions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AndroidUnsupportedActions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AndroidUnsupportedActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidUnsupportedActions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncActionValue)
pub struct SyncActionValue {
    // message fields
    // @@protoc_insertion_point(field:SyncActionValue.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:SyncActionValue.starAction)
    pub starAction: ::protobuf::MessageField<StarAction>,
    // @@protoc_insertion_point(field:SyncActionValue.contactAction)
    pub contactAction: ::protobuf::MessageField<ContactAction>,
    // @@protoc_insertion_point(field:SyncActionValue.muteAction)
    pub muteAction: ::protobuf::MessageField<MuteAction>,
    // @@protoc_insertion_point(field:SyncActionValue.pinAction)
    pub pinAction: ::protobuf::MessageField<PinAction>,
    // @@protoc_insertion_point(field:SyncActionValue.securityNotificationSetting)
    pub securityNotificationSetting: ::protobuf::MessageField<SecurityNotificationSetting>,
    // @@protoc_insertion_point(field:SyncActionValue.pushNameSetting)
    pub pushNameSetting: ::protobuf::MessageField<PushNameSetting>,
    // @@protoc_insertion_point(field:SyncActionValue.quickReplyAction)
    pub quickReplyAction: ::protobuf::MessageField<QuickReplyAction>,
    // @@protoc_insertion_point(field:SyncActionValue.recentStickerWeightsAction)
    pub recentStickerWeightsAction: ::protobuf::MessageField<RecentStickerWeightsAction>,
    // @@protoc_insertion_point(field:SyncActionValue.recentStickerMetadata)
    pub recentStickerMetadata: ::protobuf::MessageField<RecentStickerMetadata>,
    // @@protoc_insertion_point(field:SyncActionValue.recentEmojiWeightsAction)
    pub recentEmojiWeightsAction: ::protobuf::MessageField<RecentEmojiWeightsAction>,
    // @@protoc_insertion_point(field:SyncActionValue.labelEditAction)
    pub labelEditAction: ::protobuf::MessageField<LabelEditAction>,
    // @@protoc_insertion_point(field:SyncActionValue.labelAssociationAction)
    pub labelAssociationAction: ::protobuf::MessageField<LabelAssociationAction>,
    // @@protoc_insertion_point(field:SyncActionValue.localeSetting)
    pub localeSetting: ::protobuf::MessageField<LocaleSetting>,
    // @@protoc_insertion_point(field:SyncActionValue.archiveChatAction)
    pub archiveChatAction: ::protobuf::MessageField<ArchiveChatAction>,
    // @@protoc_insertion_point(field:SyncActionValue.deleteMessageForMeAction)
    pub deleteMessageForMeAction: ::protobuf::MessageField<DeleteMessageForMeAction>,
    // @@protoc_insertion_point(field:SyncActionValue.keyExpiration)
    pub keyExpiration: ::protobuf::MessageField<KeyExpiration>,
    // @@protoc_insertion_point(field:SyncActionValue.markChatAsReadAction)
    pub markChatAsReadAction: ::protobuf::MessageField<MarkChatAsReadAction>,
    // @@protoc_insertion_point(field:SyncActionValue.clearChatAction)
    pub clearChatAction: ::protobuf::MessageField<ClearChatAction>,
    // @@protoc_insertion_point(field:SyncActionValue.deleteChatAction)
    pub deleteChatAction: ::protobuf::MessageField<DeleteChatAction>,
    // @@protoc_insertion_point(field:SyncActionValue.unarchiveChatsSetting)
    pub unarchiveChatsSetting: ::protobuf::MessageField<UnarchiveChatsSetting>,
    // @@protoc_insertion_point(field:SyncActionValue.primaryFeature)
    pub primaryFeature: ::protobuf::MessageField<PrimaryFeature>,
    // @@protoc_insertion_point(field:SyncActionValue.favoriteStickerAction)
    pub favoriteStickerAction: ::protobuf::MessageField<FavoriteStickerAction>,
    // @@protoc_insertion_point(field:SyncActionValue.androidUnsupportedActions)
    pub androidUnsupportedActions: ::protobuf::MessageField<AndroidUnsupportedActions>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncActionValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionValue {
    fn default() -> &'a SyncActionValue {
        <SyncActionValue as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionValue {
    pub fn new() -> SyncActionValue {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 1;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &SyncActionValue| { &m.timestamp },
            |m: &mut SyncActionValue| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StarAction>(
            "starAction",
            |m: &SyncActionValue| { &m.starAction },
            |m: &mut SyncActionValue| { &mut m.starAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContactAction>(
            "contactAction",
            |m: &SyncActionValue| { &m.contactAction },
            |m: &mut SyncActionValue| { &mut m.contactAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MuteAction>(
            "muteAction",
            |m: &SyncActionValue| { &m.muteAction },
            |m: &mut SyncActionValue| { &mut m.muteAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PinAction>(
            "pinAction",
            |m: &SyncActionValue| { &m.pinAction },
            |m: &mut SyncActionValue| { &mut m.pinAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecurityNotificationSetting>(
            "securityNotificationSetting",
            |m: &SyncActionValue| { &m.securityNotificationSetting },
            |m: &mut SyncActionValue| { &mut m.securityNotificationSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PushNameSetting>(
            "pushNameSetting",
            |m: &SyncActionValue| { &m.pushNameSetting },
            |m: &mut SyncActionValue| { &mut m.pushNameSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QuickReplyAction>(
            "quickReplyAction",
            |m: &SyncActionValue| { &m.quickReplyAction },
            |m: &mut SyncActionValue| { &mut m.quickReplyAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecentStickerWeightsAction>(
            "recentStickerWeightsAction",
            |m: &SyncActionValue| { &m.recentStickerWeightsAction },
            |m: &mut SyncActionValue| { &mut m.recentStickerWeightsAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecentStickerMetadata>(
            "recentStickerMetadata",
            |m: &SyncActionValue| { &m.recentStickerMetadata },
            |m: &mut SyncActionValue| { &mut m.recentStickerMetadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecentEmojiWeightsAction>(
            "recentEmojiWeightsAction",
            |m: &SyncActionValue| { &m.recentEmojiWeightsAction },
            |m: &mut SyncActionValue| { &mut m.recentEmojiWeightsAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LabelEditAction>(
            "labelEditAction",
            |m: &SyncActionValue| { &m.labelEditAction },
            |m: &mut SyncActionValue| { &mut m.labelEditAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LabelAssociationAction>(
            "labelAssociationAction",
            |m: &SyncActionValue| { &m.labelAssociationAction },
            |m: &mut SyncActionValue| { &mut m.labelAssociationAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocaleSetting>(
            "localeSetting",
            |m: &SyncActionValue| { &m.localeSetting },
            |m: &mut SyncActionValue| { &mut m.localeSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArchiveChatAction>(
            "archiveChatAction",
            |m: &SyncActionValue| { &m.archiveChatAction },
            |m: &mut SyncActionValue| { &mut m.archiveChatAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeleteMessageForMeAction>(
            "deleteMessageForMeAction",
            |m: &SyncActionValue| { &m.deleteMessageForMeAction },
            |m: &mut SyncActionValue| { &mut m.deleteMessageForMeAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyExpiration>(
            "keyExpiration",
            |m: &SyncActionValue| { &m.keyExpiration },
            |m: &mut SyncActionValue| { &mut m.keyExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MarkChatAsReadAction>(
            "markChatAsReadAction",
            |m: &SyncActionValue| { &m.markChatAsReadAction },
            |m: &mut SyncActionValue| { &mut m.markChatAsReadAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClearChatAction>(
            "clearChatAction",
            |m: &SyncActionValue| { &m.clearChatAction },
            |m: &mut SyncActionValue| { &mut m.clearChatAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeleteChatAction>(
            "deleteChatAction",
            |m: &SyncActionValue| { &m.deleteChatAction },
            |m: &mut SyncActionValue| { &mut m.deleteChatAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnarchiveChatsSetting>(
            "unarchiveChatsSetting",
            |m: &SyncActionValue| { &m.unarchiveChatsSetting },
            |m: &mut SyncActionValue| { &mut m.unarchiveChatsSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PrimaryFeature>(
            "primaryFeature",
            |m: &SyncActionValue| { &m.primaryFeature },
            |m: &mut SyncActionValue| { &mut m.primaryFeature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FavoriteStickerAction>(
            "favoriteStickerAction",
            |m: &SyncActionValue| { &m.favoriteStickerAction },
            |m: &mut SyncActionValue| { &mut m.favoriteStickerAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AndroidUnsupportedActions>(
            "androidUnsupportedActions",
            |m: &SyncActionValue| { &m.androidUnsupportedActions },
            |m: &mut SyncActionValue| { &mut m.androidUnsupportedActions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionValue>(
            "SyncActionValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionValue {
    const NAME: &'static str = "SyncActionValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.starAction)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contactAction)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.muteAction)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pinAction)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.securityNotificationSetting)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pushNameSetting)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quickReplyAction)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recentStickerWeightsAction)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recentStickerMetadata)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recentEmojiWeightsAction)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelEditAction)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelAssociationAction)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localeSetting)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.archiveChatAction)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deleteMessageForMeAction)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyExpiration)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.markChatAsReadAction)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clearChatAction)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deleteChatAction)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unarchiveChatsSetting)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.primaryFeature)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.favoriteStickerAction)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.androidUnsupportedActions)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.starAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contactAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.muteAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pinAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.securityNotificationSetting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pushNameSetting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quickReplyAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recentStickerWeightsAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recentStickerMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recentEmojiWeightsAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.labelEditAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.labelAssociationAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.localeSetting.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.archiveChatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deleteMessageForMeAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keyExpiration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.markChatAsReadAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clearChatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deleteChatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unarchiveChatsSetting.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.primaryFeature.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.favoriteStickerAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.androidUnsupportedActions.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.starAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.contactAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.muteAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.pinAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.securityNotificationSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.pushNameSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.quickReplyAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.recentStickerWeightsAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.recentStickerMetadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.recentEmojiWeightsAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.labelEditAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.labelAssociationAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.localeSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.archiveChatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.deleteMessageForMeAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.keyExpiration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.markChatAsReadAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.clearChatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.deleteChatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.unarchiveChatsSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.primaryFeature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.favoriteStickerAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.androidUnsupportedActions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionValue {
        SyncActionValue::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.starAction.clear();
        self.contactAction.clear();
        self.muteAction.clear();
        self.pinAction.clear();
        self.securityNotificationSetting.clear();
        self.pushNameSetting.clear();
        self.quickReplyAction.clear();
        self.recentStickerWeightsAction.clear();
        self.recentStickerMetadata.clear();
        self.recentEmojiWeightsAction.clear();
        self.labelEditAction.clear();
        self.labelAssociationAction.clear();
        self.localeSetting.clear();
        self.archiveChatAction.clear();
        self.deleteMessageForMeAction.clear();
        self.keyExpiration.clear();
        self.markChatAsReadAction.clear();
        self.clearChatAction.clear();
        self.deleteChatAction.clear();
        self.unarchiveChatsSetting.clear();
        self.primaryFeature.clear();
        self.favoriteStickerAction.clear();
        self.androidUnsupportedActions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionValue {
        static instance: SyncActionValue = SyncActionValue {
            timestamp: ::std::option::Option::None,
            starAction: ::protobuf::MessageField::none(),
            contactAction: ::protobuf::MessageField::none(),
            muteAction: ::protobuf::MessageField::none(),
            pinAction: ::protobuf::MessageField::none(),
            securityNotificationSetting: ::protobuf::MessageField::none(),
            pushNameSetting: ::protobuf::MessageField::none(),
            quickReplyAction: ::protobuf::MessageField::none(),
            recentStickerWeightsAction: ::protobuf::MessageField::none(),
            recentStickerMetadata: ::protobuf::MessageField::none(),
            recentEmojiWeightsAction: ::protobuf::MessageField::none(),
            labelEditAction: ::protobuf::MessageField::none(),
            labelAssociationAction: ::protobuf::MessageField::none(),
            localeSetting: ::protobuf::MessageField::none(),
            archiveChatAction: ::protobuf::MessageField::none(),
            deleteMessageForMeAction: ::protobuf::MessageField::none(),
            keyExpiration: ::protobuf::MessageField::none(),
            markChatAsReadAction: ::protobuf::MessageField::none(),
            clearChatAction: ::protobuf::MessageField::none(),
            deleteChatAction: ::protobuf::MessageField::none(),
            unarchiveChatsSetting: ::protobuf::MessageField::none(),
            primaryFeature: ::protobuf::MessageField::none(),
            favoriteStickerAction: ::protobuf::MessageField::none(),
            androidUnsupportedActions: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RecentEmojiWeight)
pub struct RecentEmojiWeight {
    // message fields
    // @@protoc_insertion_point(field:RecentEmojiWeight.emoji)
    pub emoji: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentEmojiWeight.weight)
    pub weight: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:RecentEmojiWeight.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecentEmojiWeight {
    fn default() -> &'a RecentEmojiWeight {
        <RecentEmojiWeight as ::protobuf::Message>::default_instance()
    }
}

impl RecentEmojiWeight {
    pub fn new() -> RecentEmojiWeight {
        ::std::default::Default::default()
    }

    // optional string emoji = 1;

    pub fn emoji(&self) -> &str {
        match self.emoji.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_emoji(&mut self) {
        self.emoji = ::std::option::Option::None;
    }

    pub fn has_emoji(&self) -> bool {
        self.emoji.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoji(&mut self, v: ::std::string::String) {
        self.emoji = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emoji(&mut self) -> &mut ::std::string::String {
        if self.emoji.is_none() {
            self.emoji = ::std::option::Option::Some(::std::string::String::new());
        }
        self.emoji.as_mut().unwrap()
    }

    // Take field
    pub fn take_emoji(&mut self) -> ::std::string::String {
        self.emoji.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float weight = 2;

    pub fn weight(&self) -> f32 {
        self.weight.unwrap_or(0.)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f32) {
        self.weight = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "emoji",
            |m: &RecentEmojiWeight| { &m.emoji },
            |m: &mut RecentEmojiWeight| { &mut m.emoji },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &RecentEmojiWeight| { &m.weight },
            |m: &mut RecentEmojiWeight| { &mut m.weight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecentEmojiWeight>(
            "RecentEmojiWeight",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecentEmojiWeight {
    const NAME: &'static str = "RecentEmojiWeight";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.emoji = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.weight = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.emoji.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.weight {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.emoji.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.weight {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecentEmojiWeight {
        RecentEmojiWeight::new()
    }

    fn clear(&mut self) {
        self.emoji = ::std::option::Option::None;
        self.weight = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecentEmojiWeight {
        static instance: RecentEmojiWeight = RecentEmojiWeight {
            emoji: ::std::option::Option::None,
            weight: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecentEmojiWeight {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecentEmojiWeight").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecentEmojiWeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecentEmojiWeight {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RecentStickerWeight)
pub struct RecentStickerWeight {
    // message fields
    // @@protoc_insertion_point(field:RecentStickerWeight.filehash)
    pub filehash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RecentStickerWeight.weight)
    pub weight: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:RecentStickerWeight.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecentStickerWeight {
    fn default() -> &'a RecentStickerWeight {
        <RecentStickerWeight as ::protobuf::Message>::default_instance()
    }
}

impl RecentStickerWeight {
    pub fn new() -> RecentStickerWeight {
        ::std::default::Default::default()
    }

    // optional string filehash = 1;

    pub fn filehash(&self) -> &str {
        match self.filehash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filehash(&mut self) {
        self.filehash = ::std::option::Option::None;
    }

    pub fn has_filehash(&self) -> bool {
        self.filehash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filehash(&mut self, v: ::std::string::String) {
        self.filehash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filehash(&mut self) -> &mut ::std::string::String {
        if self.filehash.is_none() {
            self.filehash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filehash.as_mut().unwrap()
    }

    // Take field
    pub fn take_filehash(&mut self) -> ::std::string::String {
        self.filehash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float weight = 2;

    pub fn weight(&self) -> f32 {
        self.weight.unwrap_or(0.)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f32) {
        self.weight = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filehash",
            |m: &RecentStickerWeight| { &m.filehash },
            |m: &mut RecentStickerWeight| { &mut m.filehash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &RecentStickerWeight| { &m.weight },
            |m: &mut RecentStickerWeight| { &mut m.weight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecentStickerWeight>(
            "RecentStickerWeight",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecentStickerWeight {
    const NAME: &'static str = "RecentStickerWeight";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filehash = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.weight = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filehash.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.weight {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filehash.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.weight {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecentStickerWeight {
        RecentStickerWeight::new()
    }

    fn clear(&mut self) {
        self.filehash = ::std::option::Option::None;
        self.weight = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecentStickerWeight {
        static instance: RecentStickerWeight = RecentStickerWeight {
            filehash: ::std::option::Option::None,
            weight: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecentStickerWeight {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecentStickerWeight").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecentStickerWeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecentStickerWeight {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdPatch)
pub struct SyncdPatch {
    // message fields
    // @@protoc_insertion_point(field:SyncdPatch.version)
    pub version: ::protobuf::MessageField<SyncdVersion>,
    // @@protoc_insertion_point(field:SyncdPatch.mutations)
    pub mutations: ::std::vec::Vec<SyncdMutation>,
    // @@protoc_insertion_point(field:SyncdPatch.externalMutations)
    pub externalMutations: ::protobuf::MessageField<ExternalBlobReference>,
    // @@protoc_insertion_point(field:SyncdPatch.snapshotMac)
    pub snapshotMac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:SyncdPatch.patchMac)
    pub patchMac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:SyncdPatch.keyId)
    pub keyId: ::protobuf::MessageField<KeyId>,
    // @@protoc_insertion_point(field:SyncdPatch.exitCode)
    pub exitCode: ::protobuf::MessageField<ExitCode>,
    // @@protoc_insertion_point(field:SyncdPatch.deviceIndex)
    pub deviceIndex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdPatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdPatch {
    fn default() -> &'a SyncdPatch {
        <SyncdPatch as ::protobuf::Message>::default_instance()
    }
}

impl SyncdPatch {
    pub fn new() -> SyncdPatch {
        ::std::default::Default::default()
    }

    // optional bytes snapshotMac = 4;

    pub fn snapshotMac(&self) -> &[u8] {
        match self.snapshotMac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_snapshotMac(&mut self) {
        self.snapshotMac = ::std::option::Option::None;
    }

    pub fn has_snapshotMac(&self) -> bool {
        self.snapshotMac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotMac(&mut self, v: ::std::vec::Vec<u8>) {
        self.snapshotMac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotMac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.snapshotMac.is_none() {
            self.snapshotMac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.snapshotMac.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotMac(&mut self) -> ::std::vec::Vec<u8> {
        self.snapshotMac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes patchMac = 5;

    pub fn patchMac(&self) -> &[u8] {
        match self.patchMac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_patchMac(&mut self) {
        self.patchMac = ::std::option::Option::None;
    }

    pub fn has_patchMac(&self) -> bool {
        self.patchMac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patchMac(&mut self, v: ::std::vec::Vec<u8>) {
        self.patchMac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patchMac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.patchMac.is_none() {
            self.patchMac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.patchMac.as_mut().unwrap()
    }

    // Take field
    pub fn take_patchMac(&mut self) -> ::std::vec::Vec<u8> {
        self.patchMac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 deviceIndex = 8;

    pub fn deviceIndex(&self) -> u32 {
        self.deviceIndex.unwrap_or(0)
    }

    pub fn clear_deviceIndex(&mut self) {
        self.deviceIndex = ::std::option::Option::None;
    }

    pub fn has_deviceIndex(&self) -> bool {
        self.deviceIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceIndex(&mut self, v: u32) {
        self.deviceIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdVersion>(
            "version",
            |m: &SyncdPatch| { &m.version },
            |m: &mut SyncdPatch| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mutations",
            |m: &SyncdPatch| { &m.mutations },
            |m: &mut SyncdPatch| { &mut m.mutations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExternalBlobReference>(
            "externalMutations",
            |m: &SyncdPatch| { &m.externalMutations },
            |m: &mut SyncdPatch| { &mut m.externalMutations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snapshotMac",
            |m: &SyncdPatch| { &m.snapshotMac },
            |m: &mut SyncdPatch| { &mut m.snapshotMac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "patchMac",
            |m: &SyncdPatch| { &m.patchMac },
            |m: &mut SyncdPatch| { &mut m.patchMac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyId>(
            "keyId",
            |m: &SyncdPatch| { &m.keyId },
            |m: &mut SyncdPatch| { &mut m.keyId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExitCode>(
            "exitCode",
            |m: &SyncdPatch| { &m.exitCode },
            |m: &mut SyncdPatch| { &mut m.exitCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceIndex",
            |m: &SyncdPatch| { &m.deviceIndex },
            |m: &mut SyncdPatch| { &mut m.deviceIndex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdPatch>(
            "SyncdPatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdPatch {
    const NAME: &'static str = "SyncdPatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                18 => {
                    self.mutations.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.externalMutations)?;
                },
                34 => {
                    self.snapshotMac = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.patchMac = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exitCode)?;
                },
                64 => {
                    self.deviceIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.externalMutations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.snapshotMac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.patchMac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.exitCode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deviceIndex {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.mutations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.externalMutations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.snapshotMac.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.patchMac.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.exitCode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.deviceIndex {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdPatch {
        SyncdPatch::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.mutations.clear();
        self.externalMutations.clear();
        self.snapshotMac = ::std::option::Option::None;
        self.patchMac = ::std::option::Option::None;
        self.keyId.clear();
        self.exitCode.clear();
        self.deviceIndex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdPatch {
        static instance: SyncdPatch = SyncdPatch {
            version: ::protobuf::MessageField::none(),
            mutations: ::std::vec::Vec::new(),
            externalMutations: ::protobuf::MessageField::none(),
            snapshotMac: ::std::option::Option::None,
            patchMac: ::std::option::Option::None,
            keyId: ::protobuf::MessageField::none(),
            exitCode: ::protobuf::MessageField::none(),
            deviceIndex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdPatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdPatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdPatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdPatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdMutation)
pub struct SyncdMutation {
    // message fields
    // @@protoc_insertion_point(field:SyncdMutation.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<syncd_mutation::SyncdMutationSyncdOperation>>,
    // @@protoc_insertion_point(field:SyncdMutation.record)
    pub record: ::protobuf::MessageField<SyncdRecord>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdMutation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdMutation {
    fn default() -> &'a SyncdMutation {
        <SyncdMutation as ::protobuf::Message>::default_instance()
    }
}

impl SyncdMutation {
    pub fn new() -> SyncdMutation {
        ::std::default::Default::default()
    }

    // optional .SyncdMutation.SyncdMutationSyncdOperation operation = 1;

    pub fn operation(&self) -> syncd_mutation::SyncdMutationSyncdOperation {
        match self.operation {
            Some(e) => e.enum_value_or(syncd_mutation::SyncdMutationSyncdOperation::SET),
            None => syncd_mutation::SyncdMutationSyncdOperation::SET,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: syncd_mutation::SyncdMutationSyncdOperation) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &SyncdMutation| { &m.operation },
            |m: &mut SyncdMutation| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdRecord>(
            "record",
            |m: &SyncdMutation| { &m.record },
            |m: &mut SyncdMutation| { &mut m.record },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdMutation>(
            "SyncdMutation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdMutation {
    const NAME: &'static str = "SyncdMutation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.record)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.record.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdMutation {
        SyncdMutation::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.record.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdMutation {
        static instance: SyncdMutation = SyncdMutation {
            operation: ::std::option::Option::None,
            record: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdMutation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdMutation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdMutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdMutation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SyncdMutation`
pub mod syncd_mutation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SyncdMutation.SyncdMutationSyncdOperation)
    pub enum SyncdMutationSyncdOperation {
        // @@protoc_insertion_point(enum_value:SyncdMutation.SyncdMutationSyncdOperation.SET)
        SET = 0,
        // @@protoc_insertion_point(enum_value:SyncdMutation.SyncdMutationSyncdOperation.REMOVE)
        REMOVE = 1,
    }

    impl ::protobuf::Enum for SyncdMutationSyncdOperation {
        const NAME: &'static str = "SyncdMutationSyncdOperation";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SyncdMutationSyncdOperation> {
            match value {
                0 => ::std::option::Option::Some(SyncdMutationSyncdOperation::SET),
                1 => ::std::option::Option::Some(SyncdMutationSyncdOperation::REMOVE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SyncdMutationSyncdOperation] = &[
            SyncdMutationSyncdOperation::SET,
            SyncdMutationSyncdOperation::REMOVE,
        ];
    }

    impl ::protobuf::EnumFull for SyncdMutationSyncdOperation {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SyncdMutation.SyncdMutationSyncdOperation").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SyncdMutationSyncdOperation {
        fn default() -> Self {
            SyncdMutationSyncdOperation::SET
        }
    }

    impl SyncdMutationSyncdOperation {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SyncdMutationSyncdOperation>("SyncdMutation.SyncdMutationSyncdOperation")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdMutations)
pub struct SyncdMutations {
    // message fields
    // @@protoc_insertion_point(field:SyncdMutations.mutations)
    pub mutations: ::std::vec::Vec<SyncdMutation>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdMutations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdMutations {
    fn default() -> &'a SyncdMutations {
        <SyncdMutations as ::protobuf::Message>::default_instance()
    }
}

impl SyncdMutations {
    pub fn new() -> SyncdMutations {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mutations",
            |m: &SyncdMutations| { &m.mutations },
            |m: &mut SyncdMutations| { &mut m.mutations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdMutations>(
            "SyncdMutations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdMutations {
    const NAME: &'static str = "SyncdMutations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mutations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.mutations {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdMutations {
        SyncdMutations::new()
    }

    fn clear(&mut self) {
        self.mutations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdMutations {
        static instance: SyncdMutations = SyncdMutations {
            mutations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdMutations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdMutations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdMutations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdMutations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdSnapshot)
pub struct SyncdSnapshot {
    // message fields
    // @@protoc_insertion_point(field:SyncdSnapshot.version)
    pub version: ::protobuf::MessageField<SyncdVersion>,
    // @@protoc_insertion_point(field:SyncdSnapshot.records)
    pub records: ::std::vec::Vec<SyncdRecord>,
    // @@protoc_insertion_point(field:SyncdSnapshot.mac)
    pub mac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:SyncdSnapshot.keyId)
    pub keyId: ::protobuf::MessageField<KeyId>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdSnapshot {
    fn default() -> &'a SyncdSnapshot {
        <SyncdSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl SyncdSnapshot {
    pub fn new() -> SyncdSnapshot {
        ::std::default::Default::default()
    }

    // optional bytes mac = 3;

    pub fn mac(&self) -> &[u8] {
        match self.mac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mac(&mut self) {
        self.mac = ::std::option::Option::None;
    }

    pub fn has_mac(&self) -> bool {
        self.mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mac(&mut self, v: ::std::vec::Vec<u8>) {
        self.mac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mac.is_none() {
            self.mac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mac.as_mut().unwrap()
    }

    // Take field
    pub fn take_mac(&mut self) -> ::std::vec::Vec<u8> {
        self.mac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdVersion>(
            "version",
            |m: &SyncdSnapshot| { &m.version },
            |m: &mut SyncdSnapshot| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "records",
            |m: &SyncdSnapshot| { &m.records },
            |m: &mut SyncdSnapshot| { &mut m.records },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mac",
            |m: &SyncdSnapshot| { &m.mac },
            |m: &mut SyncdSnapshot| { &mut m.mac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyId>(
            "keyId",
            |m: &SyncdSnapshot| { &m.keyId },
            |m: &mut SyncdSnapshot| { &mut m.keyId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdSnapshot>(
            "SyncdSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdSnapshot {
    const NAME: &'static str = "SyncdSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                18 => {
                    self.records.push(is.read_message()?);
                },
                26 => {
                    self.mac = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.mac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.records {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.mac.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdSnapshot {
        SyncdSnapshot::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.records.clear();
        self.mac = ::std::option::Option::None;
        self.keyId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdSnapshot {
        static instance: SyncdSnapshot = SyncdSnapshot {
            version: ::protobuf::MessageField::none(),
            records: ::std::vec::Vec::new(),
            mac: ::std::option::Option::None,
            keyId: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ExternalBlobReference)
pub struct ExternalBlobReference {
    // message fields
    // @@protoc_insertion_point(field:ExternalBlobReference.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ExternalBlobReference.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalBlobReference.handle)
    pub handle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalBlobReference.fileSizeBytes)
    pub fileSizeBytes: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ExternalBlobReference.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ExternalBlobReference.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ExternalBlobReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExternalBlobReference {
    fn default() -> &'a ExternalBlobReference {
        <ExternalBlobReference as ::protobuf::Message>::default_instance()
    }
}

impl ExternalBlobReference {
    pub fn new() -> ExternalBlobReference {
        ::std::default::Default::default()
    }

    // optional bytes mediaKey = 1;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 2;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string handle = 3;

    pub fn handle(&self) -> &str {
        match self.handle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        if self.handle.is_none() {
            self.handle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        self.handle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileSizeBytes = 4;

    pub fn fileSizeBytes(&self) -> u64 {
        self.fileSizeBytes.unwrap_or(0)
    }

    pub fn clear_fileSizeBytes(&mut self) {
        self.fileSizeBytes = ::std::option::Option::None;
    }

    pub fn has_fileSizeBytes(&self) -> bool {
        self.fileSizeBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSizeBytes(&mut self, v: u64) {
        self.fileSizeBytes = ::std::option::Option::Some(v);
    }

    // optional bytes fileSha256 = 5;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 6;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &ExternalBlobReference| { &m.mediaKey },
            |m: &mut ExternalBlobReference| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &ExternalBlobReference| { &m.directPath },
            |m: &mut ExternalBlobReference| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &ExternalBlobReference| { &m.handle },
            |m: &mut ExternalBlobReference| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSizeBytes",
            |m: &ExternalBlobReference| { &m.fileSizeBytes },
            |m: &mut ExternalBlobReference| { &mut m.fileSizeBytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &ExternalBlobReference| { &m.fileSha256 },
            |m: &mut ExternalBlobReference| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &ExternalBlobReference| { &m.fileEncSha256 },
            |m: &mut ExternalBlobReference| { &mut m.fileEncSha256 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalBlobReference>(
            "ExternalBlobReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExternalBlobReference {
    const NAME: &'static str = "ExternalBlobReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.handle = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.fileSizeBytes = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.handle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileSizeBytes {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.handle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fileSizeBytes {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExternalBlobReference {
        ExternalBlobReference::new()
    }

    fn clear(&mut self) {
        self.mediaKey = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.fileSizeBytes = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExternalBlobReference {
        static instance: ExternalBlobReference = ExternalBlobReference {
            mediaKey: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            fileSizeBytes: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExternalBlobReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExternalBlobReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExternalBlobReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalBlobReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdRecord)
pub struct SyncdRecord {
    // message fields
    // @@protoc_insertion_point(field:SyncdRecord.index)
    pub index: ::protobuf::MessageField<SyncdIndex>,
    // @@protoc_insertion_point(field:SyncdRecord.value)
    pub value: ::protobuf::MessageField<SyncdValue>,
    // @@protoc_insertion_point(field:SyncdRecord.keyId)
    pub keyId: ::protobuf::MessageField<KeyId>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdRecord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdRecord {
    fn default() -> &'a SyncdRecord {
        <SyncdRecord as ::protobuf::Message>::default_instance()
    }
}

impl SyncdRecord {
    pub fn new() -> SyncdRecord {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdIndex>(
            "index",
            |m: &SyncdRecord| { &m.index },
            |m: &mut SyncdRecord| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdValue>(
            "value",
            |m: &SyncdRecord| { &m.value },
            |m: &mut SyncdRecord| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyId>(
            "keyId",
            |m: &SyncdRecord| { &m.keyId },
            |m: &mut SyncdRecord| { &mut m.keyId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdRecord>(
            "SyncdRecord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdRecord {
    const NAME: &'static str = "SyncdRecord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.index)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdRecord {
        SyncdRecord::new()
    }

    fn clear(&mut self) {
        self.index.clear();
        self.value.clear();
        self.keyId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdRecord {
        static instance: SyncdRecord = SyncdRecord {
            index: ::protobuf::MessageField::none(),
            value: ::protobuf::MessageField::none(),
            keyId: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdRecord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdRecord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdRecord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:KeyId)
pub struct KeyId {
    // message fields
    // @@protoc_insertion_point(field:KeyId.id)
    pub id: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:KeyId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyId {
    fn default() -> &'a KeyId {
        <KeyId as ::protobuf::Message>::default_instance()
    }
}

impl KeyId {
    pub fn new() -> KeyId {
        ::std::default::Default::default()
    }

    // optional bytes id = 1;

    pub fn id(&self) -> &[u8] {
        match self.id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        self.id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &KeyId| { &m.id },
            |m: &mut KeyId| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyId>(
            "KeyId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyId {
    const NAME: &'static str = "KeyId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyId {
        KeyId::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyId {
        static instance: KeyId = KeyId {
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdValue)
pub struct SyncdValue {
    // message fields
    // @@protoc_insertion_point(field:SyncdValue.blob)
    pub blob: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdValue {
    fn default() -> &'a SyncdValue {
        <SyncdValue as ::protobuf::Message>::default_instance()
    }
}

impl SyncdValue {
    pub fn new() -> SyncdValue {
        ::std::default::Default::default()
    }

    // optional bytes blob = 1;

    pub fn blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_blob(&mut self) {
        self.blob = ::std::option::Option::None;
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob",
            |m: &SyncdValue| { &m.blob },
            |m: &mut SyncdValue| { &mut m.blob },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdValue>(
            "SyncdValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdValue {
    const NAME: &'static str = "SyncdValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.blob = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.blob.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdValue {
        SyncdValue::new()
    }

    fn clear(&mut self) {
        self.blob = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdValue {
        static instance: SyncdValue = SyncdValue {
            blob: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdIndex)
pub struct SyncdIndex {
    // message fields
    // @@protoc_insertion_point(field:SyncdIndex.blob)
    pub blob: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdIndex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdIndex {
    fn default() -> &'a SyncdIndex {
        <SyncdIndex as ::protobuf::Message>::default_instance()
    }
}

impl SyncdIndex {
    pub fn new() -> SyncdIndex {
        ::std::default::Default::default()
    }

    // optional bytes blob = 1;

    pub fn blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_blob(&mut self) {
        self.blob = ::std::option::Option::None;
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob",
            |m: &SyncdIndex| { &m.blob },
            |m: &mut SyncdIndex| { &mut m.blob },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdIndex>(
            "SyncdIndex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdIndex {
    const NAME: &'static str = "SyncdIndex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.blob = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.blob.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdIndex {
        SyncdIndex::new()
    }

    fn clear(&mut self) {
        self.blob = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdIndex {
        static instance: SyncdIndex = SyncdIndex {
            blob: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdIndex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdIndex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdIndex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ExitCode)
pub struct ExitCode {
    // message fields
    // @@protoc_insertion_point(field:ExitCode.code)
    pub code: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ExitCode.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ExitCode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExitCode {
    fn default() -> &'a ExitCode {
        <ExitCode as ::protobuf::Message>::default_instance()
    }
}

impl ExitCode {
    pub fn new() -> ExitCode {
        ::std::default::Default::default()
    }

    // optional uint64 code = 1;

    pub fn code(&self) -> u64 {
        self.code.unwrap_or(0)
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u64) {
        self.code = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &ExitCode| { &m.code },
            |m: &mut ExitCode| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &ExitCode| { &m.text },
            |m: &mut ExitCode| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExitCode>(
            "ExitCode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExitCode {
    const NAME: &'static str = "ExitCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExitCode {
        ExitCode::new()
    }

    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExitCode {
        static instance: ExitCode = ExitCode {
            code: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExitCode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExitCode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExitCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitCode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SyncdVersion)
pub struct SyncdVersion {
    // message fields
    // @@protoc_insertion_point(field:SyncdVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SyncdVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdVersion {
    fn default() -> &'a SyncdVersion {
        <SyncdVersion as ::protobuf::Message>::default_instance()
    }
}

impl SyncdVersion {
    pub fn new() -> SyncdVersion {
        ::std::default::Default::default()
    }

    // optional uint64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &SyncdVersion| { &m.version },
            |m: &mut SyncdVersion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdVersion>(
            "SyncdVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdVersion {
    const NAME: &'static str = "SyncdVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdVersion {
        SyncdVersion::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdVersion {
        static instance: SyncdVersion = SyncdVersion {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ServerErrorReceipt)
pub struct ServerErrorReceipt {
    // message fields
    // @@protoc_insertion_point(field:ServerErrorReceipt.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ServerErrorReceipt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerErrorReceipt {
    fn default() -> &'a ServerErrorReceipt {
        <ServerErrorReceipt as ::protobuf::Message>::default_instance()
    }
}

impl ServerErrorReceipt {
    pub fn new() -> ServerErrorReceipt {
        ::std::default::Default::default()
    }

    // optional string stanzaId = 1;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &ServerErrorReceipt| { &m.stanzaId },
            |m: &mut ServerErrorReceipt| { &mut m.stanzaId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerErrorReceipt>(
            "ServerErrorReceipt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerErrorReceipt {
    const NAME: &'static str = "ServerErrorReceipt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerErrorReceipt {
        ServerErrorReceipt::new()
    }

    fn clear(&mut self) {
        self.stanzaId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerErrorReceipt {
        static instance: ServerErrorReceipt = ServerErrorReceipt {
            stanzaId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerErrorReceipt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerErrorReceipt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerErrorReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerErrorReceipt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MediaRetryNotification)
pub struct MediaRetryNotification {
    // message fields
    // @@protoc_insertion_point(field:MediaRetryNotification.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaRetryNotification.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MediaRetryNotification.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<media_retry_notification::MediaRetryNotificationResultType>>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaRetryNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaRetryNotification {
    fn default() -> &'a MediaRetryNotification {
        <MediaRetryNotification as ::protobuf::Message>::default_instance()
    }
}

impl MediaRetryNotification {
    pub fn new() -> MediaRetryNotification {
        ::std::default::Default::default()
    }

    // optional string stanzaId = 1;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string directPath = 2;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .MediaRetryNotification.MediaRetryNotificationResultType result = 3;

    pub fn result(&self) -> media_retry_notification::MediaRetryNotificationResultType {
        match self.result {
            Some(e) => e.enum_value_or(media_retry_notification::MediaRetryNotificationResultType::GENERAL_ERROR),
            None => media_retry_notification::MediaRetryNotificationResultType::GENERAL_ERROR,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: media_retry_notification::MediaRetryNotificationResultType) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &MediaRetryNotification| { &m.stanzaId },
            |m: &mut MediaRetryNotification| { &mut m.stanzaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &MediaRetryNotification| { &m.directPath },
            |m: &mut MediaRetryNotification| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &MediaRetryNotification| { &m.result },
            |m: &mut MediaRetryNotification| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaRetryNotification>(
            "MediaRetryNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaRetryNotification {
    const NAME: &'static str = "MediaRetryNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaRetryNotification {
        MediaRetryNotification::new()
    }

    fn clear(&mut self) {
        self.stanzaId = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaRetryNotification {
        static instance: MediaRetryNotification = MediaRetryNotification {
            stanzaId: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaRetryNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaRetryNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaRetryNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaRetryNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MediaRetryNotification`
pub mod media_retry_notification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MediaRetryNotification.MediaRetryNotificationResultType)
    pub enum MediaRetryNotificationResultType {
        // @@protoc_insertion_point(enum_value:MediaRetryNotification.MediaRetryNotificationResultType.GENERAL_ERROR)
        GENERAL_ERROR = 0,
        // @@protoc_insertion_point(enum_value:MediaRetryNotification.MediaRetryNotificationResultType.SUCCESS)
        SUCCESS = 1,
        // @@protoc_insertion_point(enum_value:MediaRetryNotification.MediaRetryNotificationResultType.NOT_FOUND)
        NOT_FOUND = 2,
        // @@protoc_insertion_point(enum_value:MediaRetryNotification.MediaRetryNotificationResultType.DECRYPTION_ERROR)
        DECRYPTION_ERROR = 3,
    }

    impl ::protobuf::Enum for MediaRetryNotificationResultType {
        const NAME: &'static str = "MediaRetryNotificationResultType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MediaRetryNotificationResultType> {
            match value {
                0 => ::std::option::Option::Some(MediaRetryNotificationResultType::GENERAL_ERROR),
                1 => ::std::option::Option::Some(MediaRetryNotificationResultType::SUCCESS),
                2 => ::std::option::Option::Some(MediaRetryNotificationResultType::NOT_FOUND),
                3 => ::std::option::Option::Some(MediaRetryNotificationResultType::DECRYPTION_ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MediaRetryNotificationResultType] = &[
            MediaRetryNotificationResultType::GENERAL_ERROR,
            MediaRetryNotificationResultType::SUCCESS,
            MediaRetryNotificationResultType::NOT_FOUND,
            MediaRetryNotificationResultType::DECRYPTION_ERROR,
        ];
    }

    impl ::protobuf::EnumFull for MediaRetryNotificationResultType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MediaRetryNotification.MediaRetryNotificationResultType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MediaRetryNotificationResultType {
        fn default() -> Self {
            MediaRetryNotificationResultType::GENERAL_ERROR
        }
    }

    impl MediaRetryNotificationResultType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaRetryNotificationResultType>("MediaRetryNotification.MediaRetryNotificationResultType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MsgOpaqueData)
pub struct MsgOpaqueData {
    // message fields
    // @@protoc_insertion_point(field:MsgOpaqueData.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.lng)
    pub lng: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:MsgOpaqueData.lat)
    pub lat: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:MsgOpaqueData.paymentAmount1000)
    pub paymentAmount1000: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MsgOpaqueData.paymentNoteMsgBody)
    pub paymentNoteMsgBody: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.canonicalUrl)
    pub canonicalUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.matchedText)
    pub matchedText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.futureproofBuffer)
    pub futureproofBuffer: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MsgOpaqueData.clientUrl)
    pub clientUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MsgOpaqueData.loc)
    pub loc: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MsgOpaqueData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgOpaqueData {
    fn default() -> &'a MsgOpaqueData {
        <MsgOpaqueData as ::protobuf::Message>::default_instance()
    }
}

impl MsgOpaqueData {
    pub fn new() -> MsgOpaqueData {
        ::std::default::Default::default()
    }

    // optional string body = 1;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double lng = 5;

    pub fn lng(&self) -> f64 {
        self.lng.unwrap_or(0.)
    }

    pub fn clear_lng(&mut self) {
        self.lng = ::std::option::Option::None;
    }

    pub fn has_lng(&self) -> bool {
        self.lng.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lng(&mut self, v: f64) {
        self.lng = ::std::option::Option::Some(v);
    }

    // optional double lat = 7;

    pub fn lat(&self) -> f64 {
        self.lat.unwrap_or(0.)
    }

    pub fn clear_lat(&mut self) {
        self.lat = ::std::option::Option::None;
    }

    pub fn has_lat(&self) -> bool {
        self.lat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: f64) {
        self.lat = ::std::option::Option::Some(v);
    }

    // optional int32 paymentAmount1000 = 8;

    pub fn paymentAmount1000(&self) -> i32 {
        self.paymentAmount1000.unwrap_or(0)
    }

    pub fn clear_paymentAmount1000(&mut self) {
        self.paymentAmount1000 = ::std::option::Option::None;
    }

    pub fn has_paymentAmount1000(&self) -> bool {
        self.paymentAmount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paymentAmount1000(&mut self, v: i32) {
        self.paymentAmount1000 = ::std::option::Option::Some(v);
    }

    // optional string paymentNoteMsgBody = 9;

    pub fn paymentNoteMsgBody(&self) -> &str {
        match self.paymentNoteMsgBody.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_paymentNoteMsgBody(&mut self) {
        self.paymentNoteMsgBody = ::std::option::Option::None;
    }

    pub fn has_paymentNoteMsgBody(&self) -> bool {
        self.paymentNoteMsgBody.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paymentNoteMsgBody(&mut self, v: ::std::string::String) {
        self.paymentNoteMsgBody = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paymentNoteMsgBody(&mut self) -> &mut ::std::string::String {
        if self.paymentNoteMsgBody.is_none() {
            self.paymentNoteMsgBody = ::std::option::Option::Some(::std::string::String::new());
        }
        self.paymentNoteMsgBody.as_mut().unwrap()
    }

    // Take field
    pub fn take_paymentNoteMsgBody(&mut self) -> ::std::string::String {
        self.paymentNoteMsgBody.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string canonicalUrl = 10;

    pub fn canonicalUrl(&self) -> &str {
        match self.canonicalUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_canonicalUrl(&mut self) {
        self.canonicalUrl = ::std::option::Option::None;
    }

    pub fn has_canonicalUrl(&self) -> bool {
        self.canonicalUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonicalUrl(&mut self, v: ::std::string::String) {
        self.canonicalUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonicalUrl(&mut self) -> &mut ::std::string::String {
        if self.canonicalUrl.is_none() {
            self.canonicalUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.canonicalUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonicalUrl(&mut self) -> ::std::string::String {
        self.canonicalUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchedText = 11;

    pub fn matchedText(&self) -> &str {
        match self.matchedText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchedText(&mut self) {
        self.matchedText = ::std::option::Option::None;
    }

    pub fn has_matchedText(&self) -> bool {
        self.matchedText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchedText(&mut self, v: ::std::string::String) {
        self.matchedText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchedText(&mut self) -> &mut ::std::string::String {
        if self.matchedText.is_none() {
            self.matchedText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchedText.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchedText(&mut self) -> ::std::string::String {
        self.matchedText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 12;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 13;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes futureproofBuffer = 14;

    pub fn futureproofBuffer(&self) -> &[u8] {
        match self.futureproofBuffer.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_futureproofBuffer(&mut self) {
        self.futureproofBuffer = ::std::option::Option::None;
    }

    pub fn has_futureproofBuffer(&self) -> bool {
        self.futureproofBuffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_futureproofBuffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.futureproofBuffer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_futureproofBuffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.futureproofBuffer.is_none() {
            self.futureproofBuffer = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.futureproofBuffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_futureproofBuffer(&mut self) -> ::std::vec::Vec<u8> {
        self.futureproofBuffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string clientUrl = 15;

    pub fn clientUrl(&self) -> &str {
        match self.clientUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clientUrl(&mut self) {
        self.clientUrl = ::std::option::Option::None;
    }

    pub fn has_clientUrl(&self) -> bool {
        self.clientUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientUrl(&mut self, v: ::std::string::String) {
        self.clientUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientUrl(&mut self) -> &mut ::std::string::String {
        if self.clientUrl.is_none() {
            self.clientUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clientUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientUrl(&mut self) -> ::std::string::String {
        self.clientUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string loc = 16;

    pub fn loc(&self) -> &str {
        match self.loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc(&mut self) {
        self.loc = ::std::option::Option::None;
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: ::std::string::String) {
        self.loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut ::std::string::String {
        if self.loc.is_none() {
            self.loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> ::std::string::String {
        self.loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &MsgOpaqueData| { &m.body },
            |m: &mut MsgOpaqueData| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &MsgOpaqueData| { &m.caption },
            |m: &mut MsgOpaqueData| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lng",
            |m: &MsgOpaqueData| { &m.lng },
            |m: &mut MsgOpaqueData| { &mut m.lng },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lat",
            |m: &MsgOpaqueData| { &m.lat },
            |m: &mut MsgOpaqueData| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paymentAmount1000",
            |m: &MsgOpaqueData| { &m.paymentAmount1000 },
            |m: &mut MsgOpaqueData| { &mut m.paymentAmount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paymentNoteMsgBody",
            |m: &MsgOpaqueData| { &m.paymentNoteMsgBody },
            |m: &mut MsgOpaqueData| { &mut m.paymentNoteMsgBody },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "canonicalUrl",
            |m: &MsgOpaqueData| { &m.canonicalUrl },
            |m: &mut MsgOpaqueData| { &mut m.canonicalUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchedText",
            |m: &MsgOpaqueData| { &m.matchedText },
            |m: &mut MsgOpaqueData| { &mut m.matchedText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &MsgOpaqueData| { &m.title },
            |m: &mut MsgOpaqueData| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &MsgOpaqueData| { &m.description },
            |m: &mut MsgOpaqueData| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "futureproofBuffer",
            |m: &MsgOpaqueData| { &m.futureproofBuffer },
            |m: &mut MsgOpaqueData| { &mut m.futureproofBuffer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientUrl",
            |m: &MsgOpaqueData| { &m.clientUrl },
            |m: &mut MsgOpaqueData| { &mut m.clientUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loc",
            |m: &MsgOpaqueData| { &m.loc },
            |m: &mut MsgOpaqueData| { &mut m.loc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgOpaqueData>(
            "MsgOpaqueData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgOpaqueData {
    const NAME: &'static str = "MsgOpaqueData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                41 => {
                    self.lng = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.lat = ::std::option::Option::Some(is.read_double()?);
                },
                64 => {
                    self.paymentAmount1000 = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.paymentNoteMsgBody = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.canonicalUrl = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.matchedText = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.futureproofBuffer = ::std::option::Option::Some(is.read_bytes()?);
                },
                122 => {
                    self.clientUrl = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.loc = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.lng {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.paymentAmount1000 {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.paymentNoteMsgBody.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.matchedText.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.futureproofBuffer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.clientUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.loc.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.body.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.lng {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.lat {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.paymentAmount1000 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.paymentNoteMsgBody.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.matchedText.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.futureproofBuffer.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.clientUrl.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.loc.as_ref() {
            os.write_string(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgOpaqueData {
        MsgOpaqueData::new()
    }

    fn clear(&mut self) {
        self.body = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.lng = ::std::option::Option::None;
        self.lat = ::std::option::Option::None;
        self.paymentAmount1000 = ::std::option::Option::None;
        self.paymentNoteMsgBody = ::std::option::Option::None;
        self.canonicalUrl = ::std::option::Option::None;
        self.matchedText = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.futureproofBuffer = ::std::option::Option::None;
        self.clientUrl = ::std::option::Option::None;
        self.loc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgOpaqueData {
        static instance: MsgOpaqueData = MsgOpaqueData {
            body: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            lng: ::std::option::Option::None,
            lat: ::std::option::Option::None,
            paymentAmount1000: ::std::option::Option::None,
            paymentNoteMsgBody: ::std::option::Option::None,
            canonicalUrl: ::std::option::Option::None,
            matchedText: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            futureproofBuffer: ::std::option::Option::None,
            clientUrl: ::std::option::Option::None,
            loc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgOpaqueData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgOpaqueData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgOpaqueData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgOpaqueData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MsgRowOpaqueData)
pub struct MsgRowOpaqueData {
    // message fields
    // @@protoc_insertion_point(field:MsgRowOpaqueData.currentMsg)
    pub currentMsg: ::protobuf::MessageField<MsgOpaqueData>,
    // @@protoc_insertion_point(field:MsgRowOpaqueData.quotedMsg)
    pub quotedMsg: ::protobuf::MessageField<MsgOpaqueData>,
    // special fields
    // @@protoc_insertion_point(special_field:MsgRowOpaqueData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgRowOpaqueData {
    fn default() -> &'a MsgRowOpaqueData {
        <MsgRowOpaqueData as ::protobuf::Message>::default_instance()
    }
}

impl MsgRowOpaqueData {
    pub fn new() -> MsgRowOpaqueData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MsgOpaqueData>(
            "currentMsg",
            |m: &MsgRowOpaqueData| { &m.currentMsg },
            |m: &mut MsgRowOpaqueData| { &mut m.currentMsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MsgOpaqueData>(
            "quotedMsg",
            |m: &MsgRowOpaqueData| { &m.quotedMsg },
            |m: &mut MsgRowOpaqueData| { &mut m.quotedMsg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgRowOpaqueData>(
            "MsgRowOpaqueData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgRowOpaqueData {
    const NAME: &'static str = "MsgRowOpaqueData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.currentMsg)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedMsg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currentMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quotedMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currentMsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quotedMsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgRowOpaqueData {
        MsgRowOpaqueData::new()
    }

    fn clear(&mut self) {
        self.currentMsg.clear();
        self.quotedMsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgRowOpaqueData {
        static instance: MsgRowOpaqueData = MsgRowOpaqueData {
            currentMsg: ::protobuf::MessageField::none(),
            quotedMsg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgRowOpaqueData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgRowOpaqueData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgRowOpaqueData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRowOpaqueData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GlobalSettings)
pub struct GlobalSettings {
    // message fields
    // @@protoc_insertion_point(field:GlobalSettings.lightThemeWallpaper)
    pub lightThemeWallpaper: ::protobuf::MessageField<WallpaperSettings>,
    // @@protoc_insertion_point(field:GlobalSettings.mediaVisibility)
    pub mediaVisibility: ::std::option::Option<::protobuf::EnumOrUnknown<MediaVisibility>>,
    // @@protoc_insertion_point(field:GlobalSettings.darkThemeWallpaper)
    pub darkThemeWallpaper: ::protobuf::MessageField<WallpaperSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:GlobalSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlobalSettings {
    fn default() -> &'a GlobalSettings {
        <GlobalSettings as ::protobuf::Message>::default_instance()
    }
}

impl GlobalSettings {
    pub fn new() -> GlobalSettings {
        ::std::default::Default::default()
    }

    // optional .MediaVisibility mediaVisibility = 2;

    pub fn mediaVisibility(&self) -> MediaVisibility {
        match self.mediaVisibility {
            Some(e) => e.enum_value_or(MediaVisibility::DEFAULT),
            None => MediaVisibility::DEFAULT,
        }
    }

    pub fn clear_mediaVisibility(&mut self) {
        self.mediaVisibility = ::std::option::Option::None;
    }

    pub fn has_mediaVisibility(&self) -> bool {
        self.mediaVisibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaVisibility(&mut self, v: MediaVisibility) {
        self.mediaVisibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WallpaperSettings>(
            "lightThemeWallpaper",
            |m: &GlobalSettings| { &m.lightThemeWallpaper },
            |m: &mut GlobalSettings| { &mut m.lightThemeWallpaper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaVisibility",
            |m: &GlobalSettings| { &m.mediaVisibility },
            |m: &mut GlobalSettings| { &mut m.mediaVisibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WallpaperSettings>(
            "darkThemeWallpaper",
            |m: &GlobalSettings| { &m.darkThemeWallpaper },
            |m: &mut GlobalSettings| { &mut m.darkThemeWallpaper },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlobalSettings>(
            "GlobalSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlobalSettings {
    const NAME: &'static str = "GlobalSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lightThemeWallpaper)?;
                },
                16 => {
                    self.mediaVisibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.darkThemeWallpaper)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lightThemeWallpaper.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mediaVisibility {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.darkThemeWallpaper.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lightThemeWallpaper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.mediaVisibility {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.darkThemeWallpaper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlobalSettings {
        GlobalSettings::new()
    }

    fn clear(&mut self) {
        self.lightThemeWallpaper.clear();
        self.mediaVisibility = ::std::option::Option::None;
        self.darkThemeWallpaper.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlobalSettings {
        static instance: GlobalSettings = GlobalSettings {
            lightThemeWallpaper: ::protobuf::MessageField::none(),
            mediaVisibility: ::std::option::Option::None,
            darkThemeWallpaper: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlobalSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlobalSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlobalSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WallpaperSettings)
pub struct WallpaperSettings {
    // message fields
    // @@protoc_insertion_point(field:WallpaperSettings.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WallpaperSettings.opacity)
    pub opacity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:WallpaperSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WallpaperSettings {
    fn default() -> &'a WallpaperSettings {
        <WallpaperSettings as ::protobuf::Message>::default_instance()
    }
}

impl WallpaperSettings {
    pub fn new() -> WallpaperSettings {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 opacity = 2;

    pub fn opacity(&self) -> u32 {
        self.opacity.unwrap_or(0)
    }

    pub fn clear_opacity(&mut self) {
        self.opacity = ::std::option::Option::None;
    }

    pub fn has_opacity(&self) -> bool {
        self.opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity(&mut self, v: u32) {
        self.opacity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &WallpaperSettings| { &m.filename },
            |m: &mut WallpaperSettings| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity",
            |m: &WallpaperSettings| { &m.opacity },
            |m: &mut WallpaperSettings| { &mut m.opacity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WallpaperSettings>(
            "WallpaperSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WallpaperSettings {
    const NAME: &'static str = "WallpaperSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.opacity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.opacity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.opacity {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WallpaperSettings {
        WallpaperSettings::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.opacity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WallpaperSettings {
        static instance: WallpaperSettings = WallpaperSettings {
            filename: ::std::option::Option::None,
            opacity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WallpaperSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WallpaperSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WallpaperSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WallpaperSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GroupParticipant)
pub struct GroupParticipant {
    // message fields
    // @@protoc_insertion_point(field:GroupParticipant.userJid)
    pub userJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GroupParticipant.rank)
    pub rank: ::std::option::Option<::protobuf::EnumOrUnknown<group_participant::GroupParticipantRank>>,
    // special fields
    // @@protoc_insertion_point(special_field:GroupParticipant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupParticipant {
    fn default() -> &'a GroupParticipant {
        <GroupParticipant as ::protobuf::Message>::default_instance()
    }
}

impl GroupParticipant {
    pub fn new() -> GroupParticipant {
        ::std::default::Default::default()
    }

    // required string userJid = 1;

    pub fn userJid(&self) -> &str {
        match self.userJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_userJid(&mut self) {
        self.userJid = ::std::option::Option::None;
    }

    pub fn has_userJid(&self) -> bool {
        self.userJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userJid(&mut self, v: ::std::string::String) {
        self.userJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userJid(&mut self) -> &mut ::std::string::String {
        if self.userJid.is_none() {
            self.userJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.userJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_userJid(&mut self) -> ::std::string::String {
        self.userJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .GroupParticipant.GroupParticipantRank rank = 2;

    pub fn rank(&self) -> group_participant::GroupParticipantRank {
        match self.rank {
            Some(e) => e.enum_value_or(group_participant::GroupParticipantRank::REGULAR),
            None => group_participant::GroupParticipantRank::REGULAR,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: group_participant::GroupParticipantRank) {
        self.rank = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userJid",
            |m: &GroupParticipant| { &m.userJid },
            |m: &mut GroupParticipant| { &mut m.userJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &GroupParticipant| { &m.rank },
            |m: &mut GroupParticipant| { &mut m.rank },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupParticipant>(
            "GroupParticipant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupParticipant {
    const NAME: &'static str = "GroupParticipant";

    fn is_initialized(&self) -> bool {
        if self.userJid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.userJid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.userJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.userJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rank {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupParticipant {
        GroupParticipant::new()
    }

    fn clear(&mut self) {
        self.userJid = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupParticipant {
        static instance: GroupParticipant = GroupParticipant {
            userJid: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupParticipant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupParticipant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupParticipant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupParticipant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GroupParticipant`
pub mod group_participant {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:GroupParticipant.GroupParticipantRank)
    pub enum GroupParticipantRank {
        // @@protoc_insertion_point(enum_value:GroupParticipant.GroupParticipantRank.REGULAR)
        REGULAR = 0,
        // @@protoc_insertion_point(enum_value:GroupParticipant.GroupParticipantRank.ADMIN)
        ADMIN = 1,
        // @@protoc_insertion_point(enum_value:GroupParticipant.GroupParticipantRank.SUPERADMIN)
        SUPERADMIN = 2,
    }

    impl ::protobuf::Enum for GroupParticipantRank {
        const NAME: &'static str = "GroupParticipantRank";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GroupParticipantRank> {
            match value {
                0 => ::std::option::Option::Some(GroupParticipantRank::REGULAR),
                1 => ::std::option::Option::Some(GroupParticipantRank::ADMIN),
                2 => ::std::option::Option::Some(GroupParticipantRank::SUPERADMIN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [GroupParticipantRank] = &[
            GroupParticipantRank::REGULAR,
            GroupParticipantRank::ADMIN,
            GroupParticipantRank::SUPERADMIN,
        ];
    }

    impl ::protobuf::EnumFull for GroupParticipantRank {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GroupParticipant.GroupParticipantRank").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for GroupParticipantRank {
        fn default() -> Self {
            GroupParticipantRank::REGULAR
        }
    }

    impl GroupParticipantRank {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GroupParticipantRank>("GroupParticipant.GroupParticipantRank")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Pushname)
pub struct Pushname {
    // message fields
    // @@protoc_insertion_point(field:Pushname.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Pushname.pushname)
    pub pushname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Pushname.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pushname {
    fn default() -> &'a Pushname {
        <Pushname as ::protobuf::Message>::default_instance()
    }
}

impl Pushname {
    pub fn new() -> Pushname {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pushname = 2;

    pub fn pushname(&self) -> &str {
        match self.pushname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pushname(&mut self) {
        self.pushname = ::std::option::Option::None;
    }

    pub fn has_pushname(&self) -> bool {
        self.pushname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pushname(&mut self, v: ::std::string::String) {
        self.pushname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pushname(&mut self) -> &mut ::std::string::String {
        if self.pushname.is_none() {
            self.pushname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pushname.as_mut().unwrap()
    }

    // Take field
    pub fn take_pushname(&mut self) -> ::std::string::String {
        self.pushname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Pushname| { &m.id },
            |m: &mut Pushname| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pushname",
            |m: &Pushname| { &m.pushname },
            |m: &mut Pushname| { &mut m.pushname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pushname>(
            "Pushname",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pushname {
    const NAME: &'static str = "Pushname";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.pushname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pushname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pushname.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pushname {
        Pushname::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.pushname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pushname {
        static instance: Pushname = Pushname {
            id: ::std::option::Option::None,
            pushname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pushname {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pushname").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pushname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pushname {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HistorySyncMsg)
pub struct HistorySyncMsg {
    // message fields
    // @@protoc_insertion_point(field:HistorySyncMsg.message)
    pub message: ::protobuf::MessageField<WebMessageInfo>,
    // @@protoc_insertion_point(field:HistorySyncMsg.msgOrderId)
    pub msgOrderId: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:HistorySyncMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistorySyncMsg {
    fn default() -> &'a HistorySyncMsg {
        <HistorySyncMsg as ::protobuf::Message>::default_instance()
    }
}

impl HistorySyncMsg {
    pub fn new() -> HistorySyncMsg {
        ::std::default::Default::default()
    }

    // optional uint64 msgOrderId = 2;

    pub fn msgOrderId(&self) -> u64 {
        self.msgOrderId.unwrap_or(0)
    }

    pub fn clear_msgOrderId(&mut self) {
        self.msgOrderId = ::std::option::Option::None;
    }

    pub fn has_msgOrderId(&self) -> bool {
        self.msgOrderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgOrderId(&mut self, v: u64) {
        self.msgOrderId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebMessageInfo>(
            "message",
            |m: &HistorySyncMsg| { &m.message },
            |m: &mut HistorySyncMsg| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgOrderId",
            |m: &HistorySyncMsg| { &m.msgOrderId },
            |m: &mut HistorySyncMsg| { &mut m.msgOrderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistorySyncMsg>(
            "HistorySyncMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistorySyncMsg {
    const NAME: &'static str = "HistorySyncMsg";

    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                16 => {
                    self.msgOrderId = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.msgOrderId {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.msgOrderId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistorySyncMsg {
        HistorySyncMsg::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.msgOrderId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistorySyncMsg {
        static instance: HistorySyncMsg = HistorySyncMsg {
            message: ::protobuf::MessageField::none(),
            msgOrderId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistorySyncMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistorySyncMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistorySyncMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistorySyncMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Conversation)
pub struct Conversation {
    // message fields
    // @@protoc_insertion_point(field:Conversation.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Conversation.messages)
    pub messages: ::std::vec::Vec<HistorySyncMsg>,
    // @@protoc_insertion_point(field:Conversation.newJid)
    pub newJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Conversation.oldJid)
    pub oldJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Conversation.lastMsgTimestamp)
    pub lastMsgTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:Conversation.unreadCount)
    pub unreadCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Conversation.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:Conversation.endOfHistoryTransfer)
    pub endOfHistoryTransfer: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:Conversation.ephemeralExpiration)
    pub ephemeralExpiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Conversation.ephemeralSettingTimestamp)
    pub ephemeralSettingTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:Conversation.endOfHistoryTransferType)
    pub endOfHistoryTransferType: ::std::option::Option<::protobuf::EnumOrUnknown<conversation::ConversationEndOfHistoryTransferType>>,
    // @@protoc_insertion_point(field:Conversation.conversationTimestamp)
    pub conversationTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:Conversation.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Conversation.pHash)
    pub pHash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Conversation.notSpam)
    pub notSpam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:Conversation.archived)
    pub archived: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:Conversation.disappearingMode)
    pub disappearingMode: ::protobuf::MessageField<DisappearingMode>,
    // @@protoc_insertion_point(field:Conversation.unreadMentionCount)
    pub unreadMentionCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Conversation.markedAsUnread)
    pub markedAsUnread: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:Conversation.participant)
    pub participant: ::std::vec::Vec<GroupParticipant>,
    // @@protoc_insertion_point(field:Conversation.tcToken)
    pub tcToken: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:Conversation.tcTokenTimestamp)
    pub tcTokenTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:Conversation.contactPrimaryIdentityKey)
    pub contactPrimaryIdentityKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:Conversation.pinned)
    pub pinned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Conversation.muteEndTime)
    pub muteEndTime: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:Conversation.wallpaper)
    pub wallpaper: ::protobuf::MessageField<WallpaperSettings>,
    // @@protoc_insertion_point(field:Conversation.mediaVisibility)
    pub mediaVisibility: ::std::option::Option<::protobuf::EnumOrUnknown<MediaVisibility>>,
    // @@protoc_insertion_point(field:Conversation.tcTokenSenderTimestamp)
    pub tcTokenSenderTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:Conversation.suspended)
    pub suspended: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:Conversation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Conversation {
    fn default() -> &'a Conversation {
        <Conversation as ::protobuf::Message>::default_instance()
    }
}

impl Conversation {
    pub fn new() -> Conversation {
        ::std::default::Default::default()
    }

    // required string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string newJid = 3;

    pub fn newJid(&self) -> &str {
        match self.newJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_newJid(&mut self) {
        self.newJid = ::std::option::Option::None;
    }

    pub fn has_newJid(&self) -> bool {
        self.newJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newJid(&mut self, v: ::std::string::String) {
        self.newJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newJid(&mut self) -> &mut ::std::string::String {
        if self.newJid.is_none() {
            self.newJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.newJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_newJid(&mut self) -> ::std::string::String {
        self.newJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string oldJid = 4;

    pub fn oldJid(&self) -> &str {
        match self.oldJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_oldJid(&mut self) {
        self.oldJid = ::std::option::Option::None;
    }

    pub fn has_oldJid(&self) -> bool {
        self.oldJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldJid(&mut self, v: ::std::string::String) {
        self.oldJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldJid(&mut self) -> &mut ::std::string::String {
        if self.oldJid.is_none() {
            self.oldJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.oldJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldJid(&mut self) -> ::std::string::String {
        self.oldJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 lastMsgTimestamp = 5;

    pub fn lastMsgTimestamp(&self) -> u64 {
        self.lastMsgTimestamp.unwrap_or(0)
    }

    pub fn clear_lastMsgTimestamp(&mut self) {
        self.lastMsgTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastMsgTimestamp(&self) -> bool {
        self.lastMsgTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastMsgTimestamp(&mut self, v: u64) {
        self.lastMsgTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 unreadCount = 6;

    pub fn unreadCount(&self) -> u32 {
        self.unreadCount.unwrap_or(0)
    }

    pub fn clear_unreadCount(&mut self) {
        self.unreadCount = ::std::option::Option::None;
    }

    pub fn has_unreadCount(&self) -> bool {
        self.unreadCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreadCount(&mut self, v: u32) {
        self.unreadCount = ::std::option::Option::Some(v);
    }

    // optional bool readOnly = 7;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional bool endOfHistoryTransfer = 8;

    pub fn endOfHistoryTransfer(&self) -> bool {
        self.endOfHistoryTransfer.unwrap_or(false)
    }

    pub fn clear_endOfHistoryTransfer(&mut self) {
        self.endOfHistoryTransfer = ::std::option::Option::None;
    }

    pub fn has_endOfHistoryTransfer(&self) -> bool {
        self.endOfHistoryTransfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endOfHistoryTransfer(&mut self, v: bool) {
        self.endOfHistoryTransfer = ::std::option::Option::Some(v);
    }

    // optional uint32 ephemeralExpiration = 9;

    pub fn ephemeralExpiration(&self) -> u32 {
        self.ephemeralExpiration.unwrap_or(0)
    }

    pub fn clear_ephemeralExpiration(&mut self) {
        self.ephemeralExpiration = ::std::option::Option::None;
    }

    pub fn has_ephemeralExpiration(&self) -> bool {
        self.ephemeralExpiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralExpiration(&mut self, v: u32) {
        self.ephemeralExpiration = ::std::option::Option::Some(v);
    }

    // optional int64 ephemeralSettingTimestamp = 10;

    pub fn ephemeralSettingTimestamp(&self) -> i64 {
        self.ephemeralSettingTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralSettingTimestamp(&mut self) {
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralSettingTimestamp(&self) -> bool {
        self.ephemeralSettingTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSettingTimestamp(&mut self, v: i64) {
        self.ephemeralSettingTimestamp = ::std::option::Option::Some(v);
    }

    // optional .Conversation.ConversationEndOfHistoryTransferType endOfHistoryTransferType = 11;

    pub fn endOfHistoryTransferType(&self) -> conversation::ConversationEndOfHistoryTransferType {
        match self.endOfHistoryTransferType {
            Some(e) => e.enum_value_or(conversation::ConversationEndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY),
            None => conversation::ConversationEndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY,
        }
    }

    pub fn clear_endOfHistoryTransferType(&mut self) {
        self.endOfHistoryTransferType = ::std::option::Option::None;
    }

    pub fn has_endOfHistoryTransferType(&self) -> bool {
        self.endOfHistoryTransferType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endOfHistoryTransferType(&mut self, v: conversation::ConversationEndOfHistoryTransferType) {
        self.endOfHistoryTransferType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 conversationTimestamp = 12;

    pub fn conversationTimestamp(&self) -> u64 {
        self.conversationTimestamp.unwrap_or(0)
    }

    pub fn clear_conversationTimestamp(&mut self) {
        self.conversationTimestamp = ::std::option::Option::None;
    }

    pub fn has_conversationTimestamp(&self) -> bool {
        self.conversationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversationTimestamp(&mut self, v: u64) {
        self.conversationTimestamp = ::std::option::Option::Some(v);
    }

    // optional string name = 13;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pHash = 14;

    pub fn pHash(&self) -> &str {
        match self.pHash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pHash(&mut self) {
        self.pHash = ::std::option::Option::None;
    }

    pub fn has_pHash(&self) -> bool {
        self.pHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pHash(&mut self, v: ::std::string::String) {
        self.pHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pHash(&mut self) -> &mut ::std::string::String {
        if self.pHash.is_none() {
            self.pHash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_pHash(&mut self) -> ::std::string::String {
        self.pHash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool notSpam = 15;

    pub fn notSpam(&self) -> bool {
        self.notSpam.unwrap_or(false)
    }

    pub fn clear_notSpam(&mut self) {
        self.notSpam = ::std::option::Option::None;
    }

    pub fn has_notSpam(&self) -> bool {
        self.notSpam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notSpam(&mut self, v: bool) {
        self.notSpam = ::std::option::Option::Some(v);
    }

    // optional bool archived = 16;

    pub fn archived(&self) -> bool {
        self.archived.unwrap_or(false)
    }

    pub fn clear_archived(&mut self) {
        self.archived = ::std::option::Option::None;
    }

    pub fn has_archived(&self) -> bool {
        self.archived.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archived(&mut self, v: bool) {
        self.archived = ::std::option::Option::Some(v);
    }

    // optional uint32 unreadMentionCount = 18;

    pub fn unreadMentionCount(&self) -> u32 {
        self.unreadMentionCount.unwrap_or(0)
    }

    pub fn clear_unreadMentionCount(&mut self) {
        self.unreadMentionCount = ::std::option::Option::None;
    }

    pub fn has_unreadMentionCount(&self) -> bool {
        self.unreadMentionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreadMentionCount(&mut self, v: u32) {
        self.unreadMentionCount = ::std::option::Option::Some(v);
    }

    // optional bool markedAsUnread = 19;

    pub fn markedAsUnread(&self) -> bool {
        self.markedAsUnread.unwrap_or(false)
    }

    pub fn clear_markedAsUnread(&mut self) {
        self.markedAsUnread = ::std::option::Option::None;
    }

    pub fn has_markedAsUnread(&self) -> bool {
        self.markedAsUnread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_markedAsUnread(&mut self, v: bool) {
        self.markedAsUnread = ::std::option::Option::Some(v);
    }

    // optional bytes tcToken = 21;

    pub fn tcToken(&self) -> &[u8] {
        match self.tcToken.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tcToken(&mut self) {
        self.tcToken = ::std::option::Option::None;
    }

    pub fn has_tcToken(&self) -> bool {
        self.tcToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcToken(&mut self, v: ::std::vec::Vec<u8>) {
        self.tcToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcToken(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tcToken.is_none() {
            self.tcToken = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tcToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcToken(&mut self) -> ::std::vec::Vec<u8> {
        self.tcToken.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 tcTokenTimestamp = 22;

    pub fn tcTokenTimestamp(&self) -> u64 {
        self.tcTokenTimestamp.unwrap_or(0)
    }

    pub fn clear_tcTokenTimestamp(&mut self) {
        self.tcTokenTimestamp = ::std::option::Option::None;
    }

    pub fn has_tcTokenTimestamp(&self) -> bool {
        self.tcTokenTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcTokenTimestamp(&mut self, v: u64) {
        self.tcTokenTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes contactPrimaryIdentityKey = 23;

    pub fn contactPrimaryIdentityKey(&self) -> &[u8] {
        match self.contactPrimaryIdentityKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_contactPrimaryIdentityKey(&mut self) {
        self.contactPrimaryIdentityKey = ::std::option::Option::None;
    }

    pub fn has_contactPrimaryIdentityKey(&self) -> bool {
        self.contactPrimaryIdentityKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contactPrimaryIdentityKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.contactPrimaryIdentityKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contactPrimaryIdentityKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.contactPrimaryIdentityKey.is_none() {
            self.contactPrimaryIdentityKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.contactPrimaryIdentityKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_contactPrimaryIdentityKey(&mut self) -> ::std::vec::Vec<u8> {
        self.contactPrimaryIdentityKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 pinned = 24;

    pub fn pinned(&self) -> u32 {
        self.pinned.unwrap_or(0)
    }

    pub fn clear_pinned(&mut self) {
        self.pinned = ::std::option::Option::None;
    }

    pub fn has_pinned(&self) -> bool {
        self.pinned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinned(&mut self, v: u32) {
        self.pinned = ::std::option::Option::Some(v);
    }

    // optional uint64 muteEndTime = 25;

    pub fn muteEndTime(&self) -> u64 {
        self.muteEndTime.unwrap_or(0)
    }

    pub fn clear_muteEndTime(&mut self) {
        self.muteEndTime = ::std::option::Option::None;
    }

    pub fn has_muteEndTime(&self) -> bool {
        self.muteEndTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muteEndTime(&mut self, v: u64) {
        self.muteEndTime = ::std::option::Option::Some(v);
    }

    // optional .MediaVisibility mediaVisibility = 27;

    pub fn mediaVisibility(&self) -> MediaVisibility {
        match self.mediaVisibility {
            Some(e) => e.enum_value_or(MediaVisibility::DEFAULT),
            None => MediaVisibility::DEFAULT,
        }
    }

    pub fn clear_mediaVisibility(&mut self) {
        self.mediaVisibility = ::std::option::Option::None;
    }

    pub fn has_mediaVisibility(&self) -> bool {
        self.mediaVisibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaVisibility(&mut self, v: MediaVisibility) {
        self.mediaVisibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 tcTokenSenderTimestamp = 28;

    pub fn tcTokenSenderTimestamp(&self) -> u64 {
        self.tcTokenSenderTimestamp.unwrap_or(0)
    }

    pub fn clear_tcTokenSenderTimestamp(&mut self) {
        self.tcTokenSenderTimestamp = ::std::option::Option::None;
    }

    pub fn has_tcTokenSenderTimestamp(&self) -> bool {
        self.tcTokenSenderTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcTokenSenderTimestamp(&mut self, v: u64) {
        self.tcTokenSenderTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool suspended = 29;

    pub fn suspended(&self) -> bool {
        self.suspended.unwrap_or(false)
    }

    pub fn clear_suspended(&mut self) {
        self.suspended = ::std::option::Option::None;
    }

    pub fn has_suspended(&self) -> bool {
        self.suspended.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspended(&mut self, v: bool) {
        self.suspended = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(29);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Conversation| { &m.id },
            |m: &mut Conversation| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &Conversation| { &m.messages },
            |m: &mut Conversation| { &mut m.messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "newJid",
            |m: &Conversation| { &m.newJid },
            |m: &mut Conversation| { &mut m.newJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oldJid",
            |m: &Conversation| { &m.oldJid },
            |m: &mut Conversation| { &mut m.oldJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastMsgTimestamp",
            |m: &Conversation| { &m.lastMsgTimestamp },
            |m: &mut Conversation| { &mut m.lastMsgTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unreadCount",
            |m: &Conversation| { &m.unreadCount },
            |m: &mut Conversation| { &mut m.unreadCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &Conversation| { &m.readOnly },
            |m: &mut Conversation| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endOfHistoryTransfer",
            |m: &Conversation| { &m.endOfHistoryTransfer },
            |m: &mut Conversation| { &mut m.endOfHistoryTransfer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralExpiration",
            |m: &Conversation| { &m.ephemeralExpiration },
            |m: &mut Conversation| { &mut m.ephemeralExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSettingTimestamp",
            |m: &Conversation| { &m.ephemeralSettingTimestamp },
            |m: &mut Conversation| { &mut m.ephemeralSettingTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endOfHistoryTransferType",
            |m: &Conversation| { &m.endOfHistoryTransferType },
            |m: &mut Conversation| { &mut m.endOfHistoryTransferType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversationTimestamp",
            |m: &Conversation| { &m.conversationTimestamp },
            |m: &mut Conversation| { &mut m.conversationTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Conversation| { &m.name },
            |m: &mut Conversation| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pHash",
            |m: &Conversation| { &m.pHash },
            |m: &mut Conversation| { &mut m.pHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notSpam",
            |m: &Conversation| { &m.notSpam },
            |m: &mut Conversation| { &mut m.notSpam },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "archived",
            |m: &Conversation| { &m.archived },
            |m: &mut Conversation| { &mut m.archived },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DisappearingMode>(
            "disappearingMode",
            |m: &Conversation| { &m.disappearingMode },
            |m: &mut Conversation| { &mut m.disappearingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unreadMentionCount",
            |m: &Conversation| { &m.unreadMentionCount },
            |m: &mut Conversation| { &mut m.unreadMentionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "markedAsUnread",
            |m: &Conversation| { &m.markedAsUnread },
            |m: &mut Conversation| { &mut m.markedAsUnread },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "participant",
            |m: &Conversation| { &m.participant },
            |m: &mut Conversation| { &mut m.participant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcToken",
            |m: &Conversation| { &m.tcToken },
            |m: &mut Conversation| { &mut m.tcToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcTokenTimestamp",
            |m: &Conversation| { &m.tcTokenTimestamp },
            |m: &mut Conversation| { &mut m.tcTokenTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contactPrimaryIdentityKey",
            |m: &Conversation| { &m.contactPrimaryIdentityKey },
            |m: &mut Conversation| { &mut m.contactPrimaryIdentityKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pinned",
            |m: &Conversation| { &m.pinned },
            |m: &mut Conversation| { &mut m.pinned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muteEndTime",
            |m: &Conversation| { &m.muteEndTime },
            |m: &mut Conversation| { &mut m.muteEndTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WallpaperSettings>(
            "wallpaper",
            |m: &Conversation| { &m.wallpaper },
            |m: &mut Conversation| { &mut m.wallpaper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaVisibility",
            |m: &Conversation| { &m.mediaVisibility },
            |m: &mut Conversation| { &mut m.mediaVisibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcTokenSenderTimestamp",
            |m: &Conversation| { &m.tcTokenSenderTimestamp },
            |m: &mut Conversation| { &mut m.tcTokenSenderTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suspended",
            |m: &Conversation| { &m.suspended },
            |m: &mut Conversation| { &mut m.suspended },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Conversation>(
            "Conversation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Conversation {
    const NAME: &'static str = "Conversation";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disappearingMode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.participant {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wallpaper {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.messages.push(is.read_message()?);
                },
                26 => {
                    self.newJid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.oldJid = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.lastMsgTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.unreadCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.endOfHistoryTransfer = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.ephemeralExpiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ephemeralSettingTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                88 => {
                    self.endOfHistoryTransferType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.conversationTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.pHash = ::std::option::Option::Some(is.read_string()?);
                },
                120 => {
                    self.notSpam = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.archived = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.disappearingMode)?;
                },
                144 => {
                    self.unreadMentionCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.markedAsUnread = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.participant.push(is.read_message()?);
                },
                170 => {
                    self.tcToken = ::std::option::Option::Some(is.read_bytes()?);
                },
                176 => {
                    self.tcTokenTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                186 => {
                    self.contactPrimaryIdentityKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                192 => {
                    self.pinned = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.muteEndTime = ::std::option::Option::Some(is.read_uint64()?);
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wallpaper)?;
                },
                216 => {
                    self.mediaVisibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                224 => {
                    self.tcTokenSenderTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                232 => {
                    self.suspended = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.newJid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.oldJid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.lastMsgTimestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.unreadCount {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.endOfHistoryTransfer {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ephemeralExpiration {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.endOfHistoryTransferType {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.conversationTimestamp {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.pHash.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.notSpam {
            my_size += 1 + 1;
        }
        if let Some(v) = self.archived {
            my_size += 2 + 1;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unreadMentionCount {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.markedAsUnread {
            my_size += 2 + 1;
        }
        for value in &self.participant {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tcToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.tcTokenTimestamp {
            my_size += ::protobuf::rt::uint64_size(22, v);
        }
        if let Some(v) = self.contactPrimaryIdentityKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(23, &v);
        }
        if let Some(v) = self.pinned {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.muteEndTime {
            my_size += ::protobuf::rt::uint64_size(25, v);
        }
        if let Some(v) = self.wallpaper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mediaVisibility {
            my_size += ::protobuf::rt::int32_size(27, v.value());
        }
        if let Some(v) = self.tcTokenSenderTimestamp {
            my_size += ::protobuf::rt::uint64_size(28, v);
        }
        if let Some(v) = self.suspended {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.newJid.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.oldJid.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.lastMsgTimestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.unreadCount {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.endOfHistoryTransfer {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.ephemeralExpiration {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.endOfHistoryTransferType {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.conversationTimestamp {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.pHash.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.notSpam {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.archived {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.unreadMentionCount {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.markedAsUnread {
            os.write_bool(19, v)?;
        }
        for v in &self.participant {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if let Some(v) = self.tcToken.as_ref() {
            os.write_bytes(21, v)?;
        }
        if let Some(v) = self.tcTokenTimestamp {
            os.write_uint64(22, v)?;
        }
        if let Some(v) = self.contactPrimaryIdentityKey.as_ref() {
            os.write_bytes(23, v)?;
        }
        if let Some(v) = self.pinned {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.muteEndTime {
            os.write_uint64(25, v)?;
        }
        if let Some(v) = self.wallpaper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.mediaVisibility {
            os.write_enum(27, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tcTokenSenderTimestamp {
            os.write_uint64(28, v)?;
        }
        if let Some(v) = self.suspended {
            os.write_bool(29, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Conversation {
        Conversation::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.messages.clear();
        self.newJid = ::std::option::Option::None;
        self.oldJid = ::std::option::Option::None;
        self.lastMsgTimestamp = ::std::option::Option::None;
        self.unreadCount = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.endOfHistoryTransfer = ::std::option::Option::None;
        self.ephemeralExpiration = ::std::option::Option::None;
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
        self.endOfHistoryTransferType = ::std::option::Option::None;
        self.conversationTimestamp = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.pHash = ::std::option::Option::None;
        self.notSpam = ::std::option::Option::None;
        self.archived = ::std::option::Option::None;
        self.disappearingMode.clear();
        self.unreadMentionCount = ::std::option::Option::None;
        self.markedAsUnread = ::std::option::Option::None;
        self.participant.clear();
        self.tcToken = ::std::option::Option::None;
        self.tcTokenTimestamp = ::std::option::Option::None;
        self.contactPrimaryIdentityKey = ::std::option::Option::None;
        self.pinned = ::std::option::Option::None;
        self.muteEndTime = ::std::option::Option::None;
        self.wallpaper.clear();
        self.mediaVisibility = ::std::option::Option::None;
        self.tcTokenSenderTimestamp = ::std::option::Option::None;
        self.suspended = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Conversation {
        static instance: Conversation = Conversation {
            id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            newJid: ::std::option::Option::None,
            oldJid: ::std::option::Option::None,
            lastMsgTimestamp: ::std::option::Option::None,
            unreadCount: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            endOfHistoryTransfer: ::std::option::Option::None,
            ephemeralExpiration: ::std::option::Option::None,
            ephemeralSettingTimestamp: ::std::option::Option::None,
            endOfHistoryTransferType: ::std::option::Option::None,
            conversationTimestamp: ::std::option::Option::None,
            name: ::std::option::Option::None,
            pHash: ::std::option::Option::None,
            notSpam: ::std::option::Option::None,
            archived: ::std::option::Option::None,
            disappearingMode: ::protobuf::MessageField::none(),
            unreadMentionCount: ::std::option::Option::None,
            markedAsUnread: ::std::option::Option::None,
            participant: ::std::vec::Vec::new(),
            tcToken: ::std::option::Option::None,
            tcTokenTimestamp: ::std::option::Option::None,
            contactPrimaryIdentityKey: ::std::option::Option::None,
            pinned: ::std::option::Option::None,
            muteEndTime: ::std::option::Option::None,
            wallpaper: ::protobuf::MessageField::none(),
            mediaVisibility: ::std::option::Option::None,
            tcTokenSenderTimestamp: ::std::option::Option::None,
            suspended: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Conversation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Conversation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Conversation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Conversation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Conversation`
pub mod conversation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Conversation.ConversationEndOfHistoryTransferType)
    pub enum ConversationEndOfHistoryTransferType {
        // @@protoc_insertion_point(enum_value:Conversation.ConversationEndOfHistoryTransferType.COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY)
        COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY = 0,
        // @@protoc_insertion_point(enum_value:Conversation.ConversationEndOfHistoryTransferType.COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY)
        COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY = 1,
    }

    impl ::protobuf::Enum for ConversationEndOfHistoryTransferType {
        const NAME: &'static str = "ConversationEndOfHistoryTransferType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConversationEndOfHistoryTransferType> {
            match value {
                0 => ::std::option::Option::Some(ConversationEndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY),
                1 => ::std::option::Option::Some(ConversationEndOfHistoryTransferType::COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConversationEndOfHistoryTransferType] = &[
            ConversationEndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY,
            ConversationEndOfHistoryTransferType::COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY,
        ];
    }

    impl ::protobuf::EnumFull for ConversationEndOfHistoryTransferType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Conversation.ConversationEndOfHistoryTransferType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ConversationEndOfHistoryTransferType {
        fn default() -> Self {
            ConversationEndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY
        }
    }

    impl ConversationEndOfHistoryTransferType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConversationEndOfHistoryTransferType>("Conversation.ConversationEndOfHistoryTransferType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HistorySync)
pub struct HistorySync {
    // message fields
    // @@protoc_insertion_point(field:HistorySync.syncType)
    pub syncType: ::std::option::Option<::protobuf::EnumOrUnknown<history_sync::HistorySyncHistorySyncType>>,
    // @@protoc_insertion_point(field:HistorySync.conversations)
    pub conversations: ::std::vec::Vec<Conversation>,
    // @@protoc_insertion_point(field:HistorySync.statusV3Messages)
    pub statusV3Messages: ::std::vec::Vec<WebMessageInfo>,
    // @@protoc_insertion_point(field:HistorySync.chunkOrder)
    pub chunkOrder: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HistorySync.progress)
    pub progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HistorySync.pushnames)
    pub pushnames: ::std::vec::Vec<Pushname>,
    // @@protoc_insertion_point(field:HistorySync.globalSettings)
    pub globalSettings: ::protobuf::MessageField<GlobalSettings>,
    // @@protoc_insertion_point(field:HistorySync.threadIdUserSecret)
    pub threadIdUserSecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:HistorySync.threadDsTimeframeOffset)
    pub threadDsTimeframeOffset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:HistorySync.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistorySync {
    fn default() -> &'a HistorySync {
        <HistorySync as ::protobuf::Message>::default_instance()
    }
}

impl HistorySync {
    pub fn new() -> HistorySync {
        ::std::default::Default::default()
    }

    // required .HistorySync.HistorySyncHistorySyncType syncType = 1;

    pub fn syncType(&self) -> history_sync::HistorySyncHistorySyncType {
        match self.syncType {
            Some(e) => e.enum_value_or(history_sync::HistorySyncHistorySyncType::INITIAL_BOOTSTRAP),
            None => history_sync::HistorySyncHistorySyncType::INITIAL_BOOTSTRAP,
        }
    }

    pub fn clear_syncType(&mut self) {
        self.syncType = ::std::option::Option::None;
    }

    pub fn has_syncType(&self) -> bool {
        self.syncType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncType(&mut self, v: history_sync::HistorySyncHistorySyncType) {
        self.syncType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 chunkOrder = 5;

    pub fn chunkOrder(&self) -> u32 {
        self.chunkOrder.unwrap_or(0)
    }

    pub fn clear_chunkOrder(&mut self) {
        self.chunkOrder = ::std::option::Option::None;
    }

    pub fn has_chunkOrder(&self) -> bool {
        self.chunkOrder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunkOrder(&mut self, v: u32) {
        self.chunkOrder = ::std::option::Option::Some(v);
    }

    // optional uint32 progress = 6;

    pub fn progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional bytes threadIdUserSecret = 9;

    pub fn threadIdUserSecret(&self) -> &[u8] {
        match self.threadIdUserSecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_threadIdUserSecret(&mut self) {
        self.threadIdUserSecret = ::std::option::Option::None;
    }

    pub fn has_threadIdUserSecret(&self) -> bool {
        self.threadIdUserSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threadIdUserSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.threadIdUserSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_threadIdUserSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.threadIdUserSecret.is_none() {
            self.threadIdUserSecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.threadIdUserSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_threadIdUserSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.threadIdUserSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 threadDsTimeframeOffset = 10;

    pub fn threadDsTimeframeOffset(&self) -> u32 {
        self.threadDsTimeframeOffset.unwrap_or(0)
    }

    pub fn clear_threadDsTimeframeOffset(&mut self) {
        self.threadDsTimeframeOffset = ::std::option::Option::None;
    }

    pub fn has_threadDsTimeframeOffset(&self) -> bool {
        self.threadDsTimeframeOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threadDsTimeframeOffset(&mut self, v: u32) {
        self.threadDsTimeframeOffset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "syncType",
            |m: &HistorySync| { &m.syncType },
            |m: &mut HistorySync| { &mut m.syncType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conversations",
            |m: &HistorySync| { &m.conversations },
            |m: &mut HistorySync| { &mut m.conversations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statusV3Messages",
            |m: &HistorySync| { &m.statusV3Messages },
            |m: &mut HistorySync| { &mut m.statusV3Messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunkOrder",
            |m: &HistorySync| { &m.chunkOrder },
            |m: &mut HistorySync| { &mut m.chunkOrder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &HistorySync| { &m.progress },
            |m: &mut HistorySync| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pushnames",
            |m: &HistorySync| { &m.pushnames },
            |m: &mut HistorySync| { &mut m.pushnames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlobalSettings>(
            "globalSettings",
            |m: &HistorySync| { &m.globalSettings },
            |m: &mut HistorySync| { &mut m.globalSettings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "threadIdUserSecret",
            |m: &HistorySync| { &m.threadIdUserSecret },
            |m: &mut HistorySync| { &mut m.threadIdUserSecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "threadDsTimeframeOffset",
            |m: &HistorySync| { &m.threadDsTimeframeOffset },
            |m: &mut HistorySync| { &mut m.threadDsTimeframeOffset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistorySync>(
            "HistorySync",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistorySync {
    const NAME: &'static str = "HistorySync";

    fn is_initialized(&self) -> bool {
        if self.syncType.is_none() {
            return false;
        }
        for v in &self.conversations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statusV3Messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pushnames {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.globalSettings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.syncType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.conversations.push(is.read_message()?);
                },
                26 => {
                    self.statusV3Messages.push(is.read_message()?);
                },
                40 => {
                    self.chunkOrder = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.pushnames.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.globalSettings)?;
                },
                74 => {
                    self.threadIdUserSecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                80 => {
                    self.threadDsTimeframeOffset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.syncType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.conversations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.statusV3Messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.chunkOrder {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.pushnames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.globalSettings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.threadIdUserSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.threadDsTimeframeOffset {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.syncType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.conversations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.statusV3Messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.chunkOrder {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(6, v)?;
        }
        for v in &self.pushnames {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.globalSettings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.threadIdUserSecret.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.threadDsTimeframeOffset {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistorySync {
        HistorySync::new()
    }

    fn clear(&mut self) {
        self.syncType = ::std::option::Option::None;
        self.conversations.clear();
        self.statusV3Messages.clear();
        self.chunkOrder = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.pushnames.clear();
        self.globalSettings.clear();
        self.threadIdUserSecret = ::std::option::Option::None;
        self.threadDsTimeframeOffset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistorySync {
        static instance: HistorySync = HistorySync {
            syncType: ::std::option::Option::None,
            conversations: ::std::vec::Vec::new(),
            statusV3Messages: ::std::vec::Vec::new(),
            chunkOrder: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            pushnames: ::std::vec::Vec::new(),
            globalSettings: ::protobuf::MessageField::none(),
            threadIdUserSecret: ::std::option::Option::None,
            threadDsTimeframeOffset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistorySync {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistorySync").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistorySync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistorySync {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HistorySync`
pub mod history_sync {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:HistorySync.HistorySyncHistorySyncType)
    pub enum HistorySyncHistorySyncType {
        // @@protoc_insertion_point(enum_value:HistorySync.HistorySyncHistorySyncType.INITIAL_BOOTSTRAP)
        INITIAL_BOOTSTRAP = 0,
        // @@protoc_insertion_point(enum_value:HistorySync.HistorySyncHistorySyncType.INITIAL_STATUS_V3)
        INITIAL_STATUS_V3 = 1,
        // @@protoc_insertion_point(enum_value:HistorySync.HistorySyncHistorySyncType.FULL)
        FULL = 2,
        // @@protoc_insertion_point(enum_value:HistorySync.HistorySyncHistorySyncType.RECENT)
        RECENT = 3,
        // @@protoc_insertion_point(enum_value:HistorySync.HistorySyncHistorySyncType.PUSH_NAME)
        PUSH_NAME = 4,
    }

    impl ::protobuf::Enum for HistorySyncHistorySyncType {
        const NAME: &'static str = "HistorySyncHistorySyncType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HistorySyncHistorySyncType> {
            match value {
                0 => ::std::option::Option::Some(HistorySyncHistorySyncType::INITIAL_BOOTSTRAP),
                1 => ::std::option::Option::Some(HistorySyncHistorySyncType::INITIAL_STATUS_V3),
                2 => ::std::option::Option::Some(HistorySyncHistorySyncType::FULL),
                3 => ::std::option::Option::Some(HistorySyncHistorySyncType::RECENT),
                4 => ::std::option::Option::Some(HistorySyncHistorySyncType::PUSH_NAME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HistorySyncHistorySyncType] = &[
            HistorySyncHistorySyncType::INITIAL_BOOTSTRAP,
            HistorySyncHistorySyncType::INITIAL_STATUS_V3,
            HistorySyncHistorySyncType::FULL,
            HistorySyncHistorySyncType::RECENT,
            HistorySyncHistorySyncType::PUSH_NAME,
        ];
    }

    impl ::protobuf::EnumFull for HistorySyncHistorySyncType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HistorySync.HistorySyncHistorySyncType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for HistorySyncHistorySyncType {
        fn default() -> Self {
            HistorySyncHistorySyncType::INITIAL_BOOTSTRAP
        }
    }

    impl HistorySyncHistorySyncType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HistorySyncHistorySyncType>("HistorySync.HistorySyncHistorySyncType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:EphemeralSetting)
pub struct EphemeralSetting {
    // message fields
    // @@protoc_insertion_point(field:EphemeralSetting.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:EphemeralSetting.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:EphemeralSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EphemeralSetting {
    fn default() -> &'a EphemeralSetting {
        <EphemeralSetting as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralSetting {
    pub fn new() -> EphemeralSetting {
        ::std::default::Default::default()
    }

    // optional sfixed32 duration = 1;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional sfixed64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &EphemeralSetting| { &m.duration },
            |m: &mut EphemeralSetting| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &EphemeralSetting| { &m.timestamp },
            |m: &mut EphemeralSetting| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EphemeralSetting>(
            "EphemeralSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EphemeralSetting {
    const NAME: &'static str = "EphemeralSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.duration = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                17 => {
                    self.timestamp = ::std::option::Option::Some(is.read_sfixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_sfixed32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_sfixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EphemeralSetting {
        EphemeralSetting::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EphemeralSetting {
        static instance: EphemeralSetting = EphemeralSetting {
            duration: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EphemeralSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EphemeralSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EphemeralSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:InteractiveAnnotation)
pub struct InteractiveAnnotation {
    // message fields
    // @@protoc_insertion_point(field:InteractiveAnnotation.polygonVertices)
    pub polygonVertices: ::std::vec::Vec<Point>,
    // message oneof groups
    pub action: ::std::option::Option<interactive_annotation::Action>,
    // special fields
    // @@protoc_insertion_point(special_field:InteractiveAnnotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractiveAnnotation {
    fn default() -> &'a InteractiveAnnotation {
        <InteractiveAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl InteractiveAnnotation {
    pub fn new() -> InteractiveAnnotation {
        ::std::default::Default::default()
    }

    // optional .Location location = 2;

    pub fn location(&self) -> &Location {
        match self.action {
            ::std::option::Option::Some(interactive_annotation::Action::Location(ref v)) => v,
            _ => <Location as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_location(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(interactive_annotation::Action::Location(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.action = ::std::option::Option::Some(interactive_annotation::Action::Location(v))
    }

    // Mutable pointer to the field.
    pub fn mut_location(&mut self) -> &mut Location {
        if let ::std::option::Option::Some(interactive_annotation::Action::Location(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(interactive_annotation::Action::Location(Location::new()));
        }
        match self.action {
            ::std::option::Option::Some(interactive_annotation::Action::Location(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        if self.has_location() {
            match self.action.take() {
                ::std::option::Option::Some(interactive_annotation::Action::Location(v)) => v,
                _ => panic!(),
            }
        } else {
            Location::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "polygonVertices",
            |m: &InteractiveAnnotation| { &m.polygonVertices },
            |m: &mut InteractiveAnnotation| { &mut m.polygonVertices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Location>(
            "location",
            InteractiveAnnotation::has_location,
            InteractiveAnnotation::location,
            InteractiveAnnotation::mut_location,
            InteractiveAnnotation::set_location,
        ));
        oneofs.push(interactive_annotation::Action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractiveAnnotation>(
            "InteractiveAnnotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractiveAnnotation {
    const NAME: &'static str = "InteractiveAnnotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.polygonVertices.push(is.read_message()?);
                },
                18 => {
                    self.action = ::std::option::Option::Some(interactive_annotation::Action::Location(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.polygonVertices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &interactive_annotation::Action::Location(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.polygonVertices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &interactive_annotation::Action::Location(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractiveAnnotation {
        InteractiveAnnotation::new()
    }

    fn clear(&mut self) {
        self.polygonVertices.clear();
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractiveAnnotation {
        static instance: InteractiveAnnotation = InteractiveAnnotation {
            polygonVertices: ::std::vec::Vec::new(),
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractiveAnnotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractiveAnnotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractiveAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractiveAnnotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InteractiveAnnotation`
pub mod interactive_annotation {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:InteractiveAnnotation.action)
    pub enum Action {
        // @@protoc_insertion_point(oneof_field:InteractiveAnnotation.location)
        Location(super::Location),
    }

    impl ::protobuf::Oneof for Action {
    }

    impl ::protobuf::OneofFull for Action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InteractiveAnnotation as ::protobuf::MessageFull>::descriptor().oneof_by_name("action").unwrap()).clone()
        }
    }

    impl Action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action>("action")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeviceListMetadata)
pub struct DeviceListMetadata {
    // message fields
    // @@protoc_insertion_point(field:DeviceListMetadata.senderKeyHash)
    pub senderKeyHash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DeviceListMetadata.senderTimestamp)
    pub senderTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:DeviceListMetadata.senderKeyIndexes)
    pub senderKeyIndexes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:DeviceListMetadata.recipientKeyHash)
    pub recipientKeyHash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DeviceListMetadata.recipientTimestamp)
    pub recipientTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:DeviceListMetadata.recipientKeyIndexes)
    pub recipientKeyIndexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:DeviceListMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceListMetadata {
    fn default() -> &'a DeviceListMetadata {
        <DeviceListMetadata as ::protobuf::Message>::default_instance()
    }
}

impl DeviceListMetadata {
    pub fn new() -> DeviceListMetadata {
        ::std::default::Default::default()
    }

    // optional bytes senderKeyHash = 1;

    pub fn senderKeyHash(&self) -> &[u8] {
        match self.senderKeyHash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_senderKeyHash(&mut self) {
        self.senderKeyHash = ::std::option::Option::None;
    }

    pub fn has_senderKeyHash(&self) -> bool {
        self.senderKeyHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderKeyHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.senderKeyHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderKeyHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.senderKeyHash.is_none() {
            self.senderKeyHash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.senderKeyHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderKeyHash(&mut self) -> ::std::vec::Vec<u8> {
        self.senderKeyHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 senderTimestamp = 2;

    pub fn senderTimestamp(&self) -> u64 {
        self.senderTimestamp.unwrap_or(0)
    }

    pub fn clear_senderTimestamp(&mut self) {
        self.senderTimestamp = ::std::option::Option::None;
    }

    pub fn has_senderTimestamp(&self) -> bool {
        self.senderTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestamp(&mut self, v: u64) {
        self.senderTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes recipientKeyHash = 8;

    pub fn recipientKeyHash(&self) -> &[u8] {
        match self.recipientKeyHash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_recipientKeyHash(&mut self) {
        self.recipientKeyHash = ::std::option::Option::None;
    }

    pub fn has_recipientKeyHash(&self) -> bool {
        self.recipientKeyHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipientKeyHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.recipientKeyHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipientKeyHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.recipientKeyHash.is_none() {
            self.recipientKeyHash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.recipientKeyHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipientKeyHash(&mut self) -> ::std::vec::Vec<u8> {
        self.recipientKeyHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 recipientTimestamp = 9;

    pub fn recipientTimestamp(&self) -> u64 {
        self.recipientTimestamp.unwrap_or(0)
    }

    pub fn clear_recipientTimestamp(&mut self) {
        self.recipientTimestamp = ::std::option::Option::None;
    }

    pub fn has_recipientTimestamp(&self) -> bool {
        self.recipientTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipientTimestamp(&mut self, v: u64) {
        self.recipientTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderKeyHash",
            |m: &DeviceListMetadata| { &m.senderKeyHash },
            |m: &mut DeviceListMetadata| { &mut m.senderKeyHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestamp",
            |m: &DeviceListMetadata| { &m.senderTimestamp },
            |m: &mut DeviceListMetadata| { &mut m.senderTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "senderKeyIndexes",
            |m: &DeviceListMetadata| { &m.senderKeyIndexes },
            |m: &mut DeviceListMetadata| { &mut m.senderKeyIndexes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipientKeyHash",
            |m: &DeviceListMetadata| { &m.recipientKeyHash },
            |m: &mut DeviceListMetadata| { &mut m.recipientKeyHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipientTimestamp",
            |m: &DeviceListMetadata| { &m.recipientTimestamp },
            |m: &mut DeviceListMetadata| { &mut m.recipientTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "recipientKeyIndexes",
            |m: &DeviceListMetadata| { &m.recipientKeyIndexes },
            |m: &mut DeviceListMetadata| { &mut m.recipientKeyIndexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceListMetadata>(
            "DeviceListMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceListMetadata {
    const NAME: &'static str = "DeviceListMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.senderKeyHash = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.senderTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.senderKeyIndexes)?;
                },
                24 => {
                    self.senderKeyIndexes.push(is.read_uint32()?);
                },
                66 => {
                    self.recipientKeyHash = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.recipientTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.recipientKeyIndexes)?;
                },
                80 => {
                    self.recipientKeyIndexes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.senderKeyHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.senderTimestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.senderKeyIndexes);
        if let Some(v) = self.recipientKeyHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.recipientTimestamp {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(10, &self.recipientKeyIndexes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.senderKeyHash.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.senderTimestamp {
            os.write_uint64(2, v)?;
        }
        os.write_repeated_packed_uint32(3, &self.senderKeyIndexes)?;
        if let Some(v) = self.recipientKeyHash.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.recipientTimestamp {
            os.write_uint64(9, v)?;
        }
        os.write_repeated_packed_uint32(10, &self.recipientKeyIndexes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceListMetadata {
        DeviceListMetadata::new()
    }

    fn clear(&mut self) {
        self.senderKeyHash = ::std::option::Option::None;
        self.senderTimestamp = ::std::option::Option::None;
        self.senderKeyIndexes.clear();
        self.recipientKeyHash = ::std::option::Option::None;
        self.recipientTimestamp = ::std::option::Option::None;
        self.recipientKeyIndexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceListMetadata {
        static instance: DeviceListMetadata = DeviceListMetadata {
            senderKeyHash: ::std::option::Option::None,
            senderTimestamp: ::std::option::Option::None,
            senderKeyIndexes: ::std::vec::Vec::new(),
            recipientKeyHash: ::std::option::Option::None,
            recipientTimestamp: ::std::option::Option::None,
            recipientKeyIndexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceListMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceListMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceListMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceListMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MessageContextInfo)
pub struct MessageContextInfo {
    // message fields
    // @@protoc_insertion_point(field:MessageContextInfo.deviceListMetadata)
    pub deviceListMetadata: ::protobuf::MessageField<DeviceListMetadata>,
    // @@protoc_insertion_point(field:MessageContextInfo.deviceListMetadataVersion)
    pub deviceListMetadataVersion: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:MessageContextInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageContextInfo {
    fn default() -> &'a MessageContextInfo {
        <MessageContextInfo as ::protobuf::Message>::default_instance()
    }
}

impl MessageContextInfo {
    pub fn new() -> MessageContextInfo {
        ::std::default::Default::default()
    }

    // optional int32 deviceListMetadataVersion = 2;

    pub fn deviceListMetadataVersion(&self) -> i32 {
        self.deviceListMetadataVersion.unwrap_or(0)
    }

    pub fn clear_deviceListMetadataVersion(&mut self) {
        self.deviceListMetadataVersion = ::std::option::Option::None;
    }

    pub fn has_deviceListMetadataVersion(&self) -> bool {
        self.deviceListMetadataVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceListMetadataVersion(&mut self, v: i32) {
        self.deviceListMetadataVersion = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceListMetadata>(
            "deviceListMetadata",
            |m: &MessageContextInfo| { &m.deviceListMetadata },
            |m: &mut MessageContextInfo| { &mut m.deviceListMetadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceListMetadataVersion",
            |m: &MessageContextInfo| { &m.deviceListMetadataVersion },
            |m: &mut MessageContextInfo| { &mut m.deviceListMetadataVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageContextInfo>(
            "MessageContextInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageContextInfo {
    const NAME: &'static str = "MessageContextInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceListMetadata)?;
                },
                16 => {
                    self.deviceListMetadataVersion = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deviceListMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deviceListMetadataVersion {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deviceListMetadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.deviceListMetadataVersion {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageContextInfo {
        MessageContextInfo::new()
    }

    fn clear(&mut self) {
        self.deviceListMetadata.clear();
        self.deviceListMetadataVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageContextInfo {
        static instance: MessageContextInfo = MessageContextInfo {
            deviceListMetadata: ::protobuf::MessageField::none(),
            deviceListMetadataVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageContextInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageContextInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageContextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageContextInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AdReplyInfo)
pub struct AdReplyInfo {
    // message fields
    // @@protoc_insertion_point(field:AdReplyInfo.advertiserName)
    pub advertiserName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:AdReplyInfo.mediaType)
    pub mediaType: ::std::option::Option<::protobuf::EnumOrUnknown<ad_reply_info::AdReplyInfoMediaType>>,
    // @@protoc_insertion_point(field:AdReplyInfo.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AdReplyInfo.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:AdReplyInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AdReplyInfo {
    fn default() -> &'a AdReplyInfo {
        <AdReplyInfo as ::protobuf::Message>::default_instance()
    }
}

impl AdReplyInfo {
    pub fn new() -> AdReplyInfo {
        ::std::default::Default::default()
    }

    // optional string advertiserName = 1;

    pub fn advertiserName(&self) -> &str {
        match self.advertiserName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_advertiserName(&mut self) {
        self.advertiserName = ::std::option::Option::None;
    }

    pub fn has_advertiserName(&self) -> bool {
        self.advertiserName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advertiserName(&mut self, v: ::std::string::String) {
        self.advertiserName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_advertiserName(&mut self) -> &mut ::std::string::String {
        if self.advertiserName.is_none() {
            self.advertiserName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.advertiserName.as_mut().unwrap()
    }

    // Take field
    pub fn take_advertiserName(&mut self) -> ::std::string::String {
        self.advertiserName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .AdReplyInfo.AdReplyInfoMediaType mediaType = 2;

    pub fn mediaType(&self) -> ad_reply_info::AdReplyInfoMediaType {
        match self.mediaType {
            Some(e) => e.enum_value_or(ad_reply_info::AdReplyInfoMediaType::NONE),
            None => ad_reply_info::AdReplyInfoMediaType::NONE,
        }
    }

    pub fn clear_mediaType(&mut self) {
        self.mediaType = ::std::option::Option::None;
    }

    pub fn has_mediaType(&self) -> bool {
        self.mediaType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaType(&mut self, v: ad_reply_info::AdReplyInfoMediaType) {
        self.mediaType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string caption = 17;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "advertiserName",
            |m: &AdReplyInfo| { &m.advertiserName },
            |m: &mut AdReplyInfo| { &mut m.advertiserName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaType",
            |m: &AdReplyInfo| { &m.mediaType },
            |m: &mut AdReplyInfo| { &mut m.mediaType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &AdReplyInfo| { &m.jpegThumbnail },
            |m: &mut AdReplyInfo| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &AdReplyInfo| { &m.caption },
            |m: &mut AdReplyInfo| { &mut m.caption },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdReplyInfo>(
            "AdReplyInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AdReplyInfo {
    const NAME: &'static str = "AdReplyInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.advertiserName = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.mediaType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.advertiserName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mediaType {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.advertiserName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mediaType {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AdReplyInfo {
        AdReplyInfo::new()
    }

    fn clear(&mut self) {
        self.advertiserName = ::std::option::Option::None;
        self.mediaType = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AdReplyInfo {
        static instance: AdReplyInfo = AdReplyInfo {
            advertiserName: ::std::option::Option::None,
            mediaType: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AdReplyInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AdReplyInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AdReplyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdReplyInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AdReplyInfo`
pub mod ad_reply_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:AdReplyInfo.AdReplyInfoMediaType)
    pub enum AdReplyInfoMediaType {
        // @@protoc_insertion_point(enum_value:AdReplyInfo.AdReplyInfoMediaType.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:AdReplyInfo.AdReplyInfoMediaType.IMAGE)
        IMAGE = 1,
        // @@protoc_insertion_point(enum_value:AdReplyInfo.AdReplyInfoMediaType.VIDEO)
        VIDEO = 2,
    }

    impl ::protobuf::Enum for AdReplyInfoMediaType {
        const NAME: &'static str = "AdReplyInfoMediaType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AdReplyInfoMediaType> {
            match value {
                0 => ::std::option::Option::Some(AdReplyInfoMediaType::NONE),
                1 => ::std::option::Option::Some(AdReplyInfoMediaType::IMAGE),
                2 => ::std::option::Option::Some(AdReplyInfoMediaType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AdReplyInfoMediaType] = &[
            AdReplyInfoMediaType::NONE,
            AdReplyInfoMediaType::IMAGE,
            AdReplyInfoMediaType::VIDEO,
        ];
    }

    impl ::protobuf::EnumFull for AdReplyInfoMediaType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AdReplyInfo.AdReplyInfoMediaType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for AdReplyInfoMediaType {
        fn default() -> Self {
            AdReplyInfoMediaType::NONE
        }
    }

    impl AdReplyInfoMediaType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AdReplyInfoMediaType>("AdReplyInfo.AdReplyInfoMediaType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ExternalAdReplyInfo)
pub struct ExternalAdReplyInfo {
    // message fields
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.mediaType)
    pub mediaType: ::std::option::Option<::protobuf::EnumOrUnknown<external_ad_reply_info::ExternalAdReplyInfoMediaType>>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.thumbnailUrl)
    pub thumbnailUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.mediaUrl)
    pub mediaUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.thumbnail)
    pub thumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.sourceType)
    pub sourceType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.sourceId)
    pub sourceId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.sourceUrl)
    pub sourceUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExternalAdReplyInfo.containsAutoReply)
    pub containsAutoReply: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ExternalAdReplyInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExternalAdReplyInfo {
    fn default() -> &'a ExternalAdReplyInfo {
        <ExternalAdReplyInfo as ::protobuf::Message>::default_instance()
    }
}

impl ExternalAdReplyInfo {
    pub fn new() -> ExternalAdReplyInfo {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 2;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ExternalAdReplyInfo.ExternalAdReplyInfoMediaType mediaType = 3;

    pub fn mediaType(&self) -> external_ad_reply_info::ExternalAdReplyInfoMediaType {
        match self.mediaType {
            Some(e) => e.enum_value_or(external_ad_reply_info::ExternalAdReplyInfoMediaType::NONE),
            None => external_ad_reply_info::ExternalAdReplyInfoMediaType::NONE,
        }
    }

    pub fn clear_mediaType(&mut self) {
        self.mediaType = ::std::option::Option::None;
    }

    pub fn has_mediaType(&self) -> bool {
        self.mediaType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaType(&mut self, v: external_ad_reply_info::ExternalAdReplyInfoMediaType) {
        self.mediaType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string thumbnailUrl = 4;

    pub fn thumbnailUrl(&self) -> &str {
        match self.thumbnailUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailUrl(&mut self) {
        self.thumbnailUrl = ::std::option::Option::None;
    }

    pub fn has_thumbnailUrl(&self) -> bool {
        self.thumbnailUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailUrl(&mut self, v: ::std::string::String) {
        self.thumbnailUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailUrl(&mut self) -> &mut ::std::string::String {
        if self.thumbnailUrl.is_none() {
            self.thumbnailUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailUrl(&mut self) -> ::std::string::String {
        self.thumbnailUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mediaUrl = 5;

    pub fn mediaUrl(&self) -> &str {
        match self.mediaUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mediaUrl(&mut self) {
        self.mediaUrl = ::std::option::Option::None;
    }

    pub fn has_mediaUrl(&self) -> bool {
        self.mediaUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaUrl(&mut self, v: ::std::string::String) {
        self.mediaUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaUrl(&mut self) -> &mut ::std::string::String {
        if self.mediaUrl.is_none() {
            self.mediaUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mediaUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaUrl(&mut self) -> ::std::string::String {
        self.mediaUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnail = 6;

    pub fn thumbnail(&self) -> &[u8] {
        match self.thumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnail(&mut self) {
        self.thumbnail = ::std::option::Option::None;
    }

    pub fn has_thumbnail(&self) -> bool {
        self.thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnail.is_none() {
            self.thumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string sourceType = 7;

    pub fn sourceType(&self) -> &str {
        match self.sourceType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sourceType(&mut self) {
        self.sourceType = ::std::option::Option::None;
    }

    pub fn has_sourceType(&self) -> bool {
        self.sourceType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceType(&mut self, v: ::std::string::String) {
        self.sourceType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceType(&mut self) -> &mut ::std::string::String {
        if self.sourceType.is_none() {
            self.sourceType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sourceType.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceType(&mut self) -> ::std::string::String {
        self.sourceType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sourceId = 8;

    pub fn sourceId(&self) -> &str {
        match self.sourceId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sourceId(&mut self) {
        self.sourceId = ::std::option::Option::None;
    }

    pub fn has_sourceId(&self) -> bool {
        self.sourceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceId(&mut self, v: ::std::string::String) {
        self.sourceId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceId(&mut self) -> &mut ::std::string::String {
        if self.sourceId.is_none() {
            self.sourceId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sourceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceId(&mut self) -> ::std::string::String {
        self.sourceId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sourceUrl = 9;

    pub fn sourceUrl(&self) -> &str {
        match self.sourceUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sourceUrl(&mut self) {
        self.sourceUrl = ::std::option::Option::None;
    }

    pub fn has_sourceUrl(&self) -> bool {
        self.sourceUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourceUrl(&mut self, v: ::std::string::String) {
        self.sourceUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourceUrl(&mut self) -> &mut ::std::string::String {
        if self.sourceUrl.is_none() {
            self.sourceUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sourceUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourceUrl(&mut self) -> ::std::string::String {
        self.sourceUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool containsAutoReply = 10;

    pub fn containsAutoReply(&self) -> bool {
        self.containsAutoReply.unwrap_or(false)
    }

    pub fn clear_containsAutoReply(&mut self) {
        self.containsAutoReply = ::std::option::Option::None;
    }

    pub fn has_containsAutoReply(&self) -> bool {
        self.containsAutoReply.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containsAutoReply(&mut self, v: bool) {
        self.containsAutoReply = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ExternalAdReplyInfo| { &m.title },
            |m: &mut ExternalAdReplyInfo| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &ExternalAdReplyInfo| { &m.body },
            |m: &mut ExternalAdReplyInfo| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaType",
            |m: &ExternalAdReplyInfo| { &m.mediaType },
            |m: &mut ExternalAdReplyInfo| { &mut m.mediaType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailUrl",
            |m: &ExternalAdReplyInfo| { &m.thumbnailUrl },
            |m: &mut ExternalAdReplyInfo| { &mut m.thumbnailUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaUrl",
            |m: &ExternalAdReplyInfo| { &m.mediaUrl },
            |m: &mut ExternalAdReplyInfo| { &mut m.mediaUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnail",
            |m: &ExternalAdReplyInfo| { &m.thumbnail },
            |m: &mut ExternalAdReplyInfo| { &mut m.thumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sourceType",
            |m: &ExternalAdReplyInfo| { &m.sourceType },
            |m: &mut ExternalAdReplyInfo| { &mut m.sourceType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sourceId",
            |m: &ExternalAdReplyInfo| { &m.sourceId },
            |m: &mut ExternalAdReplyInfo| { &mut m.sourceId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sourceUrl",
            |m: &ExternalAdReplyInfo| { &m.sourceUrl },
            |m: &mut ExternalAdReplyInfo| { &mut m.sourceUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "containsAutoReply",
            |m: &ExternalAdReplyInfo| { &m.containsAutoReply },
            |m: &mut ExternalAdReplyInfo| { &mut m.containsAutoReply },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalAdReplyInfo>(
            "ExternalAdReplyInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExternalAdReplyInfo {
    const NAME: &'static str = "ExternalAdReplyInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.mediaType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.thumbnailUrl = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.mediaUrl = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.thumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.sourceType = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.sourceId = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.sourceUrl = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.containsAutoReply = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mediaType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.thumbnailUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.mediaUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.thumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.sourceType.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.sourceId.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.sourceUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.containsAutoReply {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.mediaType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.thumbnailUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.mediaUrl.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.thumbnail.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.sourceType.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.sourceId.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.sourceUrl.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.containsAutoReply {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExternalAdReplyInfo {
        ExternalAdReplyInfo::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.mediaType = ::std::option::Option::None;
        self.thumbnailUrl = ::std::option::Option::None;
        self.mediaUrl = ::std::option::Option::None;
        self.thumbnail = ::std::option::Option::None;
        self.sourceType = ::std::option::Option::None;
        self.sourceId = ::std::option::Option::None;
        self.sourceUrl = ::std::option::Option::None;
        self.containsAutoReply = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExternalAdReplyInfo {
        static instance: ExternalAdReplyInfo = ExternalAdReplyInfo {
            title: ::std::option::Option::None,
            body: ::std::option::Option::None,
            mediaType: ::std::option::Option::None,
            thumbnailUrl: ::std::option::Option::None,
            mediaUrl: ::std::option::Option::None,
            thumbnail: ::std::option::Option::None,
            sourceType: ::std::option::Option::None,
            sourceId: ::std::option::Option::None,
            sourceUrl: ::std::option::Option::None,
            containsAutoReply: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExternalAdReplyInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExternalAdReplyInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExternalAdReplyInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalAdReplyInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExternalAdReplyInfo`
pub mod external_ad_reply_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ExternalAdReplyInfo.ExternalAdReplyInfoMediaType)
    pub enum ExternalAdReplyInfoMediaType {
        // @@protoc_insertion_point(enum_value:ExternalAdReplyInfo.ExternalAdReplyInfoMediaType.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:ExternalAdReplyInfo.ExternalAdReplyInfoMediaType.IMAGE)
        IMAGE = 1,
        // @@protoc_insertion_point(enum_value:ExternalAdReplyInfo.ExternalAdReplyInfoMediaType.VIDEO)
        VIDEO = 2,
    }

    impl ::protobuf::Enum for ExternalAdReplyInfoMediaType {
        const NAME: &'static str = "ExternalAdReplyInfoMediaType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ExternalAdReplyInfoMediaType> {
            match value {
                0 => ::std::option::Option::Some(ExternalAdReplyInfoMediaType::NONE),
                1 => ::std::option::Option::Some(ExternalAdReplyInfoMediaType::IMAGE),
                2 => ::std::option::Option::Some(ExternalAdReplyInfoMediaType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ExternalAdReplyInfoMediaType] = &[
            ExternalAdReplyInfoMediaType::NONE,
            ExternalAdReplyInfoMediaType::IMAGE,
            ExternalAdReplyInfoMediaType::VIDEO,
        ];
    }

    impl ::protobuf::EnumFull for ExternalAdReplyInfoMediaType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExternalAdReplyInfo.ExternalAdReplyInfoMediaType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ExternalAdReplyInfoMediaType {
        fn default() -> Self {
            ExternalAdReplyInfoMediaType::NONE
        }
    }

    impl ExternalAdReplyInfoMediaType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ExternalAdReplyInfoMediaType>("ExternalAdReplyInfo.ExternalAdReplyInfoMediaType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ContextInfo)
pub struct ContextInfo {
    // message fields
    // @@protoc_insertion_point(field:ContextInfo.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.quotedMessage)
    pub quotedMessage: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:ContextInfo.remoteJid)
    pub remoteJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.mentionedJid)
    pub mentionedJid: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.conversionSource)
    pub conversionSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.conversionData)
    pub conversionData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ContextInfo.conversionDelaySeconds)
    pub conversionDelaySeconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ContextInfo.forwardingScore)
    pub forwardingScore: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ContextInfo.isForwarded)
    pub isForwarded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ContextInfo.quotedAd)
    pub quotedAd: ::protobuf::MessageField<AdReplyInfo>,
    // @@protoc_insertion_point(field:ContextInfo.placeholderKey)
    pub placeholderKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:ContextInfo.expiration)
    pub expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ContextInfo.ephemeralSettingTimestamp)
    pub ephemeralSettingTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ContextInfo.ephemeralSharedSecret)
    pub ephemeralSharedSecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ContextInfo.externalAdReply)
    pub externalAdReply: ::protobuf::MessageField<ExternalAdReplyInfo>,
    // @@protoc_insertion_point(field:ContextInfo.entryPointConversionSource)
    pub entryPointConversionSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.entryPointConversionApp)
    pub entryPointConversionApp: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.entryPointConversionDelaySeconds)
    pub entryPointConversionDelaySeconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ContextInfo.disappearingMode)
    pub disappearingMode: ::protobuf::MessageField<DisappearingMode>,
    // @@protoc_insertion_point(field:ContextInfo.actionLink)
    pub actionLink: ::protobuf::MessageField<ActionLink>,
    // @@protoc_insertion_point(field:ContextInfo.groupSubject)
    pub groupSubject: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContextInfo.parentGroupJid)
    pub parentGroupJid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ContextInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContextInfo {
    fn default() -> &'a ContextInfo {
        <ContextInfo as ::protobuf::Message>::default_instance()
    }
}

impl ContextInfo {
    pub fn new() -> ContextInfo {
        ::std::default::Default::default()
    }

    // optional string stanzaId = 1;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string participant = 2;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remoteJid = 4;

    pub fn remoteJid(&self) -> &str {
        match self.remoteJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remoteJid(&mut self) {
        self.remoteJid = ::std::option::Option::None;
    }

    pub fn has_remoteJid(&self) -> bool {
        self.remoteJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteJid(&mut self, v: ::std::string::String) {
        self.remoteJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteJid(&mut self) -> &mut ::std::string::String {
        if self.remoteJid.is_none() {
            self.remoteJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remoteJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_remoteJid(&mut self) -> ::std::string::String {
        self.remoteJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string conversionSource = 18;

    pub fn conversionSource(&self) -> &str {
        match self.conversionSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conversionSource(&mut self) {
        self.conversionSource = ::std::option::Option::None;
    }

    pub fn has_conversionSource(&self) -> bool {
        self.conversionSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionSource(&mut self, v: ::std::string::String) {
        self.conversionSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionSource(&mut self) -> &mut ::std::string::String {
        if self.conversionSource.is_none() {
            self.conversionSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conversionSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionSource(&mut self) -> ::std::string::String {
        self.conversionSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes conversionData = 19;

    pub fn conversionData(&self) -> &[u8] {
        match self.conversionData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_conversionData(&mut self) {
        self.conversionData = ::std::option::Option::None;
    }

    pub fn has_conversionData(&self) -> bool {
        self.conversionData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionData(&mut self, v: ::std::vec::Vec<u8>) {
        self.conversionData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.conversionData.is_none() {
            self.conversionData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.conversionData.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionData(&mut self) -> ::std::vec::Vec<u8> {
        self.conversionData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 conversionDelaySeconds = 20;

    pub fn conversionDelaySeconds(&self) -> u32 {
        self.conversionDelaySeconds.unwrap_or(0)
    }

    pub fn clear_conversionDelaySeconds(&mut self) {
        self.conversionDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_conversionDelaySeconds(&self) -> bool {
        self.conversionDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionDelaySeconds(&mut self, v: u32) {
        self.conversionDelaySeconds = ::std::option::Option::Some(v);
    }

    // optional uint32 forwardingScore = 21;

    pub fn forwardingScore(&self) -> u32 {
        self.forwardingScore.unwrap_or(0)
    }

    pub fn clear_forwardingScore(&mut self) {
        self.forwardingScore = ::std::option::Option::None;
    }

    pub fn has_forwardingScore(&self) -> bool {
        self.forwardingScore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forwardingScore(&mut self, v: u32) {
        self.forwardingScore = ::std::option::Option::Some(v);
    }

    // optional bool isForwarded = 22;

    pub fn isForwarded(&self) -> bool {
        self.isForwarded.unwrap_or(false)
    }

    pub fn clear_isForwarded(&mut self) {
        self.isForwarded = ::std::option::Option::None;
    }

    pub fn has_isForwarded(&self) -> bool {
        self.isForwarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isForwarded(&mut self, v: bool) {
        self.isForwarded = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration = 25;

    pub fn expiration(&self) -> u32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: u32) {
        self.expiration = ::std::option::Option::Some(v);
    }

    // optional int64 ephemeralSettingTimestamp = 26;

    pub fn ephemeralSettingTimestamp(&self) -> i64 {
        self.ephemeralSettingTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralSettingTimestamp(&mut self) {
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralSettingTimestamp(&self) -> bool {
        self.ephemeralSettingTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSettingTimestamp(&mut self, v: i64) {
        self.ephemeralSettingTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes ephemeralSharedSecret = 27;

    pub fn ephemeralSharedSecret(&self) -> &[u8] {
        match self.ephemeralSharedSecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ephemeralSharedSecret(&mut self) {
        self.ephemeralSharedSecret = ::std::option::Option::None;
    }

    pub fn has_ephemeralSharedSecret(&self) -> bool {
        self.ephemeralSharedSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSharedSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.ephemeralSharedSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeralSharedSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ephemeralSharedSecret.is_none() {
            self.ephemeralSharedSecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ephemeralSharedSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeralSharedSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.ephemeralSharedSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string entryPointConversionSource = 29;

    pub fn entryPointConversionSource(&self) -> &str {
        match self.entryPointConversionSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entryPointConversionSource(&mut self) {
        self.entryPointConversionSource = ::std::option::Option::None;
    }

    pub fn has_entryPointConversionSource(&self) -> bool {
        self.entryPointConversionSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryPointConversionSource(&mut self, v: ::std::string::String) {
        self.entryPointConversionSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entryPointConversionSource(&mut self) -> &mut ::std::string::String {
        if self.entryPointConversionSource.is_none() {
            self.entryPointConversionSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entryPointConversionSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_entryPointConversionSource(&mut self) -> ::std::string::String {
        self.entryPointConversionSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string entryPointConversionApp = 30;

    pub fn entryPointConversionApp(&self) -> &str {
        match self.entryPointConversionApp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entryPointConversionApp(&mut self) {
        self.entryPointConversionApp = ::std::option::Option::None;
    }

    pub fn has_entryPointConversionApp(&self) -> bool {
        self.entryPointConversionApp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryPointConversionApp(&mut self, v: ::std::string::String) {
        self.entryPointConversionApp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entryPointConversionApp(&mut self) -> &mut ::std::string::String {
        if self.entryPointConversionApp.is_none() {
            self.entryPointConversionApp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entryPointConversionApp.as_mut().unwrap()
    }

    // Take field
    pub fn take_entryPointConversionApp(&mut self) -> ::std::string::String {
        self.entryPointConversionApp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 entryPointConversionDelaySeconds = 31;

    pub fn entryPointConversionDelaySeconds(&self) -> u32 {
        self.entryPointConversionDelaySeconds.unwrap_or(0)
    }

    pub fn clear_entryPointConversionDelaySeconds(&mut self) {
        self.entryPointConversionDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_entryPointConversionDelaySeconds(&self) -> bool {
        self.entryPointConversionDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryPointConversionDelaySeconds(&mut self, v: u32) {
        self.entryPointConversionDelaySeconds = ::std::option::Option::Some(v);
    }

    // optional string groupSubject = 34;

    pub fn groupSubject(&self) -> &str {
        match self.groupSubject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupSubject(&mut self) {
        self.groupSubject = ::std::option::Option::None;
    }

    pub fn has_groupSubject(&self) -> bool {
        self.groupSubject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupSubject(&mut self, v: ::std::string::String) {
        self.groupSubject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupSubject(&mut self) -> &mut ::std::string::String {
        if self.groupSubject.is_none() {
            self.groupSubject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupSubject.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupSubject(&mut self) -> ::std::string::String {
        self.groupSubject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parentGroupJid = 35;

    pub fn parentGroupJid(&self) -> &str {
        match self.parentGroupJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parentGroupJid(&mut self) {
        self.parentGroupJid = ::std::option::Option::None;
    }

    pub fn has_parentGroupJid(&self) -> bool {
        self.parentGroupJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentGroupJid(&mut self, v: ::std::string::String) {
        self.parentGroupJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentGroupJid(&mut self) -> &mut ::std::string::String {
        if self.parentGroupJid.is_none() {
            self.parentGroupJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parentGroupJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_parentGroupJid(&mut self) -> ::std::string::String {
        self.parentGroupJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &ContextInfo| { &m.stanzaId },
            |m: &mut ContextInfo| { &mut m.stanzaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &ContextInfo| { &m.participant },
            |m: &mut ContextInfo| { &mut m.participant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "quotedMessage",
            |m: &ContextInfo| { &m.quotedMessage },
            |m: &mut ContextInfo| { &mut m.quotedMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remoteJid",
            |m: &ContextInfo| { &m.remoteJid },
            |m: &mut ContextInfo| { &mut m.remoteJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mentionedJid",
            |m: &ContextInfo| { &m.mentionedJid },
            |m: &mut ContextInfo| { &mut m.mentionedJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionSource",
            |m: &ContextInfo| { &m.conversionSource },
            |m: &mut ContextInfo| { &mut m.conversionSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionData",
            |m: &ContextInfo| { &m.conversionData },
            |m: &mut ContextInfo| { &mut m.conversionData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionDelaySeconds",
            |m: &ContextInfo| { &m.conversionDelaySeconds },
            |m: &mut ContextInfo| { &mut m.conversionDelaySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forwardingScore",
            |m: &ContextInfo| { &m.forwardingScore },
            |m: &mut ContextInfo| { &mut m.forwardingScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isForwarded",
            |m: &ContextInfo| { &m.isForwarded },
            |m: &mut ContextInfo| { &mut m.isForwarded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AdReplyInfo>(
            "quotedAd",
            |m: &ContextInfo| { &m.quotedAd },
            |m: &mut ContextInfo| { &mut m.quotedAd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "placeholderKey",
            |m: &ContextInfo| { &m.placeholderKey },
            |m: &mut ContextInfo| { &mut m.placeholderKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration",
            |m: &ContextInfo| { &m.expiration },
            |m: &mut ContextInfo| { &mut m.expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSettingTimestamp",
            |m: &ContextInfo| { &m.ephemeralSettingTimestamp },
            |m: &mut ContextInfo| { &mut m.ephemeralSettingTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSharedSecret",
            |m: &ContextInfo| { &m.ephemeralSharedSecret },
            |m: &mut ContextInfo| { &mut m.ephemeralSharedSecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExternalAdReplyInfo>(
            "externalAdReply",
            |m: &ContextInfo| { &m.externalAdReply },
            |m: &mut ContextInfo| { &mut m.externalAdReply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryPointConversionSource",
            |m: &ContextInfo| { &m.entryPointConversionSource },
            |m: &mut ContextInfo| { &mut m.entryPointConversionSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryPointConversionApp",
            |m: &ContextInfo| { &m.entryPointConversionApp },
            |m: &mut ContextInfo| { &mut m.entryPointConversionApp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryPointConversionDelaySeconds",
            |m: &ContextInfo| { &m.entryPointConversionDelaySeconds },
            |m: &mut ContextInfo| { &mut m.entryPointConversionDelaySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DisappearingMode>(
            "disappearingMode",
            |m: &ContextInfo| { &m.disappearingMode },
            |m: &mut ContextInfo| { &mut m.disappearingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ActionLink>(
            "actionLink",
            |m: &ContextInfo| { &m.actionLink },
            |m: &mut ContextInfo| { &mut m.actionLink },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupSubject",
            |m: &ContextInfo| { &m.groupSubject },
            |m: &mut ContextInfo| { &mut m.groupSubject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parentGroupJid",
            |m: &ContextInfo| { &m.parentGroupJid },
            |m: &mut ContextInfo| { &mut m.parentGroupJid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContextInfo>(
            "ContextInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContextInfo {
    const NAME: &'static str = "ContextInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedMessage)?;
                },
                34 => {
                    self.remoteJid = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.mentionedJid.push(is.read_string()?);
                },
                146 => {
                    self.conversionSource = ::std::option::Option::Some(is.read_string()?);
                },
                154 => {
                    self.conversionData = ::std::option::Option::Some(is.read_bytes()?);
                },
                160 => {
                    self.conversionDelaySeconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.forwardingScore = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.isForwarded = ::std::option::Option::Some(is.read_bool()?);
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedAd)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.placeholderKey)?;
                },
                200 => {
                    self.expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.ephemeralSettingTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                218 => {
                    self.ephemeralSharedSecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.externalAdReply)?;
                },
                234 => {
                    self.entryPointConversionSource = ::std::option::Option::Some(is.read_string()?);
                },
                242 => {
                    self.entryPointConversionApp = ::std::option::Option::Some(is.read_string()?);
                },
                248 => {
                    self.entryPointConversionDelaySeconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.disappearingMode)?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actionLink)?;
                },
                274 => {
                    self.groupSubject = ::std::option::Option::Some(is.read_string()?);
                },
                282 => {
                    self.parentGroupJid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.quotedMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.remoteJid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.mentionedJid {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.conversionSource.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.conversionData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(19, &v);
        }
        if let Some(v) = self.conversionDelaySeconds {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.forwardingScore {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.isForwarded {
            my_size += 2 + 1;
        }
        if let Some(v) = self.quotedAd.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.placeholderKey.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            my_size += ::protobuf::rt::int64_size(26, v);
        }
        if let Some(v) = self.ephemeralSharedSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(27, &v);
        }
        if let Some(v) = self.externalAdReply.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entryPointConversionSource.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.entryPointConversionApp.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        if let Some(v) = self.entryPointConversionDelaySeconds {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.actionLink.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.groupSubject.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        if let Some(v) = self.parentGroupJid.as_ref() {
            my_size += ::protobuf::rt::string_size(35, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.quotedMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.remoteJid.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.mentionedJid {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.conversionSource.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.conversionData.as_ref() {
            os.write_bytes(19, v)?;
        }
        if let Some(v) = self.conversionDelaySeconds {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.forwardingScore {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.isForwarded {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.quotedAd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.placeholderKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.expiration {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            os.write_int64(26, v)?;
        }
        if let Some(v) = self.ephemeralSharedSecret.as_ref() {
            os.write_bytes(27, v)?;
        }
        if let Some(v) = self.externalAdReply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.entryPointConversionSource.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.entryPointConversionApp.as_ref() {
            os.write_string(30, v)?;
        }
        if let Some(v) = self.entryPointConversionDelaySeconds {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.actionLink.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.groupSubject.as_ref() {
            os.write_string(34, v)?;
        }
        if let Some(v) = self.parentGroupJid.as_ref() {
            os.write_string(35, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContextInfo {
        ContextInfo::new()
    }

    fn clear(&mut self) {
        self.stanzaId = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.quotedMessage.clear();
        self.remoteJid = ::std::option::Option::None;
        self.mentionedJid.clear();
        self.conversionSource = ::std::option::Option::None;
        self.conversionData = ::std::option::Option::None;
        self.conversionDelaySeconds = ::std::option::Option::None;
        self.forwardingScore = ::std::option::Option::None;
        self.isForwarded = ::std::option::Option::None;
        self.quotedAd.clear();
        self.placeholderKey.clear();
        self.expiration = ::std::option::Option::None;
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
        self.ephemeralSharedSecret = ::std::option::Option::None;
        self.externalAdReply.clear();
        self.entryPointConversionSource = ::std::option::Option::None;
        self.entryPointConversionApp = ::std::option::Option::None;
        self.entryPointConversionDelaySeconds = ::std::option::Option::None;
        self.disappearingMode.clear();
        self.actionLink.clear();
        self.groupSubject = ::std::option::Option::None;
        self.parentGroupJid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContextInfo {
        static instance: ContextInfo = ContextInfo {
            stanzaId: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            quotedMessage: ::protobuf::MessageField::none(),
            remoteJid: ::std::option::Option::None,
            mentionedJid: ::std::vec::Vec::new(),
            conversionSource: ::std::option::Option::None,
            conversionData: ::std::option::Option::None,
            conversionDelaySeconds: ::std::option::Option::None,
            forwardingScore: ::std::option::Option::None,
            isForwarded: ::std::option::Option::None,
            quotedAd: ::protobuf::MessageField::none(),
            placeholderKey: ::protobuf::MessageField::none(),
            expiration: ::std::option::Option::None,
            ephemeralSettingTimestamp: ::std::option::Option::None,
            ephemeralSharedSecret: ::std::option::Option::None,
            externalAdReply: ::protobuf::MessageField::none(),
            entryPointConversionSource: ::std::option::Option::None,
            entryPointConversionApp: ::std::option::Option::None,
            entryPointConversionDelaySeconds: ::std::option::Option::None,
            disappearingMode: ::protobuf::MessageField::none(),
            actionLink: ::protobuf::MessageField::none(),
            groupSubject: ::std::option::Option::None,
            parentGroupJid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContextInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContextInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SenderKeyDistributionMessage)
pub struct SenderKeyDistributionMessage {
    // message fields
    // @@protoc_insertion_point(field:SenderKeyDistributionMessage.groupId)
    pub groupId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SenderKeyDistributionMessage.axolotlSenderKeyDistributionMessage)
    pub axolotlSenderKeyDistributionMessage: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:SenderKeyDistributionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SenderKeyDistributionMessage {
    fn default() -> &'a SenderKeyDistributionMessage {
        <SenderKeyDistributionMessage as ::protobuf::Message>::default_instance()
    }
}

impl SenderKeyDistributionMessage {
    pub fn new() -> SenderKeyDistributionMessage {
        ::std::default::Default::default()
    }

    // optional string groupId = 1;

    pub fn groupId(&self) -> &str {
        match self.groupId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupId(&mut self) {
        self.groupId = ::std::option::Option::None;
    }

    pub fn has_groupId(&self) -> bool {
        self.groupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupId(&mut self, v: ::std::string::String) {
        self.groupId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupId(&mut self) -> &mut ::std::string::String {
        if self.groupId.is_none() {
            self.groupId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupId.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupId(&mut self) -> ::std::string::String {
        self.groupId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes axolotlSenderKeyDistributionMessage = 2;

    pub fn axolotlSenderKeyDistributionMessage(&self) -> &[u8] {
        match self.axolotlSenderKeyDistributionMessage.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_axolotlSenderKeyDistributionMessage(&mut self) {
        self.axolotlSenderKeyDistributionMessage = ::std::option::Option::None;
    }

    pub fn has_axolotlSenderKeyDistributionMessage(&self) -> bool {
        self.axolotlSenderKeyDistributionMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_axolotlSenderKeyDistributionMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.axolotlSenderKeyDistributionMessage = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_axolotlSenderKeyDistributionMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.axolotlSenderKeyDistributionMessage.is_none() {
            self.axolotlSenderKeyDistributionMessage = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.axolotlSenderKeyDistributionMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_axolotlSenderKeyDistributionMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.axolotlSenderKeyDistributionMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupId",
            |m: &SenderKeyDistributionMessage| { &m.groupId },
            |m: &mut SenderKeyDistributionMessage| { &mut m.groupId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "axolotlSenderKeyDistributionMessage",
            |m: &SenderKeyDistributionMessage| { &m.axolotlSenderKeyDistributionMessage },
            |m: &mut SenderKeyDistributionMessage| { &mut m.axolotlSenderKeyDistributionMessage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SenderKeyDistributionMessage>(
            "SenderKeyDistributionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SenderKeyDistributionMessage {
    const NAME: &'static str = "SenderKeyDistributionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.axolotlSenderKeyDistributionMessage = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.axolotlSenderKeyDistributionMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.axolotlSenderKeyDistributionMessage.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SenderKeyDistributionMessage {
        SenderKeyDistributionMessage::new()
    }

    fn clear(&mut self) {
        self.groupId = ::std::option::Option::None;
        self.axolotlSenderKeyDistributionMessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SenderKeyDistributionMessage {
        static instance: SenderKeyDistributionMessage = SenderKeyDistributionMessage {
            groupId: ::std::option::Option::None,
            axolotlSenderKeyDistributionMessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SenderKeyDistributionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SenderKeyDistributionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SenderKeyDistributionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SenderKeyDistributionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ImageMessage)
pub struct ImageMessage {
    // message fields
    // @@protoc_insertion_point(field:ImageMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ImageMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ImageMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ImageMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ImageMessage.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ImageMessage.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ImageMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.interactiveAnnotations)
    pub interactiveAnnotations: ::std::vec::Vec<InteractiveAnnotation>,
    // @@protoc_insertion_point(field:ImageMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ImageMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ImageMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:ImageMessage.firstScanSidecar)
    pub firstScanSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.firstScanLength)
    pub firstScanLength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ImageMessage.experimentGroupId)
    pub experimentGroupId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ImageMessage.scansSidecar)
    pub scansSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.scanLengths)
    pub scanLengths: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:ImageMessage.midQualityFileSha256)
    pub midQualityFileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.midQualityFileEncSha256)
    pub midQualityFileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.viewOnce)
    pub viewOnce: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ImageMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ImageMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ImageMessage.staticUrl)
    pub staticUrl: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ImageMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ImageMessage {
    fn default() -> &'a ImageMessage {
        <ImageMessage as ::protobuf::Message>::default_instance()
    }
}

impl ImageMessage {
    pub fn new() -> ImageMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 4;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 5;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 7;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 8;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 9;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 11;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 12;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes firstScanSidecar = 18;

    pub fn firstScanSidecar(&self) -> &[u8] {
        match self.firstScanSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_firstScanSidecar(&mut self) {
        self.firstScanSidecar = ::std::option::Option::None;
    }

    pub fn has_firstScanSidecar(&self) -> bool {
        self.firstScanSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstScanSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.firstScanSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstScanSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.firstScanSidecar.is_none() {
            self.firstScanSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.firstScanSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstScanSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.firstScanSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 firstScanLength = 19;

    pub fn firstScanLength(&self) -> u32 {
        self.firstScanLength.unwrap_or(0)
    }

    pub fn clear_firstScanLength(&mut self) {
        self.firstScanLength = ::std::option::Option::None;
    }

    pub fn has_firstScanLength(&self) -> bool {
        self.firstScanLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstScanLength(&mut self, v: u32) {
        self.firstScanLength = ::std::option::Option::Some(v);
    }

    // optional uint32 experimentGroupId = 20;

    pub fn experimentGroupId(&self) -> u32 {
        self.experimentGroupId.unwrap_or(0)
    }

    pub fn clear_experimentGroupId(&mut self) {
        self.experimentGroupId = ::std::option::Option::None;
    }

    pub fn has_experimentGroupId(&self) -> bool {
        self.experimentGroupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimentGroupId(&mut self, v: u32) {
        self.experimentGroupId = ::std::option::Option::Some(v);
    }

    // optional bytes scansSidecar = 21;

    pub fn scansSidecar(&self) -> &[u8] {
        match self.scansSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_scansSidecar(&mut self) {
        self.scansSidecar = ::std::option::Option::None;
    }

    pub fn has_scansSidecar(&self) -> bool {
        self.scansSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scansSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.scansSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scansSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.scansSidecar.is_none() {
            self.scansSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.scansSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scansSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.scansSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes midQualityFileSha256 = 23;

    pub fn midQualityFileSha256(&self) -> &[u8] {
        match self.midQualityFileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_midQualityFileSha256(&mut self) {
        self.midQualityFileSha256 = ::std::option::Option::None;
    }

    pub fn has_midQualityFileSha256(&self) -> bool {
        self.midQualityFileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_midQualityFileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.midQualityFileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_midQualityFileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.midQualityFileSha256.is_none() {
            self.midQualityFileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.midQualityFileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_midQualityFileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.midQualityFileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes midQualityFileEncSha256 = 24;

    pub fn midQualityFileEncSha256(&self) -> &[u8] {
        match self.midQualityFileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_midQualityFileEncSha256(&mut self) {
        self.midQualityFileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_midQualityFileEncSha256(&self) -> bool {
        self.midQualityFileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_midQualityFileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.midQualityFileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_midQualityFileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.midQualityFileEncSha256.is_none() {
            self.midQualityFileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.midQualityFileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_midQualityFileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.midQualityFileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool viewOnce = 25;

    pub fn viewOnce(&self) -> bool {
        self.viewOnce.unwrap_or(false)
    }

    pub fn clear_viewOnce(&mut self) {
        self.viewOnce = ::std::option::Option::None;
    }

    pub fn has_viewOnce(&self) -> bool {
        self.viewOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewOnce(&mut self, v: bool) {
        self.viewOnce = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 26;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 27;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 28;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string staticUrl = 29;

    pub fn staticUrl(&self) -> &str {
        match self.staticUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_staticUrl(&mut self) {
        self.staticUrl = ::std::option::Option::None;
    }

    pub fn has_staticUrl(&self) -> bool {
        self.staticUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staticUrl(&mut self, v: ::std::string::String) {
        self.staticUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_staticUrl(&mut self) -> &mut ::std::string::String {
        if self.staticUrl.is_none() {
            self.staticUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.staticUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_staticUrl(&mut self) -> ::std::string::String {
        self.staticUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &ImageMessage| { &m.url },
            |m: &mut ImageMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &ImageMessage| { &m.mimetype },
            |m: &mut ImageMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &ImageMessage| { &m.caption },
            |m: &mut ImageMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &ImageMessage| { &m.fileSha256 },
            |m: &mut ImageMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &ImageMessage| { &m.fileLength },
            |m: &mut ImageMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &ImageMessage| { &m.height },
            |m: &mut ImageMessage| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &ImageMessage| { &m.width },
            |m: &mut ImageMessage| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &ImageMessage| { &m.mediaKey },
            |m: &mut ImageMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &ImageMessage| { &m.fileEncSha256 },
            |m: &mut ImageMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interactiveAnnotations",
            |m: &ImageMessage| { &m.interactiveAnnotations },
            |m: &mut ImageMessage| { &mut m.interactiveAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &ImageMessage| { &m.directPath },
            |m: &mut ImageMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &ImageMessage| { &m.mediaKeyTimestamp },
            |m: &mut ImageMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &ImageMessage| { &m.jpegThumbnail },
            |m: &mut ImageMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ImageMessage| { &m.contextInfo },
            |m: &mut ImageMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstScanSidecar",
            |m: &ImageMessage| { &m.firstScanSidecar },
            |m: &mut ImageMessage| { &mut m.firstScanSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstScanLength",
            |m: &ImageMessage| { &m.firstScanLength },
            |m: &mut ImageMessage| { &mut m.firstScanLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimentGroupId",
            |m: &ImageMessage| { &m.experimentGroupId },
            |m: &mut ImageMessage| { &mut m.experimentGroupId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scansSidecar",
            |m: &ImageMessage| { &m.scansSidecar },
            |m: &mut ImageMessage| { &mut m.scansSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scanLengths",
            |m: &ImageMessage| { &m.scanLengths },
            |m: &mut ImageMessage| { &mut m.scanLengths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "midQualityFileSha256",
            |m: &ImageMessage| { &m.midQualityFileSha256 },
            |m: &mut ImageMessage| { &mut m.midQualityFileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "midQualityFileEncSha256",
            |m: &ImageMessage| { &m.midQualityFileEncSha256 },
            |m: &mut ImageMessage| { &mut m.midQualityFileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewOnce",
            |m: &ImageMessage| { &m.viewOnce },
            |m: &mut ImageMessage| { &mut m.viewOnce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &ImageMessage| { &m.thumbnailDirectPath },
            |m: &mut ImageMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &ImageMessage| { &m.thumbnailSha256 },
            |m: &mut ImageMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &ImageMessage| { &m.thumbnailEncSha256 },
            |m: &mut ImageMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "staticUrl",
            |m: &ImageMessage| { &m.staticUrl },
            |m: &mut ImageMessage| { &mut m.staticUrl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImageMessage>(
            "ImageMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ImageMessage {
    const NAME: &'static str = "ImageMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                82 => {
                    self.interactiveAnnotations.push(is.read_message()?);
                },
                90 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                146 => {
                    self.firstScanSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                152 => {
                    self.firstScanLength = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.experimentGroupId = ::std::option::Option::Some(is.read_uint32()?);
                },
                170 => {
                    self.scansSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                178 => {
                    is.read_repeated_packed_uint32_into(&mut self.scanLengths)?;
                },
                176 => {
                    self.scanLengths.push(is.read_uint32()?);
                },
                186 => {
                    self.midQualityFileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                194 => {
                    self.midQualityFileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                200 => {
                    self.viewOnce = ::std::option::Option::Some(is.read_bool()?);
                },
                210 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                218 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                226 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                234 => {
                    self.staticUrl = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        for value in &self.interactiveAnnotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(12, v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.firstScanSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.firstScanLength {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.experimentGroupId {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.scansSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        for value in &self.scanLengths {
            my_size += ::protobuf::rt::uint32_size(22, *value);
        };
        if let Some(v) = self.midQualityFileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(23, &v);
        }
        if let Some(v) = self.midQualityFileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(24, &v);
        }
        if let Some(v) = self.viewOnce {
            my_size += 2 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(27, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(28, &v);
        }
        if let Some(v) = self.staticUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(9, v)?;
        }
        for v in &self.interactiveAnnotations {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.firstScanSidecar.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.firstScanLength {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.experimentGroupId {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.scansSidecar.as_ref() {
            os.write_bytes(21, v)?;
        }
        for v in &self.scanLengths {
            os.write_uint32(22, *v)?;
        };
        if let Some(v) = self.midQualityFileSha256.as_ref() {
            os.write_bytes(23, v)?;
        }
        if let Some(v) = self.midQualityFileEncSha256.as_ref() {
            os.write_bytes(24, v)?;
        }
        if let Some(v) = self.viewOnce {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(26, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(27, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(28, v)?;
        }
        if let Some(v) = self.staticUrl.as_ref() {
            os.write_string(29, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ImageMessage {
        ImageMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.interactiveAnnotations.clear();
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.firstScanSidecar = ::std::option::Option::None;
        self.firstScanLength = ::std::option::Option::None;
        self.experimentGroupId = ::std::option::Option::None;
        self.scansSidecar = ::std::option::Option::None;
        self.scanLengths.clear();
        self.midQualityFileSha256 = ::std::option::Option::None;
        self.midQualityFileEncSha256 = ::std::option::Option::None;
        self.viewOnce = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.staticUrl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ImageMessage {
        static instance: ImageMessage = ImageMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            interactiveAnnotations: ::std::vec::Vec::new(),
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            firstScanSidecar: ::std::option::Option::None,
            firstScanLength: ::std::option::Option::None,
            experimentGroupId: ::std::option::Option::None,
            scansSidecar: ::std::option::Option::None,
            scanLengths: ::std::vec::Vec::new(),
            midQualityFileSha256: ::std::option::Option::None,
            midQualityFileEncSha256: ::std::option::Option::None,
            viewOnce: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            staticUrl: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ImageMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ImageMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ImageMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:InvoiceMessage)
pub struct InvoiceMessage {
    // message fields
    // @@protoc_insertion_point(field:InvoiceMessage.note)
    pub note: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:InvoiceMessage.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentType)
    pub attachmentType: ::std::option::Option<::protobuf::EnumOrUnknown<invoice_message::InvoiceMessageAttachmentType>>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentMimetype)
    pub attachmentMimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentMediaKey)
    pub attachmentMediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentMediaKeyTimestamp)
    pub attachmentMediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentFileSha256)
    pub attachmentFileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentFileEncSha256)
    pub attachmentFileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentDirectPath)
    pub attachmentDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:InvoiceMessage.attachmentJpegThumbnail)
    pub attachmentJpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:InvoiceMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InvoiceMessage {
    fn default() -> &'a InvoiceMessage {
        <InvoiceMessage as ::protobuf::Message>::default_instance()
    }
}

impl InvoiceMessage {
    pub fn new() -> InvoiceMessage {
        ::std::default::Default::default()
    }

    // optional string note = 1;

    pub fn note(&self) -> &str {
        match self.note.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_note(&mut self) {
        self.note = ::std::option::Option::None;
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::string::String) {
        self.note = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::string::String {
        if self.note.is_none() {
            self.note = ::std::option::Option::Some(::std::string::String::new());
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::string::String {
        self.note.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string token = 2;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .InvoiceMessage.InvoiceMessageAttachmentType attachmentType = 3;

    pub fn attachmentType(&self) -> invoice_message::InvoiceMessageAttachmentType {
        match self.attachmentType {
            Some(e) => e.enum_value_or(invoice_message::InvoiceMessageAttachmentType::IMAGE),
            None => invoice_message::InvoiceMessageAttachmentType::IMAGE,
        }
    }

    pub fn clear_attachmentType(&mut self) {
        self.attachmentType = ::std::option::Option::None;
    }

    pub fn has_attachmentType(&self) -> bool {
        self.attachmentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentType(&mut self, v: invoice_message::InvoiceMessageAttachmentType) {
        self.attachmentType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string attachmentMimetype = 4;

    pub fn attachmentMimetype(&self) -> &str {
        match self.attachmentMimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attachmentMimetype(&mut self) {
        self.attachmentMimetype = ::std::option::Option::None;
    }

    pub fn has_attachmentMimetype(&self) -> bool {
        self.attachmentMimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentMimetype(&mut self, v: ::std::string::String) {
        self.attachmentMimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentMimetype(&mut self) -> &mut ::std::string::String {
        if self.attachmentMimetype.is_none() {
            self.attachmentMimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attachmentMimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentMimetype(&mut self) -> ::std::string::String {
        self.attachmentMimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes attachmentMediaKey = 5;

    pub fn attachmentMediaKey(&self) -> &[u8] {
        match self.attachmentMediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentMediaKey(&mut self) {
        self.attachmentMediaKey = ::std::option::Option::None;
    }

    pub fn has_attachmentMediaKey(&self) -> bool {
        self.attachmentMediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentMediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentMediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentMediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentMediaKey.is_none() {
            self.attachmentMediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentMediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentMediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentMediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 attachmentMediaKeyTimestamp = 6;

    pub fn attachmentMediaKeyTimestamp(&self) -> i64 {
        self.attachmentMediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_attachmentMediaKeyTimestamp(&mut self) {
        self.attachmentMediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_attachmentMediaKeyTimestamp(&self) -> bool {
        self.attachmentMediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentMediaKeyTimestamp(&mut self, v: i64) {
        self.attachmentMediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes attachmentFileSha256 = 7;

    pub fn attachmentFileSha256(&self) -> &[u8] {
        match self.attachmentFileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentFileSha256(&mut self) {
        self.attachmentFileSha256 = ::std::option::Option::None;
    }

    pub fn has_attachmentFileSha256(&self) -> bool {
        self.attachmentFileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentFileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentFileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentFileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentFileSha256.is_none() {
            self.attachmentFileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentFileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentFileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentFileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes attachmentFileEncSha256 = 8;

    pub fn attachmentFileEncSha256(&self) -> &[u8] {
        match self.attachmentFileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentFileEncSha256(&mut self) {
        self.attachmentFileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_attachmentFileEncSha256(&self) -> bool {
        self.attachmentFileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentFileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentFileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentFileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentFileEncSha256.is_none() {
            self.attachmentFileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentFileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentFileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentFileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string attachmentDirectPath = 9;

    pub fn attachmentDirectPath(&self) -> &str {
        match self.attachmentDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attachmentDirectPath(&mut self) {
        self.attachmentDirectPath = ::std::option::Option::None;
    }

    pub fn has_attachmentDirectPath(&self) -> bool {
        self.attachmentDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentDirectPath(&mut self, v: ::std::string::String) {
        self.attachmentDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentDirectPath(&mut self) -> &mut ::std::string::String {
        if self.attachmentDirectPath.is_none() {
            self.attachmentDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attachmentDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentDirectPath(&mut self) -> ::std::string::String {
        self.attachmentDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes attachmentJpegThumbnail = 10;

    pub fn attachmentJpegThumbnail(&self) -> &[u8] {
        match self.attachmentJpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentJpegThumbnail(&mut self) {
        self.attachmentJpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_attachmentJpegThumbnail(&self) -> bool {
        self.attachmentJpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentJpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentJpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentJpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentJpegThumbnail.is_none() {
            self.attachmentJpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentJpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentJpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentJpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "note",
            |m: &InvoiceMessage| { &m.note },
            |m: &mut InvoiceMessage| { &mut m.note },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &InvoiceMessage| { &m.token },
            |m: &mut InvoiceMessage| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentType",
            |m: &InvoiceMessage| { &m.attachmentType },
            |m: &mut InvoiceMessage| { &mut m.attachmentType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentMimetype",
            |m: &InvoiceMessage| { &m.attachmentMimetype },
            |m: &mut InvoiceMessage| { &mut m.attachmentMimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentMediaKey",
            |m: &InvoiceMessage| { &m.attachmentMediaKey },
            |m: &mut InvoiceMessage| { &mut m.attachmentMediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentMediaKeyTimestamp",
            |m: &InvoiceMessage| { &m.attachmentMediaKeyTimestamp },
            |m: &mut InvoiceMessage| { &mut m.attachmentMediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentFileSha256",
            |m: &InvoiceMessage| { &m.attachmentFileSha256 },
            |m: &mut InvoiceMessage| { &mut m.attachmentFileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentFileEncSha256",
            |m: &InvoiceMessage| { &m.attachmentFileEncSha256 },
            |m: &mut InvoiceMessage| { &mut m.attachmentFileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentDirectPath",
            |m: &InvoiceMessage| { &m.attachmentDirectPath },
            |m: &mut InvoiceMessage| { &mut m.attachmentDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentJpegThumbnail",
            |m: &InvoiceMessage| { &m.attachmentJpegThumbnail },
            |m: &mut InvoiceMessage| { &mut m.attachmentJpegThumbnail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InvoiceMessage>(
            "InvoiceMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InvoiceMessage {
    const NAME: &'static str = "InvoiceMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.note = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.attachmentType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.attachmentMimetype = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.attachmentMediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.attachmentMediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                58 => {
                    self.attachmentFileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.attachmentFileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.attachmentDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.attachmentJpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.note.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.attachmentType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.attachmentMimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.attachmentMediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.attachmentMediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.attachmentFileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.attachmentFileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.attachmentDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.attachmentJpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.note.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.attachmentType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.attachmentMimetype.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.attachmentMediaKey.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.attachmentMediaKeyTimestamp {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.attachmentFileSha256.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.attachmentFileEncSha256.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.attachmentDirectPath.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.attachmentJpegThumbnail.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InvoiceMessage {
        InvoiceMessage::new()
    }

    fn clear(&mut self) {
        self.note = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.attachmentType = ::std::option::Option::None;
        self.attachmentMimetype = ::std::option::Option::None;
        self.attachmentMediaKey = ::std::option::Option::None;
        self.attachmentMediaKeyTimestamp = ::std::option::Option::None;
        self.attachmentFileSha256 = ::std::option::Option::None;
        self.attachmentFileEncSha256 = ::std::option::Option::None;
        self.attachmentDirectPath = ::std::option::Option::None;
        self.attachmentJpegThumbnail = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InvoiceMessage {
        static instance: InvoiceMessage = InvoiceMessage {
            note: ::std::option::Option::None,
            token: ::std::option::Option::None,
            attachmentType: ::std::option::Option::None,
            attachmentMimetype: ::std::option::Option::None,
            attachmentMediaKey: ::std::option::Option::None,
            attachmentMediaKeyTimestamp: ::std::option::Option::None,
            attachmentFileSha256: ::std::option::Option::None,
            attachmentFileEncSha256: ::std::option::Option::None,
            attachmentDirectPath: ::std::option::Option::None,
            attachmentJpegThumbnail: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InvoiceMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InvoiceMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InvoiceMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InvoiceMessage`
pub mod invoice_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:InvoiceMessage.InvoiceMessageAttachmentType)
    pub enum InvoiceMessageAttachmentType {
        // @@protoc_insertion_point(enum_value:InvoiceMessage.InvoiceMessageAttachmentType.IMAGE)
        IMAGE = 0,
        // @@protoc_insertion_point(enum_value:InvoiceMessage.InvoiceMessageAttachmentType.PDF)
        PDF = 1,
    }

    impl ::protobuf::Enum for InvoiceMessageAttachmentType {
        const NAME: &'static str = "InvoiceMessageAttachmentType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<InvoiceMessageAttachmentType> {
            match value {
                0 => ::std::option::Option::Some(InvoiceMessageAttachmentType::IMAGE),
                1 => ::std::option::Option::Some(InvoiceMessageAttachmentType::PDF),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [InvoiceMessageAttachmentType] = &[
            InvoiceMessageAttachmentType::IMAGE,
            InvoiceMessageAttachmentType::PDF,
        ];
    }

    impl ::protobuf::EnumFull for InvoiceMessageAttachmentType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("InvoiceMessage.InvoiceMessageAttachmentType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for InvoiceMessageAttachmentType {
        fn default() -> Self {
            InvoiceMessageAttachmentType::IMAGE
        }
    }

    impl InvoiceMessageAttachmentType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InvoiceMessageAttachmentType>("InvoiceMessage.InvoiceMessageAttachmentType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ContactMessage)
pub struct ContactMessage {
    // message fields
    // @@protoc_insertion_point(field:ContactMessage.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContactMessage.vcard)
    pub vcard: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContactMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ContactMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactMessage {
    fn default() -> &'a ContactMessage {
        <ContactMessage as ::protobuf::Message>::default_instance()
    }
}

impl ContactMessage {
    pub fn new() -> ContactMessage {
        ::std::default::Default::default()
    }

    // optional string displayName = 1;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vcard = 16;

    pub fn vcard(&self) -> &str {
        match self.vcard.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vcard(&mut self) {
        self.vcard = ::std::option::Option::None;
    }

    pub fn has_vcard(&self) -> bool {
        self.vcard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vcard(&mut self, v: ::std::string::String) {
        self.vcard = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vcard(&mut self) -> &mut ::std::string::String {
        if self.vcard.is_none() {
            self.vcard = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vcard.as_mut().unwrap()
    }

    // Take field
    pub fn take_vcard(&mut self) -> ::std::string::String {
        self.vcard.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &ContactMessage| { &m.displayName },
            |m: &mut ContactMessage| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vcard",
            |m: &ContactMessage| { &m.vcard },
            |m: &mut ContactMessage| { &mut m.vcard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ContactMessage| { &m.contextInfo },
            |m: &mut ContactMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactMessage>(
            "ContactMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactMessage {
    const NAME: &'static str = "ContactMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.vcard = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.vcard.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.vcard.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactMessage {
        ContactMessage::new()
    }

    fn clear(&mut self) {
        self.displayName = ::std::option::Option::None;
        self.vcard = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactMessage {
        static instance: ContactMessage = ContactMessage {
            displayName: ::std::option::Option::None,
            vcard: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LocationMessage)
pub struct LocationMessage {
    // message fields
    // @@protoc_insertion_point(field:LocationMessage.degreesLatitude)
    pub degreesLatitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:LocationMessage.degreesLongitude)
    pub degreesLongitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:LocationMessage.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LocationMessage.address)
    pub address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LocationMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LocationMessage.isLive)
    pub isLive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:LocationMessage.accuracyInMeters)
    pub accuracyInMeters: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LocationMessage.speedInMps)
    pub speedInMps: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:LocationMessage.degreesClockwiseFromMagneticNorth)
    pub degreesClockwiseFromMagneticNorth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LocationMessage.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LocationMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LocationMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:LocationMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocationMessage {
    fn default() -> &'a LocationMessage {
        <LocationMessage as ::protobuf::Message>::default_instance()
    }
}

impl LocationMessage {
    pub fn new() -> LocationMessage {
        ::std::default::Default::default()
    }

    // optional double degreesLatitude = 1;

    pub fn degreesLatitude(&self) -> f64 {
        self.degreesLatitude.unwrap_or(0.)
    }

    pub fn clear_degreesLatitude(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
    }

    pub fn has_degreesLatitude(&self) -> bool {
        self.degreesLatitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLatitude(&mut self, v: f64) {
        self.degreesLatitude = ::std::option::Option::Some(v);
    }

    // optional double degreesLongitude = 2;

    pub fn degreesLongitude(&self) -> f64 {
        self.degreesLongitude.unwrap_or(0.)
    }

    pub fn clear_degreesLongitude(&mut self) {
        self.degreesLongitude = ::std::option::Option::None;
    }

    pub fn has_degreesLongitude(&self) -> bool {
        self.degreesLongitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLongitude(&mut self, v: f64) {
        self.degreesLongitude = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address = 4;

    pub fn address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 5;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool isLive = 6;

    pub fn isLive(&self) -> bool {
        self.isLive.unwrap_or(false)
    }

    pub fn clear_isLive(&mut self) {
        self.isLive = ::std::option::Option::None;
    }

    pub fn has_isLive(&self) -> bool {
        self.isLive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isLive(&mut self, v: bool) {
        self.isLive = ::std::option::Option::Some(v);
    }

    // optional uint32 accuracyInMeters = 7;

    pub fn accuracyInMeters(&self) -> u32 {
        self.accuracyInMeters.unwrap_or(0)
    }

    pub fn clear_accuracyInMeters(&mut self) {
        self.accuracyInMeters = ::std::option::Option::None;
    }

    pub fn has_accuracyInMeters(&self) -> bool {
        self.accuracyInMeters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accuracyInMeters(&mut self, v: u32) {
        self.accuracyInMeters = ::std::option::Option::Some(v);
    }

    // optional float speedInMps = 8;

    pub fn speedInMps(&self) -> f32 {
        self.speedInMps.unwrap_or(0.)
    }

    pub fn clear_speedInMps(&mut self) {
        self.speedInMps = ::std::option::Option::None;
    }

    pub fn has_speedInMps(&self) -> bool {
        self.speedInMps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speedInMps(&mut self, v: f32) {
        self.speedInMps = ::std::option::Option::Some(v);
    }

    // optional uint32 degreesClockwiseFromMagneticNorth = 9;

    pub fn degreesClockwiseFromMagneticNorth(&self) -> u32 {
        self.degreesClockwiseFromMagneticNorth.unwrap_or(0)
    }

    pub fn clear_degreesClockwiseFromMagneticNorth(&mut self) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
    }

    pub fn has_degreesClockwiseFromMagneticNorth(&self) -> bool {
        self.degreesClockwiseFromMagneticNorth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesClockwiseFromMagneticNorth(&mut self, v: u32) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(v);
    }

    // optional string comment = 11;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLatitude",
            |m: &LocationMessage| { &m.degreesLatitude },
            |m: &mut LocationMessage| { &mut m.degreesLatitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLongitude",
            |m: &LocationMessage| { &m.degreesLongitude },
            |m: &mut LocationMessage| { &mut m.degreesLongitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &LocationMessage| { &m.name },
            |m: &mut LocationMessage| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &LocationMessage| { &m.address },
            |m: &mut LocationMessage| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &LocationMessage| { &m.url },
            |m: &mut LocationMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isLive",
            |m: &LocationMessage| { &m.isLive },
            |m: &mut LocationMessage| { &mut m.isLive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accuracyInMeters",
            |m: &LocationMessage| { &m.accuracyInMeters },
            |m: &mut LocationMessage| { &mut m.accuracyInMeters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speedInMps",
            |m: &LocationMessage| { &m.speedInMps },
            |m: &mut LocationMessage| { &mut m.speedInMps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesClockwiseFromMagneticNorth",
            |m: &LocationMessage| { &m.degreesClockwiseFromMagneticNorth },
            |m: &mut LocationMessage| { &mut m.degreesClockwiseFromMagneticNorth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment",
            |m: &LocationMessage| { &m.comment },
            |m: &mut LocationMessage| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &LocationMessage| { &m.jpegThumbnail },
            |m: &mut LocationMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &LocationMessage| { &m.contextInfo },
            |m: &mut LocationMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocationMessage>(
            "LocationMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocationMessage {
    const NAME: &'static str = "LocationMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.degreesLatitude = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.degreesLongitude = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.address = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.isLive = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.accuracyInMeters = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.speedInMps = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.degreesLatitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.degreesLongitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.isLive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.accuracyInMeters {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.speedInMps {
            my_size += 1 + 4;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.degreesLatitude {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.degreesLongitude {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.isLive {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.accuracyInMeters {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.speedInMps {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocationMessage {
        LocationMessage::new()
    }

    fn clear(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
        self.degreesLongitude = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.address = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.isLive = ::std::option::Option::None;
        self.accuracyInMeters = ::std::option::Option::None;
        self.speedInMps = ::std::option::Option::None;
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocationMessage {
        static instance: LocationMessage = LocationMessage {
            degreesLatitude: ::std::option::Option::None,
            degreesLongitude: ::std::option::Option::None,
            name: ::std::option::Option::None,
            address: ::std::option::Option::None,
            url: ::std::option::Option::None,
            isLive: ::std::option::Option::None,
            accuracyInMeters: ::std::option::Option::None,
            speedInMps: ::std::option::Option::None,
            degreesClockwiseFromMagneticNorth: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocationMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocationMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ExtendedTextMessage)
pub struct ExtendedTextMessage {
    // message fields
    // @@protoc_insertion_point(field:ExtendedTextMessage.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.matchedText)
    pub matchedText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.canonicalUrl)
    pub canonicalUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.textArgb)
    pub textArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.backgroundArgb)
    pub backgroundArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.font)
    pub font: ::std::option::Option<::protobuf::EnumOrUnknown<extended_text_message::ExtendedTextMessageFontType>>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.previewType)
    pub previewType: ::std::option::Option<::protobuf::EnumOrUnknown<extended_text_message::ExtendedTextMessagePreviewType>>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.doNotPlayInline)
    pub doNotPlayInline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.thumbnailHeight)
    pub thumbnailHeight: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.thumbnailWidth)
    pub thumbnailWidth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ExtendedTextMessage.inviteLinkGroupType)
    pub inviteLinkGroupType: ::std::option::Option<::protobuf::EnumOrUnknown<extended_text_message::ExtendedTextMessageInviteLinkGroupType>>,
    // special fields
    // @@protoc_insertion_point(special_field:ExtendedTextMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtendedTextMessage {
    fn default() -> &'a ExtendedTextMessage {
        <ExtendedTextMessage as ::protobuf::Message>::default_instance()
    }
}

impl ExtendedTextMessage {
    pub fn new() -> ExtendedTextMessage {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchedText = 2;

    pub fn matchedText(&self) -> &str {
        match self.matchedText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchedText(&mut self) {
        self.matchedText = ::std::option::Option::None;
    }

    pub fn has_matchedText(&self) -> bool {
        self.matchedText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchedText(&mut self, v: ::std::string::String) {
        self.matchedText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchedText(&mut self) -> &mut ::std::string::String {
        if self.matchedText.is_none() {
            self.matchedText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchedText.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchedText(&mut self) -> ::std::string::String {
        self.matchedText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string canonicalUrl = 4;

    pub fn canonicalUrl(&self) -> &str {
        match self.canonicalUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_canonicalUrl(&mut self) {
        self.canonicalUrl = ::std::option::Option::None;
    }

    pub fn has_canonicalUrl(&self) -> bool {
        self.canonicalUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonicalUrl(&mut self, v: ::std::string::String) {
        self.canonicalUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonicalUrl(&mut self) -> &mut ::std::string::String {
        if self.canonicalUrl.is_none() {
            self.canonicalUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.canonicalUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonicalUrl(&mut self) -> ::std::string::String {
        self.canonicalUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 5;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 6;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 textArgb = 7;

    pub fn textArgb(&self) -> u32 {
        self.textArgb.unwrap_or(0)
    }

    pub fn clear_textArgb(&mut self) {
        self.textArgb = ::std::option::Option::None;
    }

    pub fn has_textArgb(&self) -> bool {
        self.textArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textArgb(&mut self, v: u32) {
        self.textArgb = ::std::option::Option::Some(v);
    }

    // optional fixed32 backgroundArgb = 8;

    pub fn backgroundArgb(&self) -> u32 {
        self.backgroundArgb.unwrap_or(0)
    }

    pub fn clear_backgroundArgb(&mut self) {
        self.backgroundArgb = ::std::option::Option::None;
    }

    pub fn has_backgroundArgb(&self) -> bool {
        self.backgroundArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backgroundArgb(&mut self, v: u32) {
        self.backgroundArgb = ::std::option::Option::Some(v);
    }

    // optional .ExtendedTextMessage.ExtendedTextMessageFontType font = 9;

    pub fn font(&self) -> extended_text_message::ExtendedTextMessageFontType {
        match self.font {
            Some(e) => e.enum_value_or(extended_text_message::ExtendedTextMessageFontType::SANS_SERIF),
            None => extended_text_message::ExtendedTextMessageFontType::SANS_SERIF,
        }
    }

    pub fn clear_font(&mut self) {
        self.font = ::std::option::Option::None;
    }

    pub fn has_font(&self) -> bool {
        self.font.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font(&mut self, v: extended_text_message::ExtendedTextMessageFontType) {
        self.font = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ExtendedTextMessage.ExtendedTextMessagePreviewType previewType = 10;

    pub fn previewType(&self) -> extended_text_message::ExtendedTextMessagePreviewType {
        match self.previewType {
            Some(e) => e.enum_value_or(extended_text_message::ExtendedTextMessagePreviewType::NONE),
            None => extended_text_message::ExtendedTextMessagePreviewType::NONE,
        }
    }

    pub fn clear_previewType(&mut self) {
        self.previewType = ::std::option::Option::None;
    }

    pub fn has_previewType(&self) -> bool {
        self.previewType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previewType(&mut self, v: extended_text_message::ExtendedTextMessagePreviewType) {
        self.previewType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool doNotPlayInline = 18;

    pub fn doNotPlayInline(&self) -> bool {
        self.doNotPlayInline.unwrap_or(false)
    }

    pub fn clear_doNotPlayInline(&mut self) {
        self.doNotPlayInline = ::std::option::Option::None;
    }

    pub fn has_doNotPlayInline(&self) -> bool {
        self.doNotPlayInline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doNotPlayInline(&mut self, v: bool) {
        self.doNotPlayInline = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 19;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 20;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 21;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mediaKey = 22;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 mediaKeyTimestamp = 23;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnailHeight = 24;

    pub fn thumbnailHeight(&self) -> u32 {
        self.thumbnailHeight.unwrap_or(0)
    }

    pub fn clear_thumbnailHeight(&mut self) {
        self.thumbnailHeight = ::std::option::Option::None;
    }

    pub fn has_thumbnailHeight(&self) -> bool {
        self.thumbnailHeight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailHeight(&mut self, v: u32) {
        self.thumbnailHeight = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnailWidth = 25;

    pub fn thumbnailWidth(&self) -> u32 {
        self.thumbnailWidth.unwrap_or(0)
    }

    pub fn clear_thumbnailWidth(&mut self) {
        self.thumbnailWidth = ::std::option::Option::None;
    }

    pub fn has_thumbnailWidth(&self) -> bool {
        self.thumbnailWidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailWidth(&mut self, v: u32) {
        self.thumbnailWidth = ::std::option::Option::Some(v);
    }

    // optional .ExtendedTextMessage.ExtendedTextMessageInviteLinkGroupType inviteLinkGroupType = 26;

    pub fn inviteLinkGroupType(&self) -> extended_text_message::ExtendedTextMessageInviteLinkGroupType {
        match self.inviteLinkGroupType {
            Some(e) => e.enum_value_or(extended_text_message::ExtendedTextMessageInviteLinkGroupType::DEFAULT),
            None => extended_text_message::ExtendedTextMessageInviteLinkGroupType::DEFAULT,
        }
    }

    pub fn clear_inviteLinkGroupType(&mut self) {
        self.inviteLinkGroupType = ::std::option::Option::None;
    }

    pub fn has_inviteLinkGroupType(&self) -> bool {
        self.inviteLinkGroupType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkGroupType(&mut self, v: extended_text_message::ExtendedTextMessageInviteLinkGroupType) {
        self.inviteLinkGroupType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &ExtendedTextMessage| { &m.text },
            |m: &mut ExtendedTextMessage| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchedText",
            |m: &ExtendedTextMessage| { &m.matchedText },
            |m: &mut ExtendedTextMessage| { &mut m.matchedText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "canonicalUrl",
            |m: &ExtendedTextMessage| { &m.canonicalUrl },
            |m: &mut ExtendedTextMessage| { &mut m.canonicalUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ExtendedTextMessage| { &m.description },
            |m: &mut ExtendedTextMessage| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ExtendedTextMessage| { &m.title },
            |m: &mut ExtendedTextMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "textArgb",
            |m: &ExtendedTextMessage| { &m.textArgb },
            |m: &mut ExtendedTextMessage| { &mut m.textArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backgroundArgb",
            |m: &ExtendedTextMessage| { &m.backgroundArgb },
            |m: &mut ExtendedTextMessage| { &mut m.backgroundArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font",
            |m: &ExtendedTextMessage| { &m.font },
            |m: &mut ExtendedTextMessage| { &mut m.font },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previewType",
            |m: &ExtendedTextMessage| { &m.previewType },
            |m: &mut ExtendedTextMessage| { &mut m.previewType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &ExtendedTextMessage| { &m.jpegThumbnail },
            |m: &mut ExtendedTextMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ExtendedTextMessage| { &m.contextInfo },
            |m: &mut ExtendedTextMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "doNotPlayInline",
            |m: &ExtendedTextMessage| { &m.doNotPlayInline },
            |m: &mut ExtendedTextMessage| { &mut m.doNotPlayInline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &ExtendedTextMessage| { &m.thumbnailDirectPath },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &ExtendedTextMessage| { &m.thumbnailSha256 },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &ExtendedTextMessage| { &m.thumbnailEncSha256 },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &ExtendedTextMessage| { &m.mediaKey },
            |m: &mut ExtendedTextMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &ExtendedTextMessage| { &m.mediaKeyTimestamp },
            |m: &mut ExtendedTextMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailHeight",
            |m: &ExtendedTextMessage| { &m.thumbnailHeight },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailWidth",
            |m: &ExtendedTextMessage| { &m.thumbnailWidth },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailWidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteLinkGroupType",
            |m: &ExtendedTextMessage| { &m.inviteLinkGroupType },
            |m: &mut ExtendedTextMessage| { &mut m.inviteLinkGroupType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtendedTextMessage>(
            "ExtendedTextMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExtendedTextMessage {
    const NAME: &'static str = "ExtendedTextMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.matchedText = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.canonicalUrl = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                61 => {
                    self.textArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.backgroundArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.font = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.previewType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                144 => {
                    self.doNotPlayInline = ::std::option::Option::Some(is.read_bool()?);
                },
                154 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                170 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                178 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                184 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                192 => {
                    self.thumbnailHeight = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.thumbnailWidth = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.inviteLinkGroupType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.matchedText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.textArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.backgroundArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.font {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.previewType {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.doNotPlayInline {
            my_size += 2 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(22, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(23, v);
        }
        if let Some(v) = self.thumbnailHeight {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.thumbnailWidth {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.inviteLinkGroupType {
            my_size += ::protobuf::rt::int32_size(26, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.matchedText.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.textArgb {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.backgroundArgb {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.font {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.previewType {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.doNotPlayInline {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(20, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(21, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(22, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(23, v)?;
        }
        if let Some(v) = self.thumbnailHeight {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.thumbnailWidth {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.inviteLinkGroupType {
            os.write_enum(26, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtendedTextMessage {
        ExtendedTextMessage::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.matchedText = ::std::option::Option::None;
        self.canonicalUrl = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.textArgb = ::std::option::Option::None;
        self.backgroundArgb = ::std::option::Option::None;
        self.font = ::std::option::Option::None;
        self.previewType = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.doNotPlayInline = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.thumbnailHeight = ::std::option::Option::None;
        self.thumbnailWidth = ::std::option::Option::None;
        self.inviteLinkGroupType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtendedTextMessage {
        static instance: ExtendedTextMessage = ExtendedTextMessage {
            text: ::std::option::Option::None,
            matchedText: ::std::option::Option::None,
            canonicalUrl: ::std::option::Option::None,
            description: ::std::option::Option::None,
            title: ::std::option::Option::None,
            textArgb: ::std::option::Option::None,
            backgroundArgb: ::std::option::Option::None,
            font: ::std::option::Option::None,
            previewType: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            doNotPlayInline: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            thumbnailHeight: ::std::option::Option::None,
            thumbnailWidth: ::std::option::Option::None,
            inviteLinkGroupType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExtendedTextMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtendedTextMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtendedTextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendedTextMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExtendedTextMessage`
pub mod extended_text_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ExtendedTextMessage.ExtendedTextMessageFontType)
    pub enum ExtendedTextMessageFontType {
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageFontType.SANS_SERIF)
        SANS_SERIF = 0,
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageFontType.SERIF)
        SERIF = 1,
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageFontType.NORICAN_REGULAR)
        NORICAN_REGULAR = 2,
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageFontType.BRYNDAN_WRITE)
        BRYNDAN_WRITE = 3,
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageFontType.BEBASNEUE_REGULAR)
        BEBASNEUE_REGULAR = 4,
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageFontType.OSWALD_HEAVY)
        OSWALD_HEAVY = 5,
    }

    impl ::protobuf::Enum for ExtendedTextMessageFontType {
        const NAME: &'static str = "ExtendedTextMessageFontType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ExtendedTextMessageFontType> {
            match value {
                0 => ::std::option::Option::Some(ExtendedTextMessageFontType::SANS_SERIF),
                1 => ::std::option::Option::Some(ExtendedTextMessageFontType::SERIF),
                2 => ::std::option::Option::Some(ExtendedTextMessageFontType::NORICAN_REGULAR),
                3 => ::std::option::Option::Some(ExtendedTextMessageFontType::BRYNDAN_WRITE),
                4 => ::std::option::Option::Some(ExtendedTextMessageFontType::BEBASNEUE_REGULAR),
                5 => ::std::option::Option::Some(ExtendedTextMessageFontType::OSWALD_HEAVY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ExtendedTextMessageFontType] = &[
            ExtendedTextMessageFontType::SANS_SERIF,
            ExtendedTextMessageFontType::SERIF,
            ExtendedTextMessageFontType::NORICAN_REGULAR,
            ExtendedTextMessageFontType::BRYNDAN_WRITE,
            ExtendedTextMessageFontType::BEBASNEUE_REGULAR,
            ExtendedTextMessageFontType::OSWALD_HEAVY,
        ];
    }

    impl ::protobuf::EnumFull for ExtendedTextMessageFontType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExtendedTextMessage.ExtendedTextMessageFontType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ExtendedTextMessageFontType {
        fn default() -> Self {
            ExtendedTextMessageFontType::SANS_SERIF
        }
    }

    impl ExtendedTextMessageFontType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ExtendedTextMessageFontType>("ExtendedTextMessage.ExtendedTextMessageFontType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ExtendedTextMessage.ExtendedTextMessagePreviewType)
    pub enum ExtendedTextMessagePreviewType {
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessagePreviewType.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessagePreviewType.VIDEO)
        VIDEO = 1,
    }

    impl ::protobuf::Enum for ExtendedTextMessagePreviewType {
        const NAME: &'static str = "ExtendedTextMessagePreviewType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ExtendedTextMessagePreviewType> {
            match value {
                0 => ::std::option::Option::Some(ExtendedTextMessagePreviewType::NONE),
                1 => ::std::option::Option::Some(ExtendedTextMessagePreviewType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ExtendedTextMessagePreviewType] = &[
            ExtendedTextMessagePreviewType::NONE,
            ExtendedTextMessagePreviewType::VIDEO,
        ];
    }

    impl ::protobuf::EnumFull for ExtendedTextMessagePreviewType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExtendedTextMessage.ExtendedTextMessagePreviewType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ExtendedTextMessagePreviewType {
        fn default() -> Self {
            ExtendedTextMessagePreviewType::NONE
        }
    }

    impl ExtendedTextMessagePreviewType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ExtendedTextMessagePreviewType>("ExtendedTextMessage.ExtendedTextMessagePreviewType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ExtendedTextMessage.ExtendedTextMessageInviteLinkGroupType)
    pub enum ExtendedTextMessageInviteLinkGroupType {
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageInviteLinkGroupType.DEFAULT)
        DEFAULT = 0,
        // @@protoc_insertion_point(enum_value:ExtendedTextMessage.ExtendedTextMessageInviteLinkGroupType.PARENT)
        PARENT = 1,
    }

    impl ::protobuf::Enum for ExtendedTextMessageInviteLinkGroupType {
        const NAME: &'static str = "ExtendedTextMessageInviteLinkGroupType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ExtendedTextMessageInviteLinkGroupType> {
            match value {
                0 => ::std::option::Option::Some(ExtendedTextMessageInviteLinkGroupType::DEFAULT),
                1 => ::std::option::Option::Some(ExtendedTextMessageInviteLinkGroupType::PARENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ExtendedTextMessageInviteLinkGroupType] = &[
            ExtendedTextMessageInviteLinkGroupType::DEFAULT,
            ExtendedTextMessageInviteLinkGroupType::PARENT,
        ];
    }

    impl ::protobuf::EnumFull for ExtendedTextMessageInviteLinkGroupType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExtendedTextMessage.ExtendedTextMessageInviteLinkGroupType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ExtendedTextMessageInviteLinkGroupType {
        fn default() -> Self {
            ExtendedTextMessageInviteLinkGroupType::DEFAULT
        }
    }

    impl ExtendedTextMessageInviteLinkGroupType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ExtendedTextMessageInviteLinkGroupType>("ExtendedTextMessage.ExtendedTextMessageInviteLinkGroupType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DocumentMessage)
pub struct DocumentMessage {
    // message fields
    // @@protoc_insertion_point(field:DocumentMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DocumentMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DocumentMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DocumentMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DocumentMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:DocumentMessage.pageCount)
    pub pageCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DocumentMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DocumentMessage.fileName)
    pub fileName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DocumentMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DocumentMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DocumentMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:DocumentMessage.contactVcard)
    pub contactVcard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DocumentMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DocumentMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DocumentMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DocumentMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:DocumentMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:DocumentMessage.thumbnailHeight)
    pub thumbnailHeight: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DocumentMessage.thumbnailWidth)
    pub thumbnailWidth: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:DocumentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DocumentMessage {
    fn default() -> &'a DocumentMessage {
        <DocumentMessage as ::protobuf::Message>::default_instance()
    }
}

impl DocumentMessage {
    pub fn new() -> DocumentMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 4;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 5;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 pageCount = 6;

    pub fn pageCount(&self) -> u32 {
        self.pageCount.unwrap_or(0)
    }

    pub fn clear_pageCount(&mut self) {
        self.pageCount = ::std::option::Option::None;
    }

    pub fn has_pageCount(&self) -> bool {
        self.pageCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageCount(&mut self, v: u32) {
        self.pageCount = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 7;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string fileName = 8;

    pub fn fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fileName(&mut self) {
        self.fileName = ::std::option::Option::None;
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileEncSha256 = 9;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 10;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 11;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool contactVcard = 12;

    pub fn contactVcard(&self) -> bool {
        self.contactVcard.unwrap_or(false)
    }

    pub fn clear_contactVcard(&mut self) {
        self.contactVcard = ::std::option::Option::None;
    }

    pub fn has_contactVcard(&self) -> bool {
        self.contactVcard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contactVcard(&mut self, v: bool) {
        self.contactVcard = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 13;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 14;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 15;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 thumbnailHeight = 18;

    pub fn thumbnailHeight(&self) -> u32 {
        self.thumbnailHeight.unwrap_or(0)
    }

    pub fn clear_thumbnailHeight(&mut self) {
        self.thumbnailHeight = ::std::option::Option::None;
    }

    pub fn has_thumbnailHeight(&self) -> bool {
        self.thumbnailHeight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailHeight(&mut self, v: u32) {
        self.thumbnailHeight = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnailWidth = 19;

    pub fn thumbnailWidth(&self) -> u32 {
        self.thumbnailWidth.unwrap_or(0)
    }

    pub fn clear_thumbnailWidth(&mut self) {
        self.thumbnailWidth = ::std::option::Option::None;
    }

    pub fn has_thumbnailWidth(&self) -> bool {
        self.thumbnailWidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailWidth(&mut self, v: u32) {
        self.thumbnailWidth = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &DocumentMessage| { &m.url },
            |m: &mut DocumentMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &DocumentMessage| { &m.mimetype },
            |m: &mut DocumentMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &DocumentMessage| { &m.title },
            |m: &mut DocumentMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &DocumentMessage| { &m.fileSha256 },
            |m: &mut DocumentMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &DocumentMessage| { &m.fileLength },
            |m: &mut DocumentMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageCount",
            |m: &DocumentMessage| { &m.pageCount },
            |m: &mut DocumentMessage| { &mut m.pageCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &DocumentMessage| { &m.mediaKey },
            |m: &mut DocumentMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileName",
            |m: &DocumentMessage| { &m.fileName },
            |m: &mut DocumentMessage| { &mut m.fileName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &DocumentMessage| { &m.fileEncSha256 },
            |m: &mut DocumentMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &DocumentMessage| { &m.directPath },
            |m: &mut DocumentMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &DocumentMessage| { &m.mediaKeyTimestamp },
            |m: &mut DocumentMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contactVcard",
            |m: &DocumentMessage| { &m.contactVcard },
            |m: &mut DocumentMessage| { &mut m.contactVcard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &DocumentMessage| { &m.thumbnailDirectPath },
            |m: &mut DocumentMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &DocumentMessage| { &m.thumbnailSha256 },
            |m: &mut DocumentMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &DocumentMessage| { &m.thumbnailEncSha256 },
            |m: &mut DocumentMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &DocumentMessage| { &m.jpegThumbnail },
            |m: &mut DocumentMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &DocumentMessage| { &m.contextInfo },
            |m: &mut DocumentMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailHeight",
            |m: &DocumentMessage| { &m.thumbnailHeight },
            |m: &mut DocumentMessage| { &mut m.thumbnailHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailWidth",
            |m: &DocumentMessage| { &m.thumbnailWidth },
            |m: &mut DocumentMessage| { &mut m.thumbnailWidth },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DocumentMessage>(
            "DocumentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DocumentMessage {
    const NAME: &'static str = "DocumentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.pageCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.fileName = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                82 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                96 => {
                    self.contactVcard = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                122 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                144 => {
                    self.thumbnailHeight = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.thumbnailWidth = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.pageCount {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(11, v);
        }
        if let Some(v) = self.contactVcard {
            my_size += 1 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(15, &v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.thumbnailHeight {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.thumbnailWidth {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.pageCount {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.fileName.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.contactVcard {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(15, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.thumbnailHeight {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.thumbnailWidth {
            os.write_uint32(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DocumentMessage {
        DocumentMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.pageCount = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileName = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.contactVcard = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.thumbnailHeight = ::std::option::Option::None;
        self.thumbnailWidth = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DocumentMessage {
        static instance: DocumentMessage = DocumentMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            title: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            pageCount: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileName: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            contactVcard: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            thumbnailHeight: ::std::option::Option::None,
            thumbnailWidth: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DocumentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DocumentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DocumentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AudioMessage)
pub struct AudioMessage {
    // message fields
    // @@protoc_insertion_point(field:AudioMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:AudioMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:AudioMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AudioMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:AudioMessage.seconds)
    pub seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AudioMessage.ptt)
    pub ptt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:AudioMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AudioMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AudioMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:AudioMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:AudioMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:AudioMessage.streamingSidecar)
    pub streamingSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AudioMessage.waveform)
    pub waveform: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:AudioMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioMessage {
    fn default() -> &'a AudioMessage {
        <AudioMessage as ::protobuf::Message>::default_instance()
    }
}

impl AudioMessage {
    pub fn new() -> AudioMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 3;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 4;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 5;

    pub fn seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional bool ptt = 6;

    pub fn ptt(&self) -> bool {
        self.ptt.unwrap_or(false)
    }

    pub fn clear_ptt(&mut self) {
        self.ptt = ::std::option::Option::None;
    }

    pub fn has_ptt(&self) -> bool {
        self.ptt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ptt(&mut self, v: bool) {
        self.ptt = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 7;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 8;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 9;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 10;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes streamingSidecar = 18;

    pub fn streamingSidecar(&self) -> &[u8] {
        match self.streamingSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_streamingSidecar(&mut self) {
        self.streamingSidecar = ::std::option::Option::None;
    }

    pub fn has_streamingSidecar(&self) -> bool {
        self.streamingSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streamingSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.streamingSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streamingSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.streamingSidecar.is_none() {
            self.streamingSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.streamingSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_streamingSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.streamingSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes waveform = 19;

    pub fn waveform(&self) -> &[u8] {
        match self.waveform.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_waveform(&mut self) {
        self.waveform = ::std::option::Option::None;
    }

    pub fn has_waveform(&self) -> bool {
        self.waveform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_waveform(&mut self, v: ::std::vec::Vec<u8>) {
        self.waveform = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_waveform(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.waveform.is_none() {
            self.waveform = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.waveform.as_mut().unwrap()
    }

    // Take field
    pub fn take_waveform(&mut self) -> ::std::vec::Vec<u8> {
        self.waveform.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &AudioMessage| { &m.url },
            |m: &mut AudioMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &AudioMessage| { &m.mimetype },
            |m: &mut AudioMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &AudioMessage| { &m.fileSha256 },
            |m: &mut AudioMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &AudioMessage| { &m.fileLength },
            |m: &mut AudioMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &AudioMessage| { &m.seconds },
            |m: &mut AudioMessage| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ptt",
            |m: &AudioMessage| { &m.ptt },
            |m: &mut AudioMessage| { &mut m.ptt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &AudioMessage| { &m.mediaKey },
            |m: &mut AudioMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &AudioMessage| { &m.fileEncSha256 },
            |m: &mut AudioMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &AudioMessage| { &m.directPath },
            |m: &mut AudioMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &AudioMessage| { &m.mediaKeyTimestamp },
            |m: &mut AudioMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &AudioMessage| { &m.contextInfo },
            |m: &mut AudioMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "streamingSidecar",
            |m: &AudioMessage| { &m.streamingSidecar },
            |m: &mut AudioMessage| { &mut m.streamingSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "waveform",
            |m: &AudioMessage| { &m.waveform },
            |m: &mut AudioMessage| { &mut m.waveform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioMessage>(
            "AudioMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioMessage {
    const NAME: &'static str = "AudioMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.ptt = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                146 => {
                    self.streamingSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                154 => {
                    self.waveform = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.ptt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.waveform.as_ref() {
            my_size += ::protobuf::rt::bytes_size(19, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ptt {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.waveform.as_ref() {
            os.write_bytes(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioMessage {
        AudioMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.ptt = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.contextInfo.clear();
        self.streamingSidecar = ::std::option::Option::None;
        self.waveform = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioMessage {
        static instance: AudioMessage = AudioMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            seconds: ::std::option::Option::None,
            ptt: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            streamingSidecar: ::std::option::Option::None,
            waveform: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:VideoMessage)
pub struct VideoMessage {
    // message fields
    // @@protoc_insertion_point(field:VideoMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VideoMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VideoMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VideoMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:VideoMessage.seconds)
    pub seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VideoMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VideoMessage.gifPlayback)
    pub gifPlayback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:VideoMessage.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoMessage.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:VideoMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VideoMessage.interactiveAnnotations)
    pub interactiveAnnotations: ::std::vec::Vec<InteractiveAnnotation>,
    // @@protoc_insertion_point(field:VideoMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VideoMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:VideoMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VideoMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:VideoMessage.streamingSidecar)
    pub streamingSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VideoMessage.gifAttribution)
    pub gifAttribution: ::std::option::Option<::protobuf::EnumOrUnknown<video_message::VideoMessageAttribution>>,
    // @@protoc_insertion_point(field:VideoMessage.viewOnce)
    pub viewOnce: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:VideoMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:VideoMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VideoMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:VideoMessage.staticUrl)
    pub staticUrl: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:VideoMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoMessage {
    fn default() -> &'a VideoMessage {
        <VideoMessage as ::protobuf::Message>::default_instance()
    }
}

impl VideoMessage {
    pub fn new() -> VideoMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 3;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 4;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 5;

    pub fn seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 6;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string caption = 7;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool gifPlayback = 8;

    pub fn gifPlayback(&self) -> bool {
        self.gifPlayback.unwrap_or(false)
    }

    pub fn clear_gifPlayback(&mut self) {
        self.gifPlayback = ::std::option::Option::None;
    }

    pub fn has_gifPlayback(&self) -> bool {
        self.gifPlayback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifPlayback(&mut self, v: bool) {
        self.gifPlayback = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 9;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 10;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional bytes fileEncSha256 = 11;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 13;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 14;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes streamingSidecar = 18;

    pub fn streamingSidecar(&self) -> &[u8] {
        match self.streamingSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_streamingSidecar(&mut self) {
        self.streamingSidecar = ::std::option::Option::None;
    }

    pub fn has_streamingSidecar(&self) -> bool {
        self.streamingSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streamingSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.streamingSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streamingSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.streamingSidecar.is_none() {
            self.streamingSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.streamingSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_streamingSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.streamingSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .VideoMessage.VideoMessageAttribution gifAttribution = 19;

    pub fn gifAttribution(&self) -> video_message::VideoMessageAttribution {
        match self.gifAttribution {
            Some(e) => e.enum_value_or(video_message::VideoMessageAttribution::NONE),
            None => video_message::VideoMessageAttribution::NONE,
        }
    }

    pub fn clear_gifAttribution(&mut self) {
        self.gifAttribution = ::std::option::Option::None;
    }

    pub fn has_gifAttribution(&self) -> bool {
        self.gifAttribution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifAttribution(&mut self, v: video_message::VideoMessageAttribution) {
        self.gifAttribution = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool viewOnce = 20;

    pub fn viewOnce(&self) -> bool {
        self.viewOnce.unwrap_or(false)
    }

    pub fn clear_viewOnce(&mut self) {
        self.viewOnce = ::std::option::Option::None;
    }

    pub fn has_viewOnce(&self) -> bool {
        self.viewOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewOnce(&mut self, v: bool) {
        self.viewOnce = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 21;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 22;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 23;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string staticUrl = 24;

    pub fn staticUrl(&self) -> &str {
        match self.staticUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_staticUrl(&mut self) {
        self.staticUrl = ::std::option::Option::None;
    }

    pub fn has_staticUrl(&self) -> bool {
        self.staticUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staticUrl(&mut self, v: ::std::string::String) {
        self.staticUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_staticUrl(&mut self) -> &mut ::std::string::String {
        if self.staticUrl.is_none() {
            self.staticUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.staticUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_staticUrl(&mut self) -> ::std::string::String {
        self.staticUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &VideoMessage| { &m.url },
            |m: &mut VideoMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &VideoMessage| { &m.mimetype },
            |m: &mut VideoMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &VideoMessage| { &m.fileSha256 },
            |m: &mut VideoMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &VideoMessage| { &m.fileLength },
            |m: &mut VideoMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &VideoMessage| { &m.seconds },
            |m: &mut VideoMessage| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &VideoMessage| { &m.mediaKey },
            |m: &mut VideoMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &VideoMessage| { &m.caption },
            |m: &mut VideoMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifPlayback",
            |m: &VideoMessage| { &m.gifPlayback },
            |m: &mut VideoMessage| { &mut m.gifPlayback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &VideoMessage| { &m.height },
            |m: &mut VideoMessage| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &VideoMessage| { &m.width },
            |m: &mut VideoMessage| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &VideoMessage| { &m.fileEncSha256 },
            |m: &mut VideoMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interactiveAnnotations",
            |m: &VideoMessage| { &m.interactiveAnnotations },
            |m: &mut VideoMessage| { &mut m.interactiveAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &VideoMessage| { &m.directPath },
            |m: &mut VideoMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &VideoMessage| { &m.mediaKeyTimestamp },
            |m: &mut VideoMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &VideoMessage| { &m.jpegThumbnail },
            |m: &mut VideoMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &VideoMessage| { &m.contextInfo },
            |m: &mut VideoMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "streamingSidecar",
            |m: &VideoMessage| { &m.streamingSidecar },
            |m: &mut VideoMessage| { &mut m.streamingSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifAttribution",
            |m: &VideoMessage| { &m.gifAttribution },
            |m: &mut VideoMessage| { &mut m.gifAttribution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewOnce",
            |m: &VideoMessage| { &m.viewOnce },
            |m: &mut VideoMessage| { &mut m.viewOnce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &VideoMessage| { &m.thumbnailDirectPath },
            |m: &mut VideoMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &VideoMessage| { &m.thumbnailSha256 },
            |m: &mut VideoMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &VideoMessage| { &m.thumbnailEncSha256 },
            |m: &mut VideoMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "staticUrl",
            |m: &VideoMessage| { &m.staticUrl },
            |m: &mut VideoMessage| { &mut m.staticUrl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoMessage>(
            "VideoMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoMessage {
    const NAME: &'static str = "VideoMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.gifPlayback = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                98 => {
                    self.interactiveAnnotations.push(is.read_message()?);
                },
                106 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                146 => {
                    self.streamingSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                152 => {
                    self.gifAttribution = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.viewOnce = ::std::option::Option::Some(is.read_bool()?);
                },
                170 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                186 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                194 => {
                    self.staticUrl = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gifPlayback {
            my_size += 1 + 1;
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        for value in &self.interactiveAnnotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.gifAttribution {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.viewOnce {
            my_size += 2 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(22, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(23, &v);
        }
        if let Some(v) = self.staticUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.gifPlayback {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(11, v)?;
        }
        for v in &self.interactiveAnnotations {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.gifAttribution {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.viewOnce {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(22, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(23, v)?;
        }
        if let Some(v) = self.staticUrl.as_ref() {
            os.write_string(24, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoMessage {
        VideoMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.gifPlayback = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.interactiveAnnotations.clear();
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.streamingSidecar = ::std::option::Option::None;
        self.gifAttribution = ::std::option::Option::None;
        self.viewOnce = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.staticUrl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoMessage {
        static instance: VideoMessage = VideoMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            seconds: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            gifPlayback: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            interactiveAnnotations: ::std::vec::Vec::new(),
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            streamingSidecar: ::std::option::Option::None,
            gifAttribution: ::std::option::Option::None,
            viewOnce: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            staticUrl: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VideoMessage`
pub mod video_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:VideoMessage.VideoMessageAttribution)
    pub enum VideoMessageAttribution {
        // @@protoc_insertion_point(enum_value:VideoMessage.VideoMessageAttribution.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:VideoMessage.VideoMessageAttribution.GIPHY)
        GIPHY = 1,
        // @@protoc_insertion_point(enum_value:VideoMessage.VideoMessageAttribution.TENOR)
        TENOR = 2,
    }

    impl ::protobuf::Enum for VideoMessageAttribution {
        const NAME: &'static str = "VideoMessageAttribution";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<VideoMessageAttribution> {
            match value {
                0 => ::std::option::Option::Some(VideoMessageAttribution::NONE),
                1 => ::std::option::Option::Some(VideoMessageAttribution::GIPHY),
                2 => ::std::option::Option::Some(VideoMessageAttribution::TENOR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [VideoMessageAttribution] = &[
            VideoMessageAttribution::NONE,
            VideoMessageAttribution::GIPHY,
            VideoMessageAttribution::TENOR,
        ];
    }

    impl ::protobuf::EnumFull for VideoMessageAttribution {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VideoMessage.VideoMessageAttribution").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for VideoMessageAttribution {
        fn default() -> Self {
            VideoMessageAttribution::NONE
        }
    }

    impl VideoMessageAttribution {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VideoMessageAttribution>("VideoMessage.VideoMessageAttribution")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Call)
pub struct Call {
    // message fields
    // @@protoc_insertion_point(field:Call.callKey)
    pub callKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:Call.conversionSource)
    pub conversionSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Call.conversionData)
    pub conversionData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:Call.conversionDelaySeconds)
    pub conversionDelaySeconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:Call.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Call {
    fn default() -> &'a Call {
        <Call as ::protobuf::Message>::default_instance()
    }
}

impl Call {
    pub fn new() -> Call {
        ::std::default::Default::default()
    }

    // optional bytes callKey = 1;

    pub fn callKey(&self) -> &[u8] {
        match self.callKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callKey(&mut self) {
        self.callKey = ::std::option::Option::None;
    }

    pub fn has_callKey(&self) -> bool {
        self.callKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.callKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callKey.is_none() {
            self.callKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.callKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_callKey(&mut self) -> ::std::vec::Vec<u8> {
        self.callKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string conversionSource = 2;

    pub fn conversionSource(&self) -> &str {
        match self.conversionSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conversionSource(&mut self) {
        self.conversionSource = ::std::option::Option::None;
    }

    pub fn has_conversionSource(&self) -> bool {
        self.conversionSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionSource(&mut self, v: ::std::string::String) {
        self.conversionSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionSource(&mut self) -> &mut ::std::string::String {
        if self.conversionSource.is_none() {
            self.conversionSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conversionSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionSource(&mut self) -> ::std::string::String {
        self.conversionSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes conversionData = 3;

    pub fn conversionData(&self) -> &[u8] {
        match self.conversionData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_conversionData(&mut self) {
        self.conversionData = ::std::option::Option::None;
    }

    pub fn has_conversionData(&self) -> bool {
        self.conversionData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionData(&mut self, v: ::std::vec::Vec<u8>) {
        self.conversionData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.conversionData.is_none() {
            self.conversionData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.conversionData.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionData(&mut self) -> ::std::vec::Vec<u8> {
        self.conversionData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 conversionDelaySeconds = 4;

    pub fn conversionDelaySeconds(&self) -> u32 {
        self.conversionDelaySeconds.unwrap_or(0)
    }

    pub fn clear_conversionDelaySeconds(&mut self) {
        self.conversionDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_conversionDelaySeconds(&self) -> bool {
        self.conversionDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionDelaySeconds(&mut self, v: u32) {
        self.conversionDelaySeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "callKey",
            |m: &Call| { &m.callKey },
            |m: &mut Call| { &mut m.callKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionSource",
            |m: &Call| { &m.conversionSource },
            |m: &mut Call| { &mut m.conversionSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionData",
            |m: &Call| { &m.conversionData },
            |m: &mut Call| { &mut m.conversionData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionDelaySeconds",
            |m: &Call| { &m.conversionDelaySeconds },
            |m: &mut Call| { &mut m.conversionDelaySeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Call>(
            "Call",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Call {
    const NAME: &'static str = "Call";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.callKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.conversionSource = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.conversionData = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.conversionDelaySeconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.callKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.conversionSource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.conversionData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.conversionDelaySeconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.callKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.conversionSource.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.conversionData.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.conversionDelaySeconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Call {
        Call::new()
    }

    fn clear(&mut self) {
        self.callKey = ::std::option::Option::None;
        self.conversionSource = ::std::option::Option::None;
        self.conversionData = ::std::option::Option::None;
        self.conversionDelaySeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Call {
        static instance: Call = Call {
            callKey: ::std::option::Option::None,
            conversionSource: ::std::option::Option::None,
            conversionData: ::std::option::Option::None,
            conversionDelaySeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Call {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Call").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Call {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Chat)
pub struct Chat {
    // message fields
    // @@protoc_insertion_point(field:Chat.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Chat.id)
    pub id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Chat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Chat {
    fn default() -> &'a Chat {
        <Chat as ::protobuf::Message>::default_instance()
    }
}

impl Chat {
    pub fn new() -> Chat {
        ::std::default::Default::default()
    }

    // optional string displayName = 1;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &Chat| { &m.displayName },
            |m: &mut Chat| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Chat| { &m.id },
            |m: &mut Chat| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Chat>(
            "Chat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Chat {
    const NAME: &'static str = "Chat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Chat {
        Chat::new()
    }

    fn clear(&mut self) {
        self.displayName = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Chat {
        static instance: Chat = Chat {
            displayName: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Chat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Chat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Chat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ProtocolMessage)
pub struct ProtocolMessage {
    // message fields
    // @@protoc_insertion_point(field:ProtocolMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:ProtocolMessage.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<protocol_message::ProtocolMessageType>>,
    // @@protoc_insertion_point(field:ProtocolMessage.ephemeralExpiration)
    pub ephemeralExpiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtocolMessage.ephemeralSettingTimestamp)
    pub ephemeralSettingTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtocolMessage.historySyncNotification)
    pub historySyncNotification: ::protobuf::MessageField<HistorySyncNotification>,
    // @@protoc_insertion_point(field:ProtocolMessage.appStateSyncKeyShare)
    pub appStateSyncKeyShare: ::protobuf::MessageField<AppStateSyncKeyShare>,
    // @@protoc_insertion_point(field:ProtocolMessage.appStateSyncKeyRequest)
    pub appStateSyncKeyRequest: ::protobuf::MessageField<AppStateSyncKeyRequest>,
    // @@protoc_insertion_point(field:ProtocolMessage.initialSecurityNotificationSettingSync)
    pub initialSecurityNotificationSettingSync: ::protobuf::MessageField<InitialSecurityNotificationSettingSync>,
    // @@protoc_insertion_point(field:ProtocolMessage.appStateFatalExceptionNotification)
    pub appStateFatalExceptionNotification: ::protobuf::MessageField<AppStateFatalExceptionNotification>,
    // @@protoc_insertion_point(field:ProtocolMessage.disappearingMode)
    pub disappearingMode: ::protobuf::MessageField<DisappearingMode>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtocolMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtocolMessage {
    fn default() -> &'a ProtocolMessage {
        <ProtocolMessage as ::protobuf::Message>::default_instance()
    }
}

impl ProtocolMessage {
    pub fn new() -> ProtocolMessage {
        ::std::default::Default::default()
    }

    // optional .ProtocolMessage.ProtocolMessageType type = 2;

    pub fn type_(&self) -> protocol_message::ProtocolMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(protocol_message::ProtocolMessageType::REVOKE),
            None => protocol_message::ProtocolMessageType::REVOKE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: protocol_message::ProtocolMessageType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 ephemeralExpiration = 4;

    pub fn ephemeralExpiration(&self) -> u32 {
        self.ephemeralExpiration.unwrap_or(0)
    }

    pub fn clear_ephemeralExpiration(&mut self) {
        self.ephemeralExpiration = ::std::option::Option::None;
    }

    pub fn has_ephemeralExpiration(&self) -> bool {
        self.ephemeralExpiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralExpiration(&mut self, v: u32) {
        self.ephemeralExpiration = ::std::option::Option::Some(v);
    }

    // optional int64 ephemeralSettingTimestamp = 5;

    pub fn ephemeralSettingTimestamp(&self) -> i64 {
        self.ephemeralSettingTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralSettingTimestamp(&mut self) {
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralSettingTimestamp(&self) -> bool {
        self.ephemeralSettingTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSettingTimestamp(&mut self, v: i64) {
        self.ephemeralSettingTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &ProtocolMessage| { &m.key },
            |m: &mut ProtocolMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ProtocolMessage| { &m.type_ },
            |m: &mut ProtocolMessage| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralExpiration",
            |m: &ProtocolMessage| { &m.ephemeralExpiration },
            |m: &mut ProtocolMessage| { &mut m.ephemeralExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSettingTimestamp",
            |m: &ProtocolMessage| { &m.ephemeralSettingTimestamp },
            |m: &mut ProtocolMessage| { &mut m.ephemeralSettingTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HistorySyncNotification>(
            "historySyncNotification",
            |m: &ProtocolMessage| { &m.historySyncNotification },
            |m: &mut ProtocolMessage| { &mut m.historySyncNotification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyShare>(
            "appStateSyncKeyShare",
            |m: &ProtocolMessage| { &m.appStateSyncKeyShare },
            |m: &mut ProtocolMessage| { &mut m.appStateSyncKeyShare },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyRequest>(
            "appStateSyncKeyRequest",
            |m: &ProtocolMessage| { &m.appStateSyncKeyRequest },
            |m: &mut ProtocolMessage| { &mut m.appStateSyncKeyRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InitialSecurityNotificationSettingSync>(
            "initialSecurityNotificationSettingSync",
            |m: &ProtocolMessage| { &m.initialSecurityNotificationSettingSync },
            |m: &mut ProtocolMessage| { &mut m.initialSecurityNotificationSettingSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateFatalExceptionNotification>(
            "appStateFatalExceptionNotification",
            |m: &ProtocolMessage| { &m.appStateFatalExceptionNotification },
            |m: &mut ProtocolMessage| { &mut m.appStateFatalExceptionNotification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DisappearingMode>(
            "disappearingMode",
            |m: &ProtocolMessage| { &m.disappearingMode },
            |m: &mut ProtocolMessage| { &mut m.disappearingMode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtocolMessage>(
            "ProtocolMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtocolMessage {
    const NAME: &'static str = "ProtocolMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.ephemeralExpiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ephemeralSettingTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.historySyncNotification)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appStateSyncKeyShare)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appStateSyncKeyRequest)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.initialSecurityNotificationSettingSync)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appStateFatalExceptionNotification)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.disappearingMode)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.ephemeralExpiration {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.historySyncNotification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appStateSyncKeyShare.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appStateSyncKeyRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.initialSecurityNotificationSettingSync.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appStateFatalExceptionNotification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeralExpiration {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.historySyncNotification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.appStateSyncKeyShare.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.appStateSyncKeyRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.initialSecurityNotificationSettingSync.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.appStateFatalExceptionNotification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtocolMessage {
        ProtocolMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.type_ = ::std::option::Option::None;
        self.ephemeralExpiration = ::std::option::Option::None;
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
        self.historySyncNotification.clear();
        self.appStateSyncKeyShare.clear();
        self.appStateSyncKeyRequest.clear();
        self.initialSecurityNotificationSettingSync.clear();
        self.appStateFatalExceptionNotification.clear();
        self.disappearingMode.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtocolMessage {
        static instance: ProtocolMessage = ProtocolMessage {
            key: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            ephemeralExpiration: ::std::option::Option::None,
            ephemeralSettingTimestamp: ::std::option::Option::None,
            historySyncNotification: ::protobuf::MessageField::none(),
            appStateSyncKeyShare: ::protobuf::MessageField::none(),
            appStateSyncKeyRequest: ::protobuf::MessageField::none(),
            initialSecurityNotificationSettingSync: ::protobuf::MessageField::none(),
            appStateFatalExceptionNotification: ::protobuf::MessageField::none(),
            disappearingMode: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtocolMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtocolMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtocolMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProtocolMessage`
pub mod protocol_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ProtocolMessage.ProtocolMessageType)
    pub enum ProtocolMessageType {
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.REVOKE)
        REVOKE = 0,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.EPHEMERAL_SETTING)
        EPHEMERAL_SETTING = 3,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.EPHEMERAL_SYNC_RESPONSE)
        EPHEMERAL_SYNC_RESPONSE = 4,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.HISTORY_SYNC_NOTIFICATION)
        HISTORY_SYNC_NOTIFICATION = 5,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.APP_STATE_SYNC_KEY_SHARE)
        APP_STATE_SYNC_KEY_SHARE = 6,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.APP_STATE_SYNC_KEY_REQUEST)
        APP_STATE_SYNC_KEY_REQUEST = 7,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.MSG_FANOUT_BACKFILL_REQUEST)
        MSG_FANOUT_BACKFILL_REQUEST = 8,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC)
        INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC = 9,
        // @@protoc_insertion_point(enum_value:ProtocolMessage.ProtocolMessageType.APP_STATE_FATAL_EXCEPTION_NOTIFICATION)
        APP_STATE_FATAL_EXCEPTION_NOTIFICATION = 10,
    }

    impl ::protobuf::Enum for ProtocolMessageType {
        const NAME: &'static str = "ProtocolMessageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ProtocolMessageType> {
            match value {
                0 => ::std::option::Option::Some(ProtocolMessageType::REVOKE),
                3 => ::std::option::Option::Some(ProtocolMessageType::EPHEMERAL_SETTING),
                4 => ::std::option::Option::Some(ProtocolMessageType::EPHEMERAL_SYNC_RESPONSE),
                5 => ::std::option::Option::Some(ProtocolMessageType::HISTORY_SYNC_NOTIFICATION),
                6 => ::std::option::Option::Some(ProtocolMessageType::APP_STATE_SYNC_KEY_SHARE),
                7 => ::std::option::Option::Some(ProtocolMessageType::APP_STATE_SYNC_KEY_REQUEST),
                8 => ::std::option::Option::Some(ProtocolMessageType::MSG_FANOUT_BACKFILL_REQUEST),
                9 => ::std::option::Option::Some(ProtocolMessageType::INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC),
                10 => ::std::option::Option::Some(ProtocolMessageType::APP_STATE_FATAL_EXCEPTION_NOTIFICATION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ProtocolMessageType] = &[
            ProtocolMessageType::REVOKE,
            ProtocolMessageType::EPHEMERAL_SETTING,
            ProtocolMessageType::EPHEMERAL_SYNC_RESPONSE,
            ProtocolMessageType::HISTORY_SYNC_NOTIFICATION,
            ProtocolMessageType::APP_STATE_SYNC_KEY_SHARE,
            ProtocolMessageType::APP_STATE_SYNC_KEY_REQUEST,
            ProtocolMessageType::MSG_FANOUT_BACKFILL_REQUEST,
            ProtocolMessageType::INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC,
            ProtocolMessageType::APP_STATE_FATAL_EXCEPTION_NOTIFICATION,
        ];
    }

    impl ::protobuf::EnumFull for ProtocolMessageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ProtocolMessage.ProtocolMessageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ProtocolMessageType::REVOKE => 0,
                ProtocolMessageType::EPHEMERAL_SETTING => 1,
                ProtocolMessageType::EPHEMERAL_SYNC_RESPONSE => 2,
                ProtocolMessageType::HISTORY_SYNC_NOTIFICATION => 3,
                ProtocolMessageType::APP_STATE_SYNC_KEY_SHARE => 4,
                ProtocolMessageType::APP_STATE_SYNC_KEY_REQUEST => 5,
                ProtocolMessageType::MSG_FANOUT_BACKFILL_REQUEST => 6,
                ProtocolMessageType::INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC => 7,
                ProtocolMessageType::APP_STATE_FATAL_EXCEPTION_NOTIFICATION => 8,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ProtocolMessageType {
        fn default() -> Self {
            ProtocolMessageType::REVOKE
        }
    }

    impl ProtocolMessageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtocolMessageType>("ProtocolMessage.ProtocolMessageType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HistorySyncNotification)
pub struct HistorySyncNotification {
    // message fields
    // @@protoc_insertion_point(field:HistorySyncNotification.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:HistorySyncNotification.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:HistorySyncNotification.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:HistorySyncNotification.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:HistorySyncNotification.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HistorySyncNotification.syncType)
    pub syncType: ::std::option::Option<::protobuf::EnumOrUnknown<history_sync_notification::HistorySyncNotificationHistorySyncType>>,
    // @@protoc_insertion_point(field:HistorySyncNotification.chunkOrder)
    pub chunkOrder: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HistorySyncNotification.originalMessageId)
    pub originalMessageId: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:HistorySyncNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistorySyncNotification {
    fn default() -> &'a HistorySyncNotification {
        <HistorySyncNotification as ::protobuf::Message>::default_instance()
    }
}

impl HistorySyncNotification {
    pub fn new() -> HistorySyncNotification {
        ::std::default::Default::default()
    }

    // optional bytes fileSha256 = 1;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 2;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 3;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 4;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 5;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .HistorySyncNotification.HistorySyncNotificationHistorySyncType syncType = 6;

    pub fn syncType(&self) -> history_sync_notification::HistorySyncNotificationHistorySyncType {
        match self.syncType {
            Some(e) => e.enum_value_or(history_sync_notification::HistorySyncNotificationHistorySyncType::INITIAL_BOOTSTRAP),
            None => history_sync_notification::HistorySyncNotificationHistorySyncType::INITIAL_BOOTSTRAP,
        }
    }

    pub fn clear_syncType(&mut self) {
        self.syncType = ::std::option::Option::None;
    }

    pub fn has_syncType(&self) -> bool {
        self.syncType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncType(&mut self, v: history_sync_notification::HistorySyncNotificationHistorySyncType) {
        self.syncType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 chunkOrder = 7;

    pub fn chunkOrder(&self) -> u32 {
        self.chunkOrder.unwrap_or(0)
    }

    pub fn clear_chunkOrder(&mut self) {
        self.chunkOrder = ::std::option::Option::None;
    }

    pub fn has_chunkOrder(&self) -> bool {
        self.chunkOrder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunkOrder(&mut self, v: u32) {
        self.chunkOrder = ::std::option::Option::Some(v);
    }

    // optional string originalMessageId = 8;

    pub fn originalMessageId(&self) -> &str {
        match self.originalMessageId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_originalMessageId(&mut self) {
        self.originalMessageId = ::std::option::Option::None;
    }

    pub fn has_originalMessageId(&self) -> bool {
        self.originalMessageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_originalMessageId(&mut self, v: ::std::string::String) {
        self.originalMessageId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originalMessageId(&mut self) -> &mut ::std::string::String {
        if self.originalMessageId.is_none() {
            self.originalMessageId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.originalMessageId.as_mut().unwrap()
    }

    // Take field
    pub fn take_originalMessageId(&mut self) -> ::std::string::String {
        self.originalMessageId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &HistorySyncNotification| { &m.fileSha256 },
            |m: &mut HistorySyncNotification| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &HistorySyncNotification| { &m.fileLength },
            |m: &mut HistorySyncNotification| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &HistorySyncNotification| { &m.mediaKey },
            |m: &mut HistorySyncNotification| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &HistorySyncNotification| { &m.fileEncSha256 },
            |m: &mut HistorySyncNotification| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &HistorySyncNotification| { &m.directPath },
            |m: &mut HistorySyncNotification| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "syncType",
            |m: &HistorySyncNotification| { &m.syncType },
            |m: &mut HistorySyncNotification| { &mut m.syncType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunkOrder",
            |m: &HistorySyncNotification| { &m.chunkOrder },
            |m: &mut HistorySyncNotification| { &mut m.chunkOrder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "originalMessageId",
            |m: &HistorySyncNotification| { &m.originalMessageId },
            |m: &mut HistorySyncNotification| { &mut m.originalMessageId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistorySyncNotification>(
            "HistorySyncNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistorySyncNotification {
    const NAME: &'static str = "HistorySyncNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.syncType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.chunkOrder = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.originalMessageId = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.syncType {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.chunkOrder {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.originalMessageId.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.syncType {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.chunkOrder {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.originalMessageId.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistorySyncNotification {
        HistorySyncNotification::new()
    }

    fn clear(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.syncType = ::std::option::Option::None;
        self.chunkOrder = ::std::option::Option::None;
        self.originalMessageId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistorySyncNotification {
        static instance: HistorySyncNotification = HistorySyncNotification {
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            syncType: ::std::option::Option::None,
            chunkOrder: ::std::option::Option::None,
            originalMessageId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistorySyncNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistorySyncNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistorySyncNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistorySyncNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HistorySyncNotification`
pub mod history_sync_notification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:HistorySyncNotification.HistorySyncNotificationHistorySyncType)
    pub enum HistorySyncNotificationHistorySyncType {
        // @@protoc_insertion_point(enum_value:HistorySyncNotification.HistorySyncNotificationHistorySyncType.INITIAL_BOOTSTRAP)
        INITIAL_BOOTSTRAP = 0,
        // @@protoc_insertion_point(enum_value:HistorySyncNotification.HistorySyncNotificationHistorySyncType.INITIAL_STATUS_V3)
        INITIAL_STATUS_V3 = 1,
        // @@protoc_insertion_point(enum_value:HistorySyncNotification.HistorySyncNotificationHistorySyncType.FULL)
        FULL = 2,
        // @@protoc_insertion_point(enum_value:HistorySyncNotification.HistorySyncNotificationHistorySyncType.RECENT)
        RECENT = 3,
        // @@protoc_insertion_point(enum_value:HistorySyncNotification.HistorySyncNotificationHistorySyncType.PUSH_NAME)
        PUSH_NAME = 4,
    }

    impl ::protobuf::Enum for HistorySyncNotificationHistorySyncType {
        const NAME: &'static str = "HistorySyncNotificationHistorySyncType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HistorySyncNotificationHistorySyncType> {
            match value {
                0 => ::std::option::Option::Some(HistorySyncNotificationHistorySyncType::INITIAL_BOOTSTRAP),
                1 => ::std::option::Option::Some(HistorySyncNotificationHistorySyncType::INITIAL_STATUS_V3),
                2 => ::std::option::Option::Some(HistorySyncNotificationHistorySyncType::FULL),
                3 => ::std::option::Option::Some(HistorySyncNotificationHistorySyncType::RECENT),
                4 => ::std::option::Option::Some(HistorySyncNotificationHistorySyncType::PUSH_NAME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HistorySyncNotificationHistorySyncType] = &[
            HistorySyncNotificationHistorySyncType::INITIAL_BOOTSTRAP,
            HistorySyncNotificationHistorySyncType::INITIAL_STATUS_V3,
            HistorySyncNotificationHistorySyncType::FULL,
            HistorySyncNotificationHistorySyncType::RECENT,
            HistorySyncNotificationHistorySyncType::PUSH_NAME,
        ];
    }

    impl ::protobuf::EnumFull for HistorySyncNotificationHistorySyncType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HistorySyncNotification.HistorySyncNotificationHistorySyncType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for HistorySyncNotificationHistorySyncType {
        fn default() -> Self {
            HistorySyncNotificationHistorySyncType::INITIAL_BOOTSTRAP
        }
    }

    impl HistorySyncNotificationHistorySyncType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HistorySyncNotificationHistorySyncType>("HistorySyncNotification.HistorySyncNotificationHistorySyncType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppStateSyncKey)
pub struct AppStateSyncKey {
    // message fields
    // @@protoc_insertion_point(field:AppStateSyncKey.keyId)
    pub keyId: ::protobuf::MessageField<AppStateSyncKeyId>,
    // @@protoc_insertion_point(field:AppStateSyncKey.keyData)
    pub keyData: ::protobuf::MessageField<AppStateSyncKeyData>,
    // special fields
    // @@protoc_insertion_point(special_field:AppStateSyncKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKey {
    fn default() -> &'a AppStateSyncKey {
        <AppStateSyncKey as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKey {
    pub fn new() -> AppStateSyncKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyId>(
            "keyId",
            |m: &AppStateSyncKey| { &m.keyId },
            |m: &mut AppStateSyncKey| { &mut m.keyId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyData>(
            "keyData",
            |m: &AppStateSyncKey| { &m.keyData },
            |m: &mut AppStateSyncKey| { &mut m.keyData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKey>(
            "AppStateSyncKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKey {
    const NAME: &'static str = "AppStateSyncKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keyData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.keyData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKey {
        AppStateSyncKey::new()
    }

    fn clear(&mut self) {
        self.keyId.clear();
        self.keyData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKey {
        static instance: AppStateSyncKey = AppStateSyncKey {
            keyId: ::protobuf::MessageField::none(),
            keyData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppStateSyncKeyId)
pub struct AppStateSyncKeyId {
    // message fields
    // @@protoc_insertion_point(field:AppStateSyncKeyId.keyId)
    pub keyId: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:AppStateSyncKeyId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyId {
    fn default() -> &'a AppStateSyncKeyId {
        <AppStateSyncKeyId as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyId {
    pub fn new() -> AppStateSyncKeyId {
        ::std::default::Default::default()
    }

    // optional bytes keyId = 1;

    pub fn keyId(&self) -> &[u8] {
        match self.keyId.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_keyId(&mut self) {
        self.keyId = ::std::option::Option::None;
    }

    pub fn has_keyId(&self) -> bool {
        self.keyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyId(&mut self, v: ::std::vec::Vec<u8>) {
        self.keyId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.keyId.is_none() {
            self.keyId = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.keyId.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyId(&mut self) -> ::std::vec::Vec<u8> {
        self.keyId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyId",
            |m: &AppStateSyncKeyId| { &m.keyId },
            |m: &mut AppStateSyncKeyId| { &mut m.keyId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyId>(
            "AppStateSyncKeyId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyId {
    const NAME: &'static str = "AppStateSyncKeyId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyId = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyId.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyId {
        AppStateSyncKeyId::new()
    }

    fn clear(&mut self) {
        self.keyId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyId {
        static instance: AppStateSyncKeyId = AppStateSyncKeyId {
            keyId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppStateSyncKeyFingerprint)
pub struct AppStateSyncKeyFingerprint {
    // message fields
    // @@protoc_insertion_point(field:AppStateSyncKeyFingerprint.rawId)
    pub rawId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AppStateSyncKeyFingerprint.currentIndex)
    pub currentIndex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AppStateSyncKeyFingerprint.deviceIndexes)
    pub deviceIndexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:AppStateSyncKeyFingerprint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyFingerprint {
    fn default() -> &'a AppStateSyncKeyFingerprint {
        <AppStateSyncKeyFingerprint as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyFingerprint {
    pub fn new() -> AppStateSyncKeyFingerprint {
        ::std::default::Default::default()
    }

    // optional uint32 rawId = 1;

    pub fn rawId(&self) -> u32 {
        self.rawId.unwrap_or(0)
    }

    pub fn clear_rawId(&mut self) {
        self.rawId = ::std::option::Option::None;
    }

    pub fn has_rawId(&self) -> bool {
        self.rawId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawId(&mut self, v: u32) {
        self.rawId = ::std::option::Option::Some(v);
    }

    // optional uint32 currentIndex = 2;

    pub fn currentIndex(&self) -> u32 {
        self.currentIndex.unwrap_or(0)
    }

    pub fn clear_currentIndex(&mut self) {
        self.currentIndex = ::std::option::Option::None;
    }

    pub fn has_currentIndex(&self) -> bool {
        self.currentIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentIndex(&mut self, v: u32) {
        self.currentIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rawId",
            |m: &AppStateSyncKeyFingerprint| { &m.rawId },
            |m: &mut AppStateSyncKeyFingerprint| { &mut m.rawId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentIndex",
            |m: &AppStateSyncKeyFingerprint| { &m.currentIndex },
            |m: &mut AppStateSyncKeyFingerprint| { &mut m.currentIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deviceIndexes",
            |m: &AppStateSyncKeyFingerprint| { &m.deviceIndexes },
            |m: &mut AppStateSyncKeyFingerprint| { &mut m.deviceIndexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyFingerprint>(
            "AppStateSyncKeyFingerprint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyFingerprint {
    const NAME: &'static str = "AppStateSyncKeyFingerprint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rawId = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.currentIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.deviceIndexes)?;
                },
                24 => {
                    self.deviceIndexes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rawId {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.currentIndex {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.deviceIndexes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rawId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currentIndex {
            os.write_uint32(2, v)?;
        }
        os.write_repeated_packed_uint32(3, &self.deviceIndexes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyFingerprint {
        AppStateSyncKeyFingerprint::new()
    }

    fn clear(&mut self) {
        self.rawId = ::std::option::Option::None;
        self.currentIndex = ::std::option::Option::None;
        self.deviceIndexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyFingerprint {
        static instance: AppStateSyncKeyFingerprint = AppStateSyncKeyFingerprint {
            rawId: ::std::option::Option::None,
            currentIndex: ::std::option::Option::None,
            deviceIndexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyFingerprint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyFingerprint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyFingerprint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyFingerprint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppStateSyncKeyData)
pub struct AppStateSyncKeyData {
    // message fields
    // @@protoc_insertion_point(field:AppStateSyncKeyData.keyData)
    pub keyData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:AppStateSyncKeyData.fingerprint)
    pub fingerprint: ::protobuf::MessageField<AppStateSyncKeyFingerprint>,
    // @@protoc_insertion_point(field:AppStateSyncKeyData.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:AppStateSyncKeyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyData {
    fn default() -> &'a AppStateSyncKeyData {
        <AppStateSyncKeyData as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyData {
    pub fn new() -> AppStateSyncKeyData {
        ::std::default::Default::default()
    }

    // optional bytes keyData = 1;

    pub fn keyData(&self) -> &[u8] {
        match self.keyData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_keyData(&mut self) {
        self.keyData = ::std::option::Option::None;
    }

    pub fn has_keyData(&self) -> bool {
        self.keyData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyData(&mut self, v: ::std::vec::Vec<u8>) {
        self.keyData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.keyData.is_none() {
            self.keyData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.keyData.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyData(&mut self) -> ::std::vec::Vec<u8> {
        self.keyData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 timestamp = 3;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyData",
            |m: &AppStateSyncKeyData| { &m.keyData },
            |m: &mut AppStateSyncKeyData| { &mut m.keyData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyFingerprint>(
            "fingerprint",
            |m: &AppStateSyncKeyData| { &m.fingerprint },
            |m: &mut AppStateSyncKeyData| { &mut m.fingerprint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &AppStateSyncKeyData| { &m.timestamp },
            |m: &mut AppStateSyncKeyData| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyData>(
            "AppStateSyncKeyData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyData {
    const NAME: &'static str = "AppStateSyncKeyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyData = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fingerprint)?;
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.fingerprint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyData.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.fingerprint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyData {
        AppStateSyncKeyData::new()
    }

    fn clear(&mut self) {
        self.keyData = ::std::option::Option::None;
        self.fingerprint.clear();
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyData {
        static instance: AppStateSyncKeyData = AppStateSyncKeyData {
            keyData: ::std::option::Option::None,
            fingerprint: ::protobuf::MessageField::none(),
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppStateSyncKeyShare)
pub struct AppStateSyncKeyShare {
    // message fields
    // @@protoc_insertion_point(field:AppStateSyncKeyShare.keys)
    pub keys: ::std::vec::Vec<AppStateSyncKey>,
    // special fields
    // @@protoc_insertion_point(special_field:AppStateSyncKeyShare.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyShare {
    fn default() -> &'a AppStateSyncKeyShare {
        <AppStateSyncKeyShare as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyShare {
    pub fn new() -> AppStateSyncKeyShare {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &AppStateSyncKeyShare| { &m.keys },
            |m: &mut AppStateSyncKeyShare| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyShare>(
            "AppStateSyncKeyShare",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyShare {
    const NAME: &'static str = "AppStateSyncKeyShare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyShare {
        AppStateSyncKeyShare::new()
    }

    fn clear(&mut self) {
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyShare {
        static instance: AppStateSyncKeyShare = AppStateSyncKeyShare {
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyShare {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyShare").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyShare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyShare {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppStateSyncKeyRequest)
pub struct AppStateSyncKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:AppStateSyncKeyRequest.keyIds)
    pub keyIds: ::std::vec::Vec<AppStateSyncKeyId>,
    // special fields
    // @@protoc_insertion_point(special_field:AppStateSyncKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyRequest {
    fn default() -> &'a AppStateSyncKeyRequest {
        <AppStateSyncKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyRequest {
    pub fn new() -> AppStateSyncKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keyIds",
            |m: &AppStateSyncKeyRequest| { &m.keyIds },
            |m: &mut AppStateSyncKeyRequest| { &mut m.keyIds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyRequest>(
            "AppStateSyncKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyRequest {
    const NAME: &'static str = "AppStateSyncKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyIds.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keyIds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.keyIds {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyRequest {
        AppStateSyncKeyRequest::new()
    }

    fn clear(&mut self) {
        self.keyIds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyRequest {
        static instance: AppStateSyncKeyRequest = AppStateSyncKeyRequest {
            keyIds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AppStateFatalExceptionNotification)
pub struct AppStateFatalExceptionNotification {
    // message fields
    // @@protoc_insertion_point(field:AppStateFatalExceptionNotification.collectionNames)
    pub collectionNames: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:AppStateFatalExceptionNotification.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:AppStateFatalExceptionNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateFatalExceptionNotification {
    fn default() -> &'a AppStateFatalExceptionNotification {
        <AppStateFatalExceptionNotification as ::protobuf::Message>::default_instance()
    }
}

impl AppStateFatalExceptionNotification {
    pub fn new() -> AppStateFatalExceptionNotification {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectionNames",
            |m: &AppStateFatalExceptionNotification| { &m.collectionNames },
            |m: &mut AppStateFatalExceptionNotification| { &mut m.collectionNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &AppStateFatalExceptionNotification| { &m.timestamp },
            |m: &mut AppStateFatalExceptionNotification| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateFatalExceptionNotification>(
            "AppStateFatalExceptionNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateFatalExceptionNotification {
    const NAME: &'static str = "AppStateFatalExceptionNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.collectionNames.push(is.read_string()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.collectionNames {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.collectionNames {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateFatalExceptionNotification {
        AppStateFatalExceptionNotification::new()
    }

    fn clear(&mut self) {
        self.collectionNames.clear();
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateFatalExceptionNotification {
        static instance: AppStateFatalExceptionNotification = AppStateFatalExceptionNotification {
            collectionNames: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateFatalExceptionNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateFatalExceptionNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateFatalExceptionNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateFatalExceptionNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:InitialSecurityNotificationSettingSync)
pub struct InitialSecurityNotificationSettingSync {
    // message fields
    // @@protoc_insertion_point(field:InitialSecurityNotificationSettingSync.securityNotificationEnabled)
    pub securityNotificationEnabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:InitialSecurityNotificationSettingSync.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InitialSecurityNotificationSettingSync {
    fn default() -> &'a InitialSecurityNotificationSettingSync {
        <InitialSecurityNotificationSettingSync as ::protobuf::Message>::default_instance()
    }
}

impl InitialSecurityNotificationSettingSync {
    pub fn new() -> InitialSecurityNotificationSettingSync {
        ::std::default::Default::default()
    }

    // optional bool securityNotificationEnabled = 1;

    pub fn securityNotificationEnabled(&self) -> bool {
        self.securityNotificationEnabled.unwrap_or(false)
    }

    pub fn clear_securityNotificationEnabled(&mut self) {
        self.securityNotificationEnabled = ::std::option::Option::None;
    }

    pub fn has_securityNotificationEnabled(&self) -> bool {
        self.securityNotificationEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityNotificationEnabled(&mut self, v: bool) {
        self.securityNotificationEnabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "securityNotificationEnabled",
            |m: &InitialSecurityNotificationSettingSync| { &m.securityNotificationEnabled },
            |m: &mut InitialSecurityNotificationSettingSync| { &mut m.securityNotificationEnabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitialSecurityNotificationSettingSync>(
            "InitialSecurityNotificationSettingSync",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InitialSecurityNotificationSettingSync {
    const NAME: &'static str = "InitialSecurityNotificationSettingSync";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.securityNotificationEnabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.securityNotificationEnabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.securityNotificationEnabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InitialSecurityNotificationSettingSync {
        InitialSecurityNotificationSettingSync::new()
    }

    fn clear(&mut self) {
        self.securityNotificationEnabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InitialSecurityNotificationSettingSync {
        static instance: InitialSecurityNotificationSettingSync = InitialSecurityNotificationSettingSync {
            securityNotificationEnabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InitialSecurityNotificationSettingSync {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InitialSecurityNotificationSettingSync").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InitialSecurityNotificationSettingSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitialSecurityNotificationSettingSync {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ContactsArrayMessage)
pub struct ContactsArrayMessage {
    // message fields
    // @@protoc_insertion_point(field:ContactsArrayMessage.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ContactsArrayMessage.contacts)
    pub contacts: ::std::vec::Vec<ContactMessage>,
    // @@protoc_insertion_point(field:ContactsArrayMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ContactsArrayMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactsArrayMessage {
    fn default() -> &'a ContactsArrayMessage {
        <ContactsArrayMessage as ::protobuf::Message>::default_instance()
    }
}

impl ContactsArrayMessage {
    pub fn new() -> ContactsArrayMessage {
        ::std::default::Default::default()
    }

    // optional string displayName = 1;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &ContactsArrayMessage| { &m.displayName },
            |m: &mut ContactsArrayMessage| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contacts",
            |m: &ContactsArrayMessage| { &m.contacts },
            |m: &mut ContactsArrayMessage| { &mut m.contacts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ContactsArrayMessage| { &m.contextInfo },
            |m: &mut ContactsArrayMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactsArrayMessage>(
            "ContactsArrayMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactsArrayMessage {
    const NAME: &'static str = "ContactsArrayMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.contacts.push(is.read_message()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.contacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.contacts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactsArrayMessage {
        ContactsArrayMessage::new()
    }

    fn clear(&mut self) {
        self.displayName = ::std::option::Option::None;
        self.contacts.clear();
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactsArrayMessage {
        static instance: ContactsArrayMessage = ContactsArrayMessage {
            displayName: ::std::option::Option::None,
            contacts: ::std::vec::Vec::new(),
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactsArrayMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactsArrayMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactsArrayMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactsArrayMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HSMCurrency)
pub struct HSMCurrency {
    // message fields
    // @@protoc_insertion_point(field:HSMCurrency.currencyCode)
    pub currencyCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HSMCurrency.amount1000)
    pub amount1000: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:HSMCurrency.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HSMCurrency {
    fn default() -> &'a HSMCurrency {
        <HSMCurrency as ::protobuf::Message>::default_instance()
    }
}

impl HSMCurrency {
    pub fn new() -> HSMCurrency {
        ::std::default::Default::default()
    }

    // optional string currencyCode = 1;

    pub fn currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currencyCode(&mut self) {
        self.currencyCode = ::std::option::Option::None;
    }

    pub fn has_currencyCode(&self) -> bool {
        self.currencyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyCode(&mut self, v: ::std::string::String) {
        self.currencyCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currencyCode(&mut self) -> &mut ::std::string::String {
        if self.currencyCode.is_none() {
            self.currencyCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currencyCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_currencyCode(&mut self) -> ::std::string::String {
        self.currencyCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 amount1000 = 2;

    pub fn amount1000(&self) -> i64 {
        self.amount1000.unwrap_or(0)
    }

    pub fn clear_amount1000(&mut self) {
        self.amount1000 = ::std::option::Option::None;
    }

    pub fn has_amount1000(&self) -> bool {
        self.amount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount1000(&mut self, v: i64) {
        self.amount1000 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyCode",
            |m: &HSMCurrency| { &m.currencyCode },
            |m: &mut HSMCurrency| { &mut m.currencyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount1000",
            |m: &HSMCurrency| { &m.amount1000 },
            |m: &mut HSMCurrency| { &mut m.amount1000 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMCurrency>(
            "HSMCurrency",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HSMCurrency {
    const NAME: &'static str = "HSMCurrency";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.currencyCode = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.amount1000 = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.amount1000 {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.amount1000 {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HSMCurrency {
        HSMCurrency::new()
    }

    fn clear(&mut self) {
        self.currencyCode = ::std::option::Option::None;
        self.amount1000 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HSMCurrency {
        static instance: HSMCurrency = HSMCurrency {
            currencyCode: ::std::option::Option::None,
            amount1000: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HSMCurrency {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HSMCurrency").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HSMCurrency {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HSMCurrency {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HSMDateTimeComponent)
pub struct HSMDateTimeComponent {
    // message fields
    // @@protoc_insertion_point(field:HSMDateTimeComponent.dayOfWeek)
    pub dayOfWeek: ::std::option::Option<::protobuf::EnumOrUnknown<hsmdate_time_component::HSMDateTimeComponentDayOfWeekType>>,
    // @@protoc_insertion_point(field:HSMDateTimeComponent.year)
    pub year: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HSMDateTimeComponent.month)
    pub month: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HSMDateTimeComponent.dayOfMonth)
    pub dayOfMonth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HSMDateTimeComponent.hour)
    pub hour: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HSMDateTimeComponent.minute)
    pub minute: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:HSMDateTimeComponent.calendar)
    pub calendar: ::std::option::Option<::protobuf::EnumOrUnknown<hsmdate_time_component::HSMDateTimeComponentCalendarType>>,
    // special fields
    // @@protoc_insertion_point(special_field:HSMDateTimeComponent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HSMDateTimeComponent {
    fn default() -> &'a HSMDateTimeComponent {
        <HSMDateTimeComponent as ::protobuf::Message>::default_instance()
    }
}

impl HSMDateTimeComponent {
    pub fn new() -> HSMDateTimeComponent {
        ::std::default::Default::default()
    }

    // optional .HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType dayOfWeek = 1;

    pub fn dayOfWeek(&self) -> hsmdate_time_component::HSMDateTimeComponentDayOfWeekType {
        match self.dayOfWeek {
            Some(e) => e.enum_value_or(hsmdate_time_component::HSMDateTimeComponentDayOfWeekType::MONDAY),
            None => hsmdate_time_component::HSMDateTimeComponentDayOfWeekType::MONDAY,
        }
    }

    pub fn clear_dayOfWeek(&mut self) {
        self.dayOfWeek = ::std::option::Option::None;
    }

    pub fn has_dayOfWeek(&self) -> bool {
        self.dayOfWeek.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dayOfWeek(&mut self, v: hsmdate_time_component::HSMDateTimeComponentDayOfWeekType) {
        self.dayOfWeek = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 year = 2;

    pub fn year(&self) -> u32 {
        self.year.unwrap_or(0)
    }

    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: u32) {
        self.year = ::std::option::Option::Some(v);
    }

    // optional uint32 month = 3;

    pub fn month(&self) -> u32 {
        self.month.unwrap_or(0)
    }

    pub fn clear_month(&mut self) {
        self.month = ::std::option::Option::None;
    }

    pub fn has_month(&self) -> bool {
        self.month.is_some()
    }

    // Param is passed by value, moved
    pub fn set_month(&mut self, v: u32) {
        self.month = ::std::option::Option::Some(v);
    }

    // optional uint32 dayOfMonth = 4;

    pub fn dayOfMonth(&self) -> u32 {
        self.dayOfMonth.unwrap_or(0)
    }

    pub fn clear_dayOfMonth(&mut self) {
        self.dayOfMonth = ::std::option::Option::None;
    }

    pub fn has_dayOfMonth(&self) -> bool {
        self.dayOfMonth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dayOfMonth(&mut self, v: u32) {
        self.dayOfMonth = ::std::option::Option::Some(v);
    }

    // optional uint32 hour = 5;

    pub fn hour(&self) -> u32 {
        self.hour.unwrap_or(0)
    }

    pub fn clear_hour(&mut self) {
        self.hour = ::std::option::Option::None;
    }

    pub fn has_hour(&self) -> bool {
        self.hour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hour(&mut self, v: u32) {
        self.hour = ::std::option::Option::Some(v);
    }

    // optional uint32 minute = 6;

    pub fn minute(&self) -> u32 {
        self.minute.unwrap_or(0)
    }

    pub fn clear_minute(&mut self) {
        self.minute = ::std::option::Option::None;
    }

    pub fn has_minute(&self) -> bool {
        self.minute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minute(&mut self, v: u32) {
        self.minute = ::std::option::Option::Some(v);
    }

    // optional .HSMDateTimeComponent.HSMDateTimeComponentCalendarType calendar = 7;

    pub fn calendar(&self) -> hsmdate_time_component::HSMDateTimeComponentCalendarType {
        match self.calendar {
            Some(e) => e.enum_value_or(hsmdate_time_component::HSMDateTimeComponentCalendarType::GREGORIAN),
            None => hsmdate_time_component::HSMDateTimeComponentCalendarType::GREGORIAN,
        }
    }

    pub fn clear_calendar(&mut self) {
        self.calendar = ::std::option::Option::None;
    }

    pub fn has_calendar(&self) -> bool {
        self.calendar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_calendar(&mut self, v: hsmdate_time_component::HSMDateTimeComponentCalendarType) {
        self.calendar = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dayOfWeek",
            |m: &HSMDateTimeComponent| { &m.dayOfWeek },
            |m: &mut HSMDateTimeComponent| { &mut m.dayOfWeek },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "year",
            |m: &HSMDateTimeComponent| { &m.year },
            |m: &mut HSMDateTimeComponent| { &mut m.year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "month",
            |m: &HSMDateTimeComponent| { &m.month },
            |m: &mut HSMDateTimeComponent| { &mut m.month },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dayOfMonth",
            |m: &HSMDateTimeComponent| { &m.dayOfMonth },
            |m: &mut HSMDateTimeComponent| { &mut m.dayOfMonth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hour",
            |m: &HSMDateTimeComponent| { &m.hour },
            |m: &mut HSMDateTimeComponent| { &mut m.hour },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minute",
            |m: &HSMDateTimeComponent| { &m.minute },
            |m: &mut HSMDateTimeComponent| { &mut m.minute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "calendar",
            |m: &HSMDateTimeComponent| { &m.calendar },
            |m: &mut HSMDateTimeComponent| { &mut m.calendar },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMDateTimeComponent>(
            "HSMDateTimeComponent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HSMDateTimeComponent {
    const NAME: &'static str = "HSMDateTimeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dayOfWeek = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.year = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.month = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.dayOfMonth = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.hour = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.minute = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.calendar = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dayOfWeek {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.month {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.dayOfMonth {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.hour {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.minute {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.calendar {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dayOfWeek {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.year {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.month {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.dayOfMonth {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.hour {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.minute {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.calendar {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HSMDateTimeComponent {
        HSMDateTimeComponent::new()
    }

    fn clear(&mut self) {
        self.dayOfWeek = ::std::option::Option::None;
        self.year = ::std::option::Option::None;
        self.month = ::std::option::Option::None;
        self.dayOfMonth = ::std::option::Option::None;
        self.hour = ::std::option::Option::None;
        self.minute = ::std::option::Option::None;
        self.calendar = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HSMDateTimeComponent {
        static instance: HSMDateTimeComponent = HSMDateTimeComponent {
            dayOfWeek: ::std::option::Option::None,
            year: ::std::option::Option::None,
            month: ::std::option::Option::None,
            dayOfMonth: ::std::option::Option::None,
            hour: ::std::option::Option::None,
            minute: ::std::option::Option::None,
            calendar: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HSMDateTimeComponent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HSMDateTimeComponent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HSMDateTimeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HSMDateTimeComponent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HSMDateTimeComponent`
pub mod hsmdate_time_component {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType)
    pub enum HSMDateTimeComponentDayOfWeekType {
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType.MONDAY)
        MONDAY = 1,
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType.TUESDAY)
        TUESDAY = 2,
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType.WEDNESDAY)
        WEDNESDAY = 3,
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType.THURSDAY)
        THURSDAY = 4,
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType.FRIDAY)
        FRIDAY = 5,
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType.SATURDAY)
        SATURDAY = 6,
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType.SUNDAY)
        SUNDAY = 7,
    }

    impl ::protobuf::Enum for HSMDateTimeComponentDayOfWeekType {
        const NAME: &'static str = "HSMDateTimeComponentDayOfWeekType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HSMDateTimeComponentDayOfWeekType> {
            match value {
                1 => ::std::option::Option::Some(HSMDateTimeComponentDayOfWeekType::MONDAY),
                2 => ::std::option::Option::Some(HSMDateTimeComponentDayOfWeekType::TUESDAY),
                3 => ::std::option::Option::Some(HSMDateTimeComponentDayOfWeekType::WEDNESDAY),
                4 => ::std::option::Option::Some(HSMDateTimeComponentDayOfWeekType::THURSDAY),
                5 => ::std::option::Option::Some(HSMDateTimeComponentDayOfWeekType::FRIDAY),
                6 => ::std::option::Option::Some(HSMDateTimeComponentDayOfWeekType::SATURDAY),
                7 => ::std::option::Option::Some(HSMDateTimeComponentDayOfWeekType::SUNDAY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HSMDateTimeComponentDayOfWeekType] = &[
            HSMDateTimeComponentDayOfWeekType::MONDAY,
            HSMDateTimeComponentDayOfWeekType::TUESDAY,
            HSMDateTimeComponentDayOfWeekType::WEDNESDAY,
            HSMDateTimeComponentDayOfWeekType::THURSDAY,
            HSMDateTimeComponentDayOfWeekType::FRIDAY,
            HSMDateTimeComponentDayOfWeekType::SATURDAY,
            HSMDateTimeComponentDayOfWeekType::SUNDAY,
        ];
    }

    impl ::protobuf::EnumFull for HSMDateTimeComponentDayOfWeekType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                HSMDateTimeComponentDayOfWeekType::MONDAY => 0,
                HSMDateTimeComponentDayOfWeekType::TUESDAY => 1,
                HSMDateTimeComponentDayOfWeekType::WEDNESDAY => 2,
                HSMDateTimeComponentDayOfWeekType::THURSDAY => 3,
                HSMDateTimeComponentDayOfWeekType::FRIDAY => 4,
                HSMDateTimeComponentDayOfWeekType::SATURDAY => 5,
                HSMDateTimeComponentDayOfWeekType::SUNDAY => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for HSMDateTimeComponentDayOfWeekType {
        fn default() -> Self {
            HSMDateTimeComponentDayOfWeekType::MONDAY
        }
    }

    impl HSMDateTimeComponentDayOfWeekType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HSMDateTimeComponentDayOfWeekType>("HSMDateTimeComponent.HSMDateTimeComponentDayOfWeekType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:HSMDateTimeComponent.HSMDateTimeComponentCalendarType)
    pub enum HSMDateTimeComponentCalendarType {
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentCalendarType.GREGORIAN)
        GREGORIAN = 1,
        // @@protoc_insertion_point(enum_value:HSMDateTimeComponent.HSMDateTimeComponentCalendarType.SOLAR_HIJRI)
        SOLAR_HIJRI = 2,
    }

    impl ::protobuf::Enum for HSMDateTimeComponentCalendarType {
        const NAME: &'static str = "HSMDateTimeComponentCalendarType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HSMDateTimeComponentCalendarType> {
            match value {
                1 => ::std::option::Option::Some(HSMDateTimeComponentCalendarType::GREGORIAN),
                2 => ::std::option::Option::Some(HSMDateTimeComponentCalendarType::SOLAR_HIJRI),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HSMDateTimeComponentCalendarType] = &[
            HSMDateTimeComponentCalendarType::GREGORIAN,
            HSMDateTimeComponentCalendarType::SOLAR_HIJRI,
        ];
    }

    impl ::protobuf::EnumFull for HSMDateTimeComponentCalendarType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HSMDateTimeComponent.HSMDateTimeComponentCalendarType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                HSMDateTimeComponentCalendarType::GREGORIAN => 0,
                HSMDateTimeComponentCalendarType::SOLAR_HIJRI => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for HSMDateTimeComponentCalendarType {
        fn default() -> Self {
            HSMDateTimeComponentCalendarType::GREGORIAN
        }
    }

    impl HSMDateTimeComponentCalendarType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HSMDateTimeComponentCalendarType>("HSMDateTimeComponent.HSMDateTimeComponentCalendarType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HSMDateTimeUnixEpoch)
pub struct HSMDateTimeUnixEpoch {
    // message fields
    // @@protoc_insertion_point(field:HSMDateTimeUnixEpoch.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:HSMDateTimeUnixEpoch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HSMDateTimeUnixEpoch {
    fn default() -> &'a HSMDateTimeUnixEpoch {
        <HSMDateTimeUnixEpoch as ::protobuf::Message>::default_instance()
    }
}

impl HSMDateTimeUnixEpoch {
    pub fn new() -> HSMDateTimeUnixEpoch {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 1;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &HSMDateTimeUnixEpoch| { &m.timestamp },
            |m: &mut HSMDateTimeUnixEpoch| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMDateTimeUnixEpoch>(
            "HSMDateTimeUnixEpoch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HSMDateTimeUnixEpoch {
    const NAME: &'static str = "HSMDateTimeUnixEpoch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HSMDateTimeUnixEpoch {
        HSMDateTimeUnixEpoch::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HSMDateTimeUnixEpoch {
        static instance: HSMDateTimeUnixEpoch = HSMDateTimeUnixEpoch {
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HSMDateTimeUnixEpoch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HSMDateTimeUnixEpoch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HSMDateTimeUnixEpoch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HSMDateTimeUnixEpoch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HSMDateTime)
pub struct HSMDateTime {
    // message oneof groups
    pub datetimeOneof: ::std::option::Option<hsmdate_time::DatetimeOneof>,
    // special fields
    // @@protoc_insertion_point(special_field:HSMDateTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HSMDateTime {
    fn default() -> &'a HSMDateTime {
        <HSMDateTime as ::protobuf::Message>::default_instance()
    }
}

impl HSMDateTime {
    pub fn new() -> HSMDateTime {
        ::std::default::Default::default()
    }

    // optional .HSMDateTimeComponent component = 1;

    pub fn component(&self) -> &HSMDateTimeComponent {
        match self.datetimeOneof {
            ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(ref v)) => v,
            _ => <HSMDateTimeComponent as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_component(&mut self) {
        self.datetimeOneof = ::std::option::Option::None;
    }

    pub fn has_component(&self) -> bool {
        match self.datetimeOneof {
            ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_component(&mut self, v: HSMDateTimeComponent) {
        self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(v))
    }

    // Mutable pointer to the field.
    pub fn mut_component(&mut self) -> &mut HSMDateTimeComponent {
        if let ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(_)) = self.datetimeOneof {
        } else {
            self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(HSMDateTimeComponent::new()));
        }
        match self.datetimeOneof {
            ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_component(&mut self) -> HSMDateTimeComponent {
        if self.has_component() {
            match self.datetimeOneof.take() {
                ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(v)) => v,
                _ => panic!(),
            }
        } else {
            HSMDateTimeComponent::new()
        }
    }

    // optional .HSMDateTimeUnixEpoch unixEpoch = 2;

    pub fn unixEpoch(&self) -> &HSMDateTimeUnixEpoch {
        match self.datetimeOneof {
            ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(ref v)) => v,
            _ => <HSMDateTimeUnixEpoch as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unixEpoch(&mut self) {
        self.datetimeOneof = ::std::option::Option::None;
    }

    pub fn has_unixEpoch(&self) -> bool {
        match self.datetimeOneof {
            ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unixEpoch(&mut self, v: HSMDateTimeUnixEpoch) {
        self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unixEpoch(&mut self) -> &mut HSMDateTimeUnixEpoch {
        if let ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(_)) = self.datetimeOneof {
        } else {
            self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(HSMDateTimeUnixEpoch::new()));
        }
        match self.datetimeOneof {
            ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unixEpoch(&mut self) -> HSMDateTimeUnixEpoch {
        if self.has_unixEpoch() {
            match self.datetimeOneof.take() {
                ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(v)) => v,
                _ => panic!(),
            }
        } else {
            HSMDateTimeUnixEpoch::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HSMDateTimeComponent>(
            "component",
            HSMDateTime::has_component,
            HSMDateTime::component,
            HSMDateTime::mut_component,
            HSMDateTime::set_component,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HSMDateTimeUnixEpoch>(
            "unixEpoch",
            HSMDateTime::has_unixEpoch,
            HSMDateTime::unixEpoch,
            HSMDateTime::mut_unixEpoch,
            HSMDateTime::set_unixEpoch,
        ));
        oneofs.push(hsmdate_time::DatetimeOneof::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMDateTime>(
            "HSMDateTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HSMDateTime {
    const NAME: &'static str = "HSMDateTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(is.read_message()?));
                },
                18 => {
                    self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.datetimeOneof {
            match v {
                &hsmdate_time::DatetimeOneof::Component(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hsmdate_time::DatetimeOneof::UnixEpoch(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.datetimeOneof {
            match v {
                &hsmdate_time::DatetimeOneof::Component(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &hsmdate_time::DatetimeOneof::UnixEpoch(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HSMDateTime {
        HSMDateTime::new()
    }

    fn clear(&mut self) {
        self.datetimeOneof = ::std::option::Option::None;
        self.datetimeOneof = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HSMDateTime {
        static instance: HSMDateTime = HSMDateTime {
            datetimeOneof: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HSMDateTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HSMDateTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HSMDateTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HSMDateTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HSMDateTime`
pub mod hsmdate_time {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:HSMDateTime.datetimeOneof)
    pub enum DatetimeOneof {
        // @@protoc_insertion_point(oneof_field:HSMDateTime.component)
        Component(super::HSMDateTimeComponent),
        // @@protoc_insertion_point(oneof_field:HSMDateTime.unixEpoch)
        UnixEpoch(super::HSMDateTimeUnixEpoch),
    }

    impl ::protobuf::Oneof for DatetimeOneof {
    }

    impl ::protobuf::OneofFull for DatetimeOneof {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::HSMDateTime as ::protobuf::MessageFull>::descriptor().oneof_by_name("datetimeOneof").unwrap()).clone()
        }
    }

    impl DatetimeOneof {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<DatetimeOneof>("datetimeOneof")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HSMLocalizableParameter)
pub struct HSMLocalizableParameter {
    // message fields
    // @@protoc_insertion_point(field:HSMLocalizableParameter.default)
    pub default: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub paramOneof: ::std::option::Option<hsmlocalizable_parameter::ParamOneof>,
    // special fields
    // @@protoc_insertion_point(special_field:HSMLocalizableParameter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HSMLocalizableParameter {
    fn default() -> &'a HSMLocalizableParameter {
        <HSMLocalizableParameter as ::protobuf::Message>::default_instance()
    }
}

impl HSMLocalizableParameter {
    pub fn new() -> HSMLocalizableParameter {
        ::std::default::Default::default()
    }

    // optional string default = 1;

    pub fn default(&self) -> &str {
        match self.default.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default(&mut self) {
        self.default = ::std::option::Option::None;
    }

    pub fn has_default(&self) -> bool {
        self.default.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default(&mut self, v: ::std::string::String) {
        self.default = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default(&mut self) -> &mut ::std::string::String {
        if self.default.is_none() {
            self.default = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default.as_mut().unwrap()
    }

    // Take field
    pub fn take_default(&mut self) -> ::std::string::String {
        self.default.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .HSMCurrency currency = 2;

    pub fn currency(&self) -> &HSMCurrency {
        match self.paramOneof {
            ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(ref v)) => v,
            _ => <HSMCurrency as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_currency(&mut self) {
        self.paramOneof = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        match self.paramOneof {
            ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: HSMCurrency) {
        self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(v))
    }

    // Mutable pointer to the field.
    pub fn mut_currency(&mut self) -> &mut HSMCurrency {
        if let ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(_)) = self.paramOneof {
        } else {
            self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(HSMCurrency::new()));
        }
        match self.paramOneof {
            ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_currency(&mut self) -> HSMCurrency {
        if self.has_currency() {
            match self.paramOneof.take() {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(v)) => v,
                _ => panic!(),
            }
        } else {
            HSMCurrency::new()
        }
    }

    // optional .HSMDateTime dateTime = 3;

    pub fn dateTime(&self) -> &HSMDateTime {
        match self.paramOneof {
            ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(ref v)) => v,
            _ => <HSMDateTime as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_dateTime(&mut self) {
        self.paramOneof = ::std::option::Option::None;
    }

    pub fn has_dateTime(&self) -> bool {
        match self.paramOneof {
            ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dateTime(&mut self, v: HSMDateTime) {
        self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dateTime(&mut self) -> &mut HSMDateTime {
        if let ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(_)) = self.paramOneof {
        } else {
            self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(HSMDateTime::new()));
        }
        match self.paramOneof {
            ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dateTime(&mut self) -> HSMDateTime {
        if self.has_dateTime() {
            match self.paramOneof.take() {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(v)) => v,
                _ => panic!(),
            }
        } else {
            HSMDateTime::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default",
            |m: &HSMLocalizableParameter| { &m.default },
            |m: &mut HSMLocalizableParameter| { &mut m.default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HSMCurrency>(
            "currency",
            HSMLocalizableParameter::has_currency,
            HSMLocalizableParameter::currency,
            HSMLocalizableParameter::mut_currency,
            HSMLocalizableParameter::set_currency,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HSMDateTime>(
            "dateTime",
            HSMLocalizableParameter::has_dateTime,
            HSMLocalizableParameter::dateTime,
            HSMLocalizableParameter::mut_dateTime,
            HSMLocalizableParameter::set_dateTime,
        ));
        oneofs.push(hsmlocalizable_parameter::ParamOneof::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMLocalizableParameter>(
            "HSMLocalizableParameter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HSMLocalizableParameter {
    const NAME: &'static str = "HSMLocalizableParameter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.default = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(is.read_message()?));
                },
                26 => {
                    self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.default.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.paramOneof {
            match v {
                &hsmlocalizable_parameter::ParamOneof::Currency(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hsmlocalizable_parameter::ParamOneof::DateTime(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.default.as_ref() {
            os.write_string(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.paramOneof {
            match v {
                &hsmlocalizable_parameter::ParamOneof::Currency(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &hsmlocalizable_parameter::ParamOneof::DateTime(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HSMLocalizableParameter {
        HSMLocalizableParameter::new()
    }

    fn clear(&mut self) {
        self.default = ::std::option::Option::None;
        self.paramOneof = ::std::option::Option::None;
        self.paramOneof = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HSMLocalizableParameter {
        static instance: HSMLocalizableParameter = HSMLocalizableParameter {
            default: ::std::option::Option::None,
            paramOneof: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HSMLocalizableParameter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HSMLocalizableParameter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HSMLocalizableParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HSMLocalizableParameter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HSMLocalizableParameter`
pub mod hsmlocalizable_parameter {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:HSMLocalizableParameter.paramOneof)
    pub enum ParamOneof {
        // @@protoc_insertion_point(oneof_field:HSMLocalizableParameter.currency)
        Currency(super::HSMCurrency),
        // @@protoc_insertion_point(oneof_field:HSMLocalizableParameter.dateTime)
        DateTime(super::HSMDateTime),
    }

    impl ::protobuf::Oneof for ParamOneof {
    }

    impl ::protobuf::OneofFull for ParamOneof {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::HSMLocalizableParameter as ::protobuf::MessageFull>::descriptor().oneof_by_name("paramOneof").unwrap()).clone()
        }
    }

    impl ParamOneof {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<ParamOneof>("paramOneof")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HighlyStructuredMessage)
pub struct HighlyStructuredMessage {
    // message fields
    // @@protoc_insertion_point(field:HighlyStructuredMessage.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.elementName)
    pub elementName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.params)
    pub params: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.fallbackLg)
    pub fallbackLg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.fallbackLc)
    pub fallbackLc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.localizableParams)
    pub localizableParams: ::std::vec::Vec<HSMLocalizableParameter>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.deterministicLg)
    pub deterministicLg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.deterministicLc)
    pub deterministicLc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HighlyStructuredMessage.hydratedHsm)
    pub hydratedHsm: ::protobuf::MessageField<TemplateMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:HighlyStructuredMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HighlyStructuredMessage {
    fn default() -> &'a HighlyStructuredMessage {
        <HighlyStructuredMessage as ::protobuf::Message>::default_instance()
    }
}

impl HighlyStructuredMessage {
    pub fn new() -> HighlyStructuredMessage {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string elementName = 2;

    pub fn elementName(&self) -> &str {
        match self.elementName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_elementName(&mut self) {
        self.elementName = ::std::option::Option::None;
    }

    pub fn has_elementName(&self) -> bool {
        self.elementName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elementName(&mut self, v: ::std::string::String) {
        self.elementName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elementName(&mut self) -> &mut ::std::string::String {
        if self.elementName.is_none() {
            self.elementName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.elementName.as_mut().unwrap()
    }

    // Take field
    pub fn take_elementName(&mut self) -> ::std::string::String {
        self.elementName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fallbackLg = 4;

    pub fn fallbackLg(&self) -> &str {
        match self.fallbackLg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fallbackLg(&mut self) {
        self.fallbackLg = ::std::option::Option::None;
    }

    pub fn has_fallbackLg(&self) -> bool {
        self.fallbackLg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallbackLg(&mut self, v: ::std::string::String) {
        self.fallbackLg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallbackLg(&mut self) -> &mut ::std::string::String {
        if self.fallbackLg.is_none() {
            self.fallbackLg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fallbackLg.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallbackLg(&mut self) -> ::std::string::String {
        self.fallbackLg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fallbackLc = 5;

    pub fn fallbackLc(&self) -> &str {
        match self.fallbackLc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fallbackLc(&mut self) {
        self.fallbackLc = ::std::option::Option::None;
    }

    pub fn has_fallbackLc(&self) -> bool {
        self.fallbackLc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallbackLc(&mut self, v: ::std::string::String) {
        self.fallbackLc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallbackLc(&mut self) -> &mut ::std::string::String {
        if self.fallbackLc.is_none() {
            self.fallbackLc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fallbackLc.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallbackLc(&mut self) -> ::std::string::String {
        self.fallbackLc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string deterministicLg = 7;

    pub fn deterministicLg(&self) -> &str {
        match self.deterministicLg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deterministicLg(&mut self) {
        self.deterministicLg = ::std::option::Option::None;
    }

    pub fn has_deterministicLg(&self) -> bool {
        self.deterministicLg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deterministicLg(&mut self, v: ::std::string::String) {
        self.deterministicLg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deterministicLg(&mut self) -> &mut ::std::string::String {
        if self.deterministicLg.is_none() {
            self.deterministicLg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deterministicLg.as_mut().unwrap()
    }

    // Take field
    pub fn take_deterministicLg(&mut self) -> ::std::string::String {
        self.deterministicLg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string deterministicLc = 8;

    pub fn deterministicLc(&self) -> &str {
        match self.deterministicLc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deterministicLc(&mut self) {
        self.deterministicLc = ::std::option::Option::None;
    }

    pub fn has_deterministicLc(&self) -> bool {
        self.deterministicLc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deterministicLc(&mut self, v: ::std::string::String) {
        self.deterministicLc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deterministicLc(&mut self) -> &mut ::std::string::String {
        if self.deterministicLc.is_none() {
            self.deterministicLc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deterministicLc.as_mut().unwrap()
    }

    // Take field
    pub fn take_deterministicLc(&mut self) -> ::std::string::String {
        self.deterministicLc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &HighlyStructuredMessage| { &m.namespace },
            |m: &mut HighlyStructuredMessage| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elementName",
            |m: &HighlyStructuredMessage| { &m.elementName },
            |m: &mut HighlyStructuredMessage| { &mut m.elementName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &HighlyStructuredMessage| { &m.params },
            |m: &mut HighlyStructuredMessage| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fallbackLg",
            |m: &HighlyStructuredMessage| { &m.fallbackLg },
            |m: &mut HighlyStructuredMessage| { &mut m.fallbackLg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fallbackLc",
            |m: &HighlyStructuredMessage| { &m.fallbackLc },
            |m: &mut HighlyStructuredMessage| { &mut m.fallbackLc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "localizableParams",
            |m: &HighlyStructuredMessage| { &m.localizableParams },
            |m: &mut HighlyStructuredMessage| { &mut m.localizableParams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deterministicLg",
            |m: &HighlyStructuredMessage| { &m.deterministicLg },
            |m: &mut HighlyStructuredMessage| { &mut m.deterministicLg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deterministicLc",
            |m: &HighlyStructuredMessage| { &m.deterministicLc },
            |m: &mut HighlyStructuredMessage| { &mut m.deterministicLc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TemplateMessage>(
            "hydratedHsm",
            |m: &HighlyStructuredMessage| { &m.hydratedHsm },
            |m: &mut HighlyStructuredMessage| { &mut m.hydratedHsm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HighlyStructuredMessage>(
            "HighlyStructuredMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HighlyStructuredMessage {
    const NAME: &'static str = "HighlyStructuredMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.elementName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.params.push(is.read_string()?);
                },
                34 => {
                    self.fallbackLg = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.fallbackLc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.localizableParams.push(is.read_message()?);
                },
                58 => {
                    self.deterministicLg = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.deterministicLc = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hydratedHsm)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.elementName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.fallbackLg.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.fallbackLc.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.localizableParams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.deterministicLg.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.deterministicLc.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.hydratedHsm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.elementName.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.params {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.fallbackLg.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.fallbackLc.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.localizableParams {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.deterministicLg.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.deterministicLc.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.hydratedHsm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HighlyStructuredMessage {
        HighlyStructuredMessage::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.elementName = ::std::option::Option::None;
        self.params.clear();
        self.fallbackLg = ::std::option::Option::None;
        self.fallbackLc = ::std::option::Option::None;
        self.localizableParams.clear();
        self.deterministicLg = ::std::option::Option::None;
        self.deterministicLc = ::std::option::Option::None;
        self.hydratedHsm.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HighlyStructuredMessage {
        static instance: HighlyStructuredMessage = HighlyStructuredMessage {
            namespace: ::std::option::Option::None,
            elementName: ::std::option::Option::None,
            params: ::std::vec::Vec::new(),
            fallbackLg: ::std::option::Option::None,
            fallbackLc: ::std::option::Option::None,
            localizableParams: ::std::vec::Vec::new(),
            deterministicLg: ::std::option::Option::None,
            deterministicLc: ::std::option::Option::None,
            hydratedHsm: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HighlyStructuredMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HighlyStructuredMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HighlyStructuredMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HighlyStructuredMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SendPaymentMessage)
pub struct SendPaymentMessage {
    // message fields
    // @@protoc_insertion_point(field:SendPaymentMessage.noteMessage)
    pub noteMessage: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:SendPaymentMessage.requestMessageKey)
    pub requestMessageKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:SendPaymentMessage.background)
    pub background: ::protobuf::MessageField<PaymentBackground>,
    // special fields
    // @@protoc_insertion_point(special_field:SendPaymentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendPaymentMessage {
    fn default() -> &'a SendPaymentMessage {
        <SendPaymentMessage as ::protobuf::Message>::default_instance()
    }
}

impl SendPaymentMessage {
    pub fn new() -> SendPaymentMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "noteMessage",
            |m: &SendPaymentMessage| { &m.noteMessage },
            |m: &mut SendPaymentMessage| { &mut m.noteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "requestMessageKey",
            |m: &SendPaymentMessage| { &m.requestMessageKey },
            |m: &mut SendPaymentMessage| { &mut m.requestMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBackground>(
            "background",
            |m: &SendPaymentMessage| { &m.background },
            |m: &mut SendPaymentMessage| { &mut m.background },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendPaymentMessage>(
            "SendPaymentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendPaymentMessage {
    const NAME: &'static str = "SendPaymentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.noteMessage)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requestMessageKey)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.noteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.noteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.background.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendPaymentMessage {
        SendPaymentMessage::new()
    }

    fn clear(&mut self) {
        self.noteMessage.clear();
        self.requestMessageKey.clear();
        self.background.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendPaymentMessage {
        static instance: SendPaymentMessage = SendPaymentMessage {
            noteMessage: ::protobuf::MessageField::none(),
            requestMessageKey: ::protobuf::MessageField::none(),
            background: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendPaymentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendPaymentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendPaymentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendPaymentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RequestPaymentMessage)
pub struct RequestPaymentMessage {
    // message fields
    // @@protoc_insertion_point(field:RequestPaymentMessage.noteMessage)
    pub noteMessage: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:RequestPaymentMessage.currencyCodeIso4217)
    pub currencyCodeIso4217: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RequestPaymentMessage.amount1000)
    pub amount1000: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:RequestPaymentMessage.requestFrom)
    pub requestFrom: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:RequestPaymentMessage.expiryTimestamp)
    pub expiryTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:RequestPaymentMessage.amount)
    pub amount: ::protobuf::MessageField<Money>,
    // @@protoc_insertion_point(field:RequestPaymentMessage.background)
    pub background: ::protobuf::MessageField<PaymentBackground>,
    // special fields
    // @@protoc_insertion_point(special_field:RequestPaymentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestPaymentMessage {
    fn default() -> &'a RequestPaymentMessage {
        <RequestPaymentMessage as ::protobuf::Message>::default_instance()
    }
}

impl RequestPaymentMessage {
    pub fn new() -> RequestPaymentMessage {
        ::std::default::Default::default()
    }

    // optional string currencyCodeIso4217 = 1;

    pub fn currencyCodeIso4217(&self) -> &str {
        match self.currencyCodeIso4217.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currencyCodeIso4217(&mut self) {
        self.currencyCodeIso4217 = ::std::option::Option::None;
    }

    pub fn has_currencyCodeIso4217(&self) -> bool {
        self.currencyCodeIso4217.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyCodeIso4217(&mut self, v: ::std::string::String) {
        self.currencyCodeIso4217 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currencyCodeIso4217(&mut self) -> &mut ::std::string::String {
        if self.currencyCodeIso4217.is_none() {
            self.currencyCodeIso4217 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currencyCodeIso4217.as_mut().unwrap()
    }

    // Take field
    pub fn take_currencyCodeIso4217(&mut self) -> ::std::string::String {
        self.currencyCodeIso4217.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 amount1000 = 2;

    pub fn amount1000(&self) -> u64 {
        self.amount1000.unwrap_or(0)
    }

    pub fn clear_amount1000(&mut self) {
        self.amount1000 = ::std::option::Option::None;
    }

    pub fn has_amount1000(&self) -> bool {
        self.amount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount1000(&mut self, v: u64) {
        self.amount1000 = ::std::option::Option::Some(v);
    }

    // optional string requestFrom = 3;

    pub fn requestFrom(&self) -> &str {
        match self.requestFrom.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requestFrom(&mut self) {
        self.requestFrom = ::std::option::Option::None;
    }

    pub fn has_requestFrom(&self) -> bool {
        self.requestFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestFrom(&mut self, v: ::std::string::String) {
        self.requestFrom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requestFrom(&mut self) -> &mut ::std::string::String {
        if self.requestFrom.is_none() {
            self.requestFrom = ::std::option::Option::Some(::std::string::String::new());
        }
        self.requestFrom.as_mut().unwrap()
    }

    // Take field
    pub fn take_requestFrom(&mut self) -> ::std::string::String {
        self.requestFrom.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 expiryTimestamp = 5;

    pub fn expiryTimestamp(&self) -> i64 {
        self.expiryTimestamp.unwrap_or(0)
    }

    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = ::std::option::Option::None;
    }

    pub fn has_expiryTimestamp(&self) -> bool {
        self.expiryTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: i64) {
        self.expiryTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "noteMessage",
            |m: &RequestPaymentMessage| { &m.noteMessage },
            |m: &mut RequestPaymentMessage| { &mut m.noteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyCodeIso4217",
            |m: &RequestPaymentMessage| { &m.currencyCodeIso4217 },
            |m: &mut RequestPaymentMessage| { &mut m.currencyCodeIso4217 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount1000",
            |m: &RequestPaymentMessage| { &m.amount1000 },
            |m: &mut RequestPaymentMessage| { &mut m.amount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requestFrom",
            |m: &RequestPaymentMessage| { &m.requestFrom },
            |m: &mut RequestPaymentMessage| { &mut m.requestFrom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiryTimestamp",
            |m: &RequestPaymentMessage| { &m.expiryTimestamp },
            |m: &mut RequestPaymentMessage| { &mut m.expiryTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Money>(
            "amount",
            |m: &RequestPaymentMessage| { &m.amount },
            |m: &mut RequestPaymentMessage| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBackground>(
            "background",
            |m: &RequestPaymentMessage| { &m.background },
            |m: &mut RequestPaymentMessage| { &mut m.background },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestPaymentMessage>(
            "RequestPaymentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestPaymentMessage {
    const NAME: &'static str = "RequestPaymentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.noteMessage)?;
                },
                10 => {
                    self.currencyCodeIso4217 = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.amount1000 = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.requestFrom = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.expiryTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.amount)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.noteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.currencyCodeIso4217.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.amount1000 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.requestFrom.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.expiryTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.noteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.currencyCodeIso4217.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.amount1000 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.requestFrom.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.expiryTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.amount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.background.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestPaymentMessage {
        RequestPaymentMessage::new()
    }

    fn clear(&mut self) {
        self.noteMessage.clear();
        self.currencyCodeIso4217 = ::std::option::Option::None;
        self.amount1000 = ::std::option::Option::None;
        self.requestFrom = ::std::option::Option::None;
        self.expiryTimestamp = ::std::option::Option::None;
        self.amount.clear();
        self.background.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestPaymentMessage {
        static instance: RequestPaymentMessage = RequestPaymentMessage {
            noteMessage: ::protobuf::MessageField::none(),
            currencyCodeIso4217: ::std::option::Option::None,
            amount1000: ::std::option::Option::None,
            requestFrom: ::std::option::Option::None,
            expiryTimestamp: ::std::option::Option::None,
            amount: ::protobuf::MessageField::none(),
            background: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestPaymentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestPaymentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestPaymentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPaymentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeclinePaymentRequestMessage)
pub struct DeclinePaymentRequestMessage {
    // message fields
    // @@protoc_insertion_point(field:DeclinePaymentRequestMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // special fields
    // @@protoc_insertion_point(special_field:DeclinePaymentRequestMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeclinePaymentRequestMessage {
    fn default() -> &'a DeclinePaymentRequestMessage {
        <DeclinePaymentRequestMessage as ::protobuf::Message>::default_instance()
    }
}

impl DeclinePaymentRequestMessage {
    pub fn new() -> DeclinePaymentRequestMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &DeclinePaymentRequestMessage| { &m.key },
            |m: &mut DeclinePaymentRequestMessage| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeclinePaymentRequestMessage>(
            "DeclinePaymentRequestMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeclinePaymentRequestMessage {
    const NAME: &'static str = "DeclinePaymentRequestMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeclinePaymentRequestMessage {
        DeclinePaymentRequestMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeclinePaymentRequestMessage {
        static instance: DeclinePaymentRequestMessage = DeclinePaymentRequestMessage {
            key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeclinePaymentRequestMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeclinePaymentRequestMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeclinePaymentRequestMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeclinePaymentRequestMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CancelPaymentRequestMessage)
pub struct CancelPaymentRequestMessage {
    // message fields
    // @@protoc_insertion_point(field:CancelPaymentRequestMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // special fields
    // @@protoc_insertion_point(special_field:CancelPaymentRequestMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelPaymentRequestMessage {
    fn default() -> &'a CancelPaymentRequestMessage {
        <CancelPaymentRequestMessage as ::protobuf::Message>::default_instance()
    }
}

impl CancelPaymentRequestMessage {
    pub fn new() -> CancelPaymentRequestMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &CancelPaymentRequestMessage| { &m.key },
            |m: &mut CancelPaymentRequestMessage| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelPaymentRequestMessage>(
            "CancelPaymentRequestMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelPaymentRequestMessage {
    const NAME: &'static str = "CancelPaymentRequestMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelPaymentRequestMessage {
        CancelPaymentRequestMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelPaymentRequestMessage {
        static instance: CancelPaymentRequestMessage = CancelPaymentRequestMessage {
            key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelPaymentRequestMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelPaymentRequestMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelPaymentRequestMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelPaymentRequestMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PaymentInviteMessage)
pub struct PaymentInviteMessage {
    // message fields
    // @@protoc_insertion_point(field:PaymentInviteMessage.serviceType)
    pub serviceType: ::std::option::Option<::protobuf::EnumOrUnknown<payment_invite_message::PaymentInviteMessageServiceType>>,
    // @@protoc_insertion_point(field:PaymentInviteMessage.expiryTimestamp)
    pub expiryTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:PaymentInviteMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentInviteMessage {
    fn default() -> &'a PaymentInviteMessage {
        <PaymentInviteMessage as ::protobuf::Message>::default_instance()
    }
}

impl PaymentInviteMessage {
    pub fn new() -> PaymentInviteMessage {
        ::std::default::Default::default()
    }

    // optional .PaymentInviteMessage.PaymentInviteMessageServiceType serviceType = 1;

    pub fn serviceType(&self) -> payment_invite_message::PaymentInviteMessageServiceType {
        match self.serviceType {
            Some(e) => e.enum_value_or(payment_invite_message::PaymentInviteMessageServiceType::UNKNOWN),
            None => payment_invite_message::PaymentInviteMessageServiceType::UNKNOWN,
        }
    }

    pub fn clear_serviceType(&mut self) {
        self.serviceType = ::std::option::Option::None;
    }

    pub fn has_serviceType(&self) -> bool {
        self.serviceType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceType(&mut self, v: payment_invite_message::PaymentInviteMessageServiceType) {
        self.serviceType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 expiryTimestamp = 2;

    pub fn expiryTimestamp(&self) -> i64 {
        self.expiryTimestamp.unwrap_or(0)
    }

    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = ::std::option::Option::None;
    }

    pub fn has_expiryTimestamp(&self) -> bool {
        self.expiryTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: i64) {
        self.expiryTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceType",
            |m: &PaymentInviteMessage| { &m.serviceType },
            |m: &mut PaymentInviteMessage| { &mut m.serviceType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiryTimestamp",
            |m: &PaymentInviteMessage| { &m.expiryTimestamp },
            |m: &mut PaymentInviteMessage| { &mut m.expiryTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentInviteMessage>(
            "PaymentInviteMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentInviteMessage {
    const NAME: &'static str = "PaymentInviteMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serviceType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.expiryTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serviceType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.expiryTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serviceType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.expiryTimestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentInviteMessage {
        PaymentInviteMessage::new()
    }

    fn clear(&mut self) {
        self.serviceType = ::std::option::Option::None;
        self.expiryTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentInviteMessage {
        static instance: PaymentInviteMessage = PaymentInviteMessage {
            serviceType: ::std::option::Option::None,
            expiryTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentInviteMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentInviteMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentInviteMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentInviteMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PaymentInviteMessage`
pub mod payment_invite_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:PaymentInviteMessage.PaymentInviteMessageServiceType)
    pub enum PaymentInviteMessageServiceType {
        // @@protoc_insertion_point(enum_value:PaymentInviteMessage.PaymentInviteMessageServiceType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:PaymentInviteMessage.PaymentInviteMessageServiceType.FBPAY)
        FBPAY = 1,
        // @@protoc_insertion_point(enum_value:PaymentInviteMessage.PaymentInviteMessageServiceType.NOVI)
        NOVI = 2,
        // @@protoc_insertion_point(enum_value:PaymentInviteMessage.PaymentInviteMessageServiceType.UPI)
        UPI = 3,
    }

    impl ::protobuf::Enum for PaymentInviteMessageServiceType {
        const NAME: &'static str = "PaymentInviteMessageServiceType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PaymentInviteMessageServiceType> {
            match value {
                0 => ::std::option::Option::Some(PaymentInviteMessageServiceType::UNKNOWN),
                1 => ::std::option::Option::Some(PaymentInviteMessageServiceType::FBPAY),
                2 => ::std::option::Option::Some(PaymentInviteMessageServiceType::NOVI),
                3 => ::std::option::Option::Some(PaymentInviteMessageServiceType::UPI),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PaymentInviteMessageServiceType] = &[
            PaymentInviteMessageServiceType::UNKNOWN,
            PaymentInviteMessageServiceType::FBPAY,
            PaymentInviteMessageServiceType::NOVI,
            PaymentInviteMessageServiceType::UPI,
        ];
    }

    impl ::protobuf::EnumFull for PaymentInviteMessageServiceType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInviteMessage.PaymentInviteMessageServiceType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PaymentInviteMessageServiceType {
        fn default() -> Self {
            PaymentInviteMessageServiceType::UNKNOWN
        }
    }

    impl PaymentInviteMessageServiceType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentInviteMessageServiceType>("PaymentInviteMessage.PaymentInviteMessageServiceType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LiveLocationMessage)
pub struct LiveLocationMessage {
    // message fields
    // @@protoc_insertion_point(field:LiveLocationMessage.degreesLatitude)
    pub degreesLatitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:LiveLocationMessage.degreesLongitude)
    pub degreesLongitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:LiveLocationMessage.accuracyInMeters)
    pub accuracyInMeters: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LiveLocationMessage.speedInMps)
    pub speedInMps: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:LiveLocationMessage.degreesClockwiseFromMagneticNorth)
    pub degreesClockwiseFromMagneticNorth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LiveLocationMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:LiveLocationMessage.sequenceNumber)
    pub sequenceNumber: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:LiveLocationMessage.timeOffset)
    pub timeOffset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:LiveLocationMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:LiveLocationMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:LiveLocationMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LiveLocationMessage {
    fn default() -> &'a LiveLocationMessage {
        <LiveLocationMessage as ::protobuf::Message>::default_instance()
    }
}

impl LiveLocationMessage {
    pub fn new() -> LiveLocationMessage {
        ::std::default::Default::default()
    }

    // optional double degreesLatitude = 1;

    pub fn degreesLatitude(&self) -> f64 {
        self.degreesLatitude.unwrap_or(0.)
    }

    pub fn clear_degreesLatitude(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
    }

    pub fn has_degreesLatitude(&self) -> bool {
        self.degreesLatitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLatitude(&mut self, v: f64) {
        self.degreesLatitude = ::std::option::Option::Some(v);
    }

    // optional double degreesLongitude = 2;

    pub fn degreesLongitude(&self) -> f64 {
        self.degreesLongitude.unwrap_or(0.)
    }

    pub fn clear_degreesLongitude(&mut self) {
        self.degreesLongitude = ::std::option::Option::None;
    }

    pub fn has_degreesLongitude(&self) -> bool {
        self.degreesLongitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLongitude(&mut self, v: f64) {
        self.degreesLongitude = ::std::option::Option::Some(v);
    }

    // optional uint32 accuracyInMeters = 3;

    pub fn accuracyInMeters(&self) -> u32 {
        self.accuracyInMeters.unwrap_or(0)
    }

    pub fn clear_accuracyInMeters(&mut self) {
        self.accuracyInMeters = ::std::option::Option::None;
    }

    pub fn has_accuracyInMeters(&self) -> bool {
        self.accuracyInMeters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accuracyInMeters(&mut self, v: u32) {
        self.accuracyInMeters = ::std::option::Option::Some(v);
    }

    // optional float speedInMps = 4;

    pub fn speedInMps(&self) -> f32 {
        self.speedInMps.unwrap_or(0.)
    }

    pub fn clear_speedInMps(&mut self) {
        self.speedInMps = ::std::option::Option::None;
    }

    pub fn has_speedInMps(&self) -> bool {
        self.speedInMps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speedInMps(&mut self, v: f32) {
        self.speedInMps = ::std::option::Option::Some(v);
    }

    // optional uint32 degreesClockwiseFromMagneticNorth = 5;

    pub fn degreesClockwiseFromMagneticNorth(&self) -> u32 {
        self.degreesClockwiseFromMagneticNorth.unwrap_or(0)
    }

    pub fn clear_degreesClockwiseFromMagneticNorth(&mut self) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
    }

    pub fn has_degreesClockwiseFromMagneticNorth(&self) -> bool {
        self.degreesClockwiseFromMagneticNorth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesClockwiseFromMagneticNorth(&mut self, v: u32) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(v);
    }

    // optional string caption = 6;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 sequenceNumber = 7;

    pub fn sequenceNumber(&self) -> i64 {
        self.sequenceNumber.unwrap_or(0)
    }

    pub fn clear_sequenceNumber(&mut self) {
        self.sequenceNumber = ::std::option::Option::None;
    }

    pub fn has_sequenceNumber(&self) -> bool {
        self.sequenceNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequenceNumber(&mut self, v: i64) {
        self.sequenceNumber = ::std::option::Option::Some(v);
    }

    // optional uint32 timeOffset = 8;

    pub fn timeOffset(&self) -> u32 {
        self.timeOffset.unwrap_or(0)
    }

    pub fn clear_timeOffset(&mut self) {
        self.timeOffset = ::std::option::Option::None;
    }

    pub fn has_timeOffset(&self) -> bool {
        self.timeOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeOffset(&mut self, v: u32) {
        self.timeOffset = ::std::option::Option::Some(v);
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLatitude",
            |m: &LiveLocationMessage| { &m.degreesLatitude },
            |m: &mut LiveLocationMessage| { &mut m.degreesLatitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLongitude",
            |m: &LiveLocationMessage| { &m.degreesLongitude },
            |m: &mut LiveLocationMessage| { &mut m.degreesLongitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accuracyInMeters",
            |m: &LiveLocationMessage| { &m.accuracyInMeters },
            |m: &mut LiveLocationMessage| { &mut m.accuracyInMeters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speedInMps",
            |m: &LiveLocationMessage| { &m.speedInMps },
            |m: &mut LiveLocationMessage| { &mut m.speedInMps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesClockwiseFromMagneticNorth",
            |m: &LiveLocationMessage| { &m.degreesClockwiseFromMagneticNorth },
            |m: &mut LiveLocationMessage| { &mut m.degreesClockwiseFromMagneticNorth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &LiveLocationMessage| { &m.caption },
            |m: &mut LiveLocationMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequenceNumber",
            |m: &LiveLocationMessage| { &m.sequenceNumber },
            |m: &mut LiveLocationMessage| { &mut m.sequenceNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeOffset",
            |m: &LiveLocationMessage| { &m.timeOffset },
            |m: &mut LiveLocationMessage| { &mut m.timeOffset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &LiveLocationMessage| { &m.jpegThumbnail },
            |m: &mut LiveLocationMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &LiveLocationMessage| { &m.contextInfo },
            |m: &mut LiveLocationMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveLocationMessage>(
            "LiveLocationMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LiveLocationMessage {
    const NAME: &'static str = "LiveLocationMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.degreesLatitude = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.degreesLongitude = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.accuracyInMeters = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.speedInMps = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.sequenceNumber = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.timeOffset = ::std::option::Option::Some(is.read_uint32()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.degreesLatitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.degreesLongitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accuracyInMeters {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.speedInMps {
            my_size += 1 + 4;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.sequenceNumber {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.timeOffset {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.degreesLatitude {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.degreesLongitude {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.accuracyInMeters {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.speedInMps {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.sequenceNumber {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.timeOffset {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LiveLocationMessage {
        LiveLocationMessage::new()
    }

    fn clear(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
        self.degreesLongitude = ::std::option::Option::None;
        self.accuracyInMeters = ::std::option::Option::None;
        self.speedInMps = ::std::option::Option::None;
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.sequenceNumber = ::std::option::Option::None;
        self.timeOffset = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LiveLocationMessage {
        static instance: LiveLocationMessage = LiveLocationMessage {
            degreesLatitude: ::std::option::Option::None,
            degreesLongitude: ::std::option::Option::None,
            accuracyInMeters: ::std::option::Option::None,
            speedInMps: ::std::option::Option::None,
            degreesClockwiseFromMagneticNorth: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            sequenceNumber: ::std::option::Option::None,
            timeOffset: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LiveLocationMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LiveLocationMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LiveLocationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LiveLocationMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:StickerMessage)
pub struct StickerMessage {
    // message fields
    // @@protoc_insertion_point(field:StickerMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StickerMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:StickerMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:StickerMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:StickerMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StickerMessage.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StickerMessage.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StickerMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StickerMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:StickerMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:StickerMessage.firstFrameLength)
    pub firstFrameLength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StickerMessage.firstFrameSidecar)
    pub firstFrameSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:StickerMessage.isAnimated)
    pub isAnimated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StickerMessage.pngThumbnail)
    pub pngThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:StickerMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:StickerMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StickerMessage {
    fn default() -> &'a StickerMessage {
        <StickerMessage as ::protobuf::Message>::default_instance()
    }
}

impl StickerMessage {
    pub fn new() -> StickerMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 2;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 3;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mediaKey = 4;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mimetype = 5;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 7;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional string directPath = 8;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileLength = 9;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional int64 mediaKeyTimestamp = 10;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 firstFrameLength = 11;

    pub fn firstFrameLength(&self) -> u32 {
        self.firstFrameLength.unwrap_or(0)
    }

    pub fn clear_firstFrameLength(&mut self) {
        self.firstFrameLength = ::std::option::Option::None;
    }

    pub fn has_firstFrameLength(&self) -> bool {
        self.firstFrameLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstFrameLength(&mut self, v: u32) {
        self.firstFrameLength = ::std::option::Option::Some(v);
    }

    // optional bytes firstFrameSidecar = 12;

    pub fn firstFrameSidecar(&self) -> &[u8] {
        match self.firstFrameSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_firstFrameSidecar(&mut self) {
        self.firstFrameSidecar = ::std::option::Option::None;
    }

    pub fn has_firstFrameSidecar(&self) -> bool {
        self.firstFrameSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstFrameSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.firstFrameSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstFrameSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.firstFrameSidecar.is_none() {
            self.firstFrameSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.firstFrameSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstFrameSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.firstFrameSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool isAnimated = 13;

    pub fn isAnimated(&self) -> bool {
        self.isAnimated.unwrap_or(false)
    }

    pub fn clear_isAnimated(&mut self) {
        self.isAnimated = ::std::option::Option::None;
    }

    pub fn has_isAnimated(&self) -> bool {
        self.isAnimated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isAnimated(&mut self, v: bool) {
        self.isAnimated = ::std::option::Option::Some(v);
    }

    // optional bytes pngThumbnail = 16;

    pub fn pngThumbnail(&self) -> &[u8] {
        match self.pngThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pngThumbnail(&mut self) {
        self.pngThumbnail = ::std::option::Option::None;
    }

    pub fn has_pngThumbnail(&self) -> bool {
        self.pngThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pngThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.pngThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pngThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pngThumbnail.is_none() {
            self.pngThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pngThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_pngThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.pngThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &StickerMessage| { &m.url },
            |m: &mut StickerMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &StickerMessage| { &m.fileSha256 },
            |m: &mut StickerMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &StickerMessage| { &m.fileEncSha256 },
            |m: &mut StickerMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &StickerMessage| { &m.mediaKey },
            |m: &mut StickerMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &StickerMessage| { &m.mimetype },
            |m: &mut StickerMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &StickerMessage| { &m.height },
            |m: &mut StickerMessage| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &StickerMessage| { &m.width },
            |m: &mut StickerMessage| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &StickerMessage| { &m.directPath },
            |m: &mut StickerMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &StickerMessage| { &m.fileLength },
            |m: &mut StickerMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &StickerMessage| { &m.mediaKeyTimestamp },
            |m: &mut StickerMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstFrameLength",
            |m: &StickerMessage| { &m.firstFrameLength },
            |m: &mut StickerMessage| { &mut m.firstFrameLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstFrameSidecar",
            |m: &StickerMessage| { &m.firstFrameSidecar },
            |m: &mut StickerMessage| { &mut m.firstFrameSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isAnimated",
            |m: &StickerMessage| { &m.isAnimated },
            |m: &mut StickerMessage| { &mut m.isAnimated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pngThumbnail",
            |m: &StickerMessage| { &m.pngThumbnail },
            |m: &mut StickerMessage| { &mut m.pngThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &StickerMessage| { &m.contextInfo },
            |m: &mut StickerMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StickerMessage>(
            "StickerMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StickerMessage {
    const NAME: &'static str = "StickerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                88 => {
                    self.firstFrameLength = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.firstFrameSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                104 => {
                    self.isAnimated = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    self.pngThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.firstFrameLength {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.firstFrameSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.isAnimated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pngThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.firstFrameLength {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.firstFrameSidecar.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.isAnimated {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.pngThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StickerMessage {
        StickerMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.firstFrameLength = ::std::option::Option::None;
        self.firstFrameSidecar = ::std::option::Option::None;
        self.isAnimated = ::std::option::Option::None;
        self.pngThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StickerMessage {
        static instance: StickerMessage = StickerMessage {
            url: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            firstFrameLength: ::std::option::Option::None,
            firstFrameSidecar: ::std::option::Option::None,
            isAnimated: ::std::option::Option::None,
            pngThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StickerMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StickerMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StickerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StickerMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:FourRowTemplate)
pub struct FourRowTemplate {
    // message fields
    // @@protoc_insertion_point(field:FourRowTemplate.content)
    pub content: ::protobuf::MessageField<HighlyStructuredMessage>,
    // @@protoc_insertion_point(field:FourRowTemplate.footer)
    pub footer: ::protobuf::MessageField<HighlyStructuredMessage>,
    // @@protoc_insertion_point(field:FourRowTemplate.buttons)
    pub buttons: ::std::vec::Vec<TemplateButton>,
    // message oneof groups
    pub title: ::std::option::Option<four_row_template::Title>,
    // special fields
    // @@protoc_insertion_point(special_field:FourRowTemplate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FourRowTemplate {
    fn default() -> &'a FourRowTemplate {
        <FourRowTemplate as ::protobuf::Message>::default_instance()
    }
}

impl FourRowTemplate {
    pub fn new() -> FourRowTemplate {
        ::std::default::Default::default()
    }

    // optional .DocumentMessage documentMessage = 1;

    pub fn documentMessage(&self) -> &DocumentMessage {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::DocumentMessage(ref v)) => v,
            _ => <DocumentMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_documentMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_documentMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::DocumentMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_documentMessage(&mut self, v: DocumentMessage) {
        self.title = ::std::option::Option::Some(four_row_template::Title::DocumentMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_documentMessage(&mut self) -> &mut DocumentMessage {
        if let ::std::option::Option::Some(four_row_template::Title::DocumentMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(four_row_template::Title::DocumentMessage(DocumentMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::DocumentMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_documentMessage(&mut self) -> DocumentMessage {
        if self.has_documentMessage() {
            match self.title.take() {
                ::std::option::Option::Some(four_row_template::Title::DocumentMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            DocumentMessage::new()
        }
    }

    // optional .HighlyStructuredMessage highlyStructuredMessage = 2;

    pub fn highlyStructuredMessage(&self) -> &HighlyStructuredMessage {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(ref v)) => v,
            _ => <HighlyStructuredMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_highlyStructuredMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_highlyStructuredMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_highlyStructuredMessage(&mut self, v: HighlyStructuredMessage) {
        self.title = ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_highlyStructuredMessage(&mut self) -> &mut HighlyStructuredMessage {
        if let ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(HighlyStructuredMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_highlyStructuredMessage(&mut self) -> HighlyStructuredMessage {
        if self.has_highlyStructuredMessage() {
            match self.title.take() {
                ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            HighlyStructuredMessage::new()
        }
    }

    // optional .ImageMessage imageMessage = 3;

    pub fn imageMessage(&self) -> &ImageMessage {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::ImageMessage(ref v)) => v,
            _ => <ImageMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_imageMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_imageMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::ImageMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_imageMessage(&mut self, v: ImageMessage) {
        self.title = ::std::option::Option::Some(four_row_template::Title::ImageMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_imageMessage(&mut self) -> &mut ImageMessage {
        if let ::std::option::Option::Some(four_row_template::Title::ImageMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(four_row_template::Title::ImageMessage(ImageMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::ImageMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_imageMessage(&mut self) -> ImageMessage {
        if self.has_imageMessage() {
            match self.title.take() {
                ::std::option::Option::Some(four_row_template::Title::ImageMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ImageMessage::new()
        }
    }

    // optional .VideoMessage videoMessage = 4;

    pub fn videoMessage(&self) -> &VideoMessage {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::VideoMessage(ref v)) => v,
            _ => <VideoMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_videoMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::VideoMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoMessage(&mut self, v: VideoMessage) {
        self.title = ::std::option::Option::Some(four_row_template::Title::VideoMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoMessage(&mut self) -> &mut VideoMessage {
        if let ::std::option::Option::Some(four_row_template::Title::VideoMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(four_row_template::Title::VideoMessage(VideoMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::VideoMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoMessage(&mut self) -> VideoMessage {
        if self.has_videoMessage() {
            match self.title.take() {
                ::std::option::Option::Some(four_row_template::Title::VideoMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoMessage::new()
        }
    }

    // optional .LocationMessage locationMessage = 5;

    pub fn locationMessage(&self) -> &LocationMessage {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::LocationMessage(ref v)) => v,
            _ => <LocationMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_locationMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_locationMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::LocationMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_locationMessage(&mut self, v: LocationMessage) {
        self.title = ::std::option::Option::Some(four_row_template::Title::LocationMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_locationMessage(&mut self) -> &mut LocationMessage {
        if let ::std::option::Option::Some(four_row_template::Title::LocationMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(four_row_template::Title::LocationMessage(LocationMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(four_row_template::Title::LocationMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_locationMessage(&mut self) -> LocationMessage {
        if self.has_locationMessage() {
            match self.title.take() {
                ::std::option::Option::Some(four_row_template::Title::LocationMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            LocationMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "content",
            |m: &FourRowTemplate| { &m.content },
            |m: &mut FourRowTemplate| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "footer",
            |m: &FourRowTemplate| { &m.footer },
            |m: &mut FourRowTemplate| { &mut m.footer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buttons",
            |m: &FourRowTemplate| { &m.buttons },
            |m: &mut FourRowTemplate| { &mut m.buttons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DocumentMessage>(
            "documentMessage",
            FourRowTemplate::has_documentMessage,
            FourRowTemplate::documentMessage,
            FourRowTemplate::mut_documentMessage,
            FourRowTemplate::set_documentMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HighlyStructuredMessage>(
            "highlyStructuredMessage",
            FourRowTemplate::has_highlyStructuredMessage,
            FourRowTemplate::highlyStructuredMessage,
            FourRowTemplate::mut_highlyStructuredMessage,
            FourRowTemplate::set_highlyStructuredMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ImageMessage>(
            "imageMessage",
            FourRowTemplate::has_imageMessage,
            FourRowTemplate::imageMessage,
            FourRowTemplate::mut_imageMessage,
            FourRowTemplate::set_imageMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoMessage>(
            "videoMessage",
            FourRowTemplate::has_videoMessage,
            FourRowTemplate::videoMessage,
            FourRowTemplate::mut_videoMessage,
            FourRowTemplate::set_videoMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LocationMessage>(
            "locationMessage",
            FourRowTemplate::has_locationMessage,
            FourRowTemplate::locationMessage,
            FourRowTemplate::mut_locationMessage,
            FourRowTemplate::set_locationMessage,
        ));
        oneofs.push(four_row_template::Title::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FourRowTemplate>(
            "FourRowTemplate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FourRowTemplate {
    const NAME: &'static str = "FourRowTemplate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.content)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.footer)?;
                },
                66 => {
                    self.buttons.push(is.read_message()?);
                },
                10 => {
                    self.title = ::std::option::Option::Some(four_row_template::Title::DocumentMessage(is.read_message()?));
                },
                18 => {
                    self.title = ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(is.read_message()?));
                },
                26 => {
                    self.title = ::std::option::Option::Some(four_row_template::Title::ImageMessage(is.read_message()?));
                },
                34 => {
                    self.title = ::std::option::Option::Some(four_row_template::Title::VideoMessage(is.read_message()?));
                },
                42 => {
                    self.title = ::std::option::Option::Some(four_row_template::Title::LocationMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.footer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.buttons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.title {
            match v {
                &four_row_template::Title::DocumentMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &four_row_template::Title::HighlyStructuredMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &four_row_template::Title::ImageMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &four_row_template::Title::VideoMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &four_row_template::Title::LocationMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.content.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.footer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.buttons {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.title {
            match v {
                &four_row_template::Title::DocumentMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &four_row_template::Title::HighlyStructuredMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &four_row_template::Title::ImageMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &four_row_template::Title::VideoMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &four_row_template::Title::LocationMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FourRowTemplate {
        FourRowTemplate::new()
    }

    fn clear(&mut self) {
        self.content.clear();
        self.footer.clear();
        self.buttons.clear();
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FourRowTemplate {
        static instance: FourRowTemplate = FourRowTemplate {
            content: ::protobuf::MessageField::none(),
            footer: ::protobuf::MessageField::none(),
            buttons: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FourRowTemplate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FourRowTemplate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FourRowTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FourRowTemplate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FourRowTemplate`
pub mod four_row_template {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:FourRowTemplate.title)
    pub enum Title {
        // @@protoc_insertion_point(oneof_field:FourRowTemplate.documentMessage)
        DocumentMessage(super::DocumentMessage),
        // @@protoc_insertion_point(oneof_field:FourRowTemplate.highlyStructuredMessage)
        HighlyStructuredMessage(super::HighlyStructuredMessage),
        // @@protoc_insertion_point(oneof_field:FourRowTemplate.imageMessage)
        ImageMessage(super::ImageMessage),
        // @@protoc_insertion_point(oneof_field:FourRowTemplate.videoMessage)
        VideoMessage(super::VideoMessage),
        // @@protoc_insertion_point(oneof_field:FourRowTemplate.locationMessage)
        LocationMessage(super::LocationMessage),
    }

    impl ::protobuf::Oneof for Title {
    }

    impl ::protobuf::OneofFull for Title {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::FourRowTemplate as ::protobuf::MessageFull>::descriptor().oneof_by_name("title").unwrap()).clone()
        }
    }

    impl Title {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Title>("title")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HydratedFourRowTemplate)
pub struct HydratedFourRowTemplate {
    // message fields
    // @@protoc_insertion_point(field:HydratedFourRowTemplate.hydratedContentText)
    pub hydratedContentText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HydratedFourRowTemplate.hydratedFooterText)
    pub hydratedFooterText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HydratedFourRowTemplate.hydratedButtons)
    pub hydratedButtons: ::std::vec::Vec<HydratedTemplateButton>,
    // @@protoc_insertion_point(field:HydratedFourRowTemplate.templateId)
    pub templateId: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub title: ::std::option::Option<hydrated_four_row_template::Title>,
    // special fields
    // @@protoc_insertion_point(special_field:HydratedFourRowTemplate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HydratedFourRowTemplate {
    fn default() -> &'a HydratedFourRowTemplate {
        <HydratedFourRowTemplate as ::protobuf::Message>::default_instance()
    }
}

impl HydratedFourRowTemplate {
    pub fn new() -> HydratedFourRowTemplate {
        ::std::default::Default::default()
    }

    // optional string hydratedContentText = 6;

    pub fn hydratedContentText(&self) -> &str {
        match self.hydratedContentText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hydratedContentText(&mut self) {
        self.hydratedContentText = ::std::option::Option::None;
    }

    pub fn has_hydratedContentText(&self) -> bool {
        self.hydratedContentText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hydratedContentText(&mut self, v: ::std::string::String) {
        self.hydratedContentText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hydratedContentText(&mut self) -> &mut ::std::string::String {
        if self.hydratedContentText.is_none() {
            self.hydratedContentText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hydratedContentText.as_mut().unwrap()
    }

    // Take field
    pub fn take_hydratedContentText(&mut self) -> ::std::string::String {
        self.hydratedContentText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hydratedFooterText = 7;

    pub fn hydratedFooterText(&self) -> &str {
        match self.hydratedFooterText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hydratedFooterText(&mut self) {
        self.hydratedFooterText = ::std::option::Option::None;
    }

    pub fn has_hydratedFooterText(&self) -> bool {
        self.hydratedFooterText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hydratedFooterText(&mut self, v: ::std::string::String) {
        self.hydratedFooterText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hydratedFooterText(&mut self) -> &mut ::std::string::String {
        if self.hydratedFooterText.is_none() {
            self.hydratedFooterText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hydratedFooterText.as_mut().unwrap()
    }

    // Take field
    pub fn take_hydratedFooterText(&mut self) -> ::std::string::String {
        self.hydratedFooterText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string templateId = 9;

    pub fn templateId(&self) -> &str {
        match self.templateId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_templateId(&mut self) {
        self.templateId = ::std::option::Option::None;
    }

    pub fn has_templateId(&self) -> bool {
        self.templateId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_templateId(&mut self, v: ::std::string::String) {
        self.templateId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_templateId(&mut self) -> &mut ::std::string::String {
        if self.templateId.is_none() {
            self.templateId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.templateId.as_mut().unwrap()
    }

    // Take field
    pub fn take_templateId(&mut self) -> ::std::string::String {
        self.templateId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .DocumentMessage documentMessage = 1;

    pub fn documentMessage(&self) -> &DocumentMessage {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(ref v)) => v,
            _ => <DocumentMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_documentMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_documentMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_documentMessage(&mut self, v: DocumentMessage) {
        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_documentMessage(&mut self) -> &mut DocumentMessage {
        if let ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(DocumentMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_documentMessage(&mut self) -> DocumentMessage {
        if self.has_documentMessage() {
            match self.title.take() {
                ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            DocumentMessage::new()
        }
    }

    // optional string hydratedTitleText = 2;

    pub fn hydratedTitleText(&self) -> &str {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_hydratedTitleText(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_hydratedTitleText(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hydratedTitleText(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hydratedTitleText(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(::std::string::String::new()));
        }
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hydratedTitleText(&mut self) -> ::std::string::String {
        if self.has_hydratedTitleText() {
            match self.title.take() {
                ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .ImageMessage imageMessage = 3;

    pub fn imageMessage(&self) -> &ImageMessage {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(ref v)) => v,
            _ => <ImageMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_imageMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_imageMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_imageMessage(&mut self, v: ImageMessage) {
        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_imageMessage(&mut self) -> &mut ImageMessage {
        if let ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(ImageMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_imageMessage(&mut self) -> ImageMessage {
        if self.has_imageMessage() {
            match self.title.take() {
                ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ImageMessage::new()
        }
    }

    // optional .VideoMessage videoMessage = 4;

    pub fn videoMessage(&self) -> &VideoMessage {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(ref v)) => v,
            _ => <VideoMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_videoMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoMessage(&mut self, v: VideoMessage) {
        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoMessage(&mut self) -> &mut VideoMessage {
        if let ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(VideoMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoMessage(&mut self) -> VideoMessage {
        if self.has_videoMessage() {
            match self.title.take() {
                ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoMessage::new()
        }
    }

    // optional .LocationMessage locationMessage = 5;

    pub fn locationMessage(&self) -> &LocationMessage {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(ref v)) => v,
            _ => <LocationMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_locationMessage(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_locationMessage(&self) -> bool {
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_locationMessage(&mut self, v: LocationMessage) {
        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_locationMessage(&mut self) -> &mut LocationMessage {
        if let ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(_)) = self.title {
        } else {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(LocationMessage::new()));
        }
        match self.title {
            ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_locationMessage(&mut self) -> LocationMessage {
        if self.has_locationMessage() {
            match self.title.take() {
                ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            LocationMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hydratedContentText",
            |m: &HydratedFourRowTemplate| { &m.hydratedContentText },
            |m: &mut HydratedFourRowTemplate| { &mut m.hydratedContentText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hydratedFooterText",
            |m: &HydratedFourRowTemplate| { &m.hydratedFooterText },
            |m: &mut HydratedFourRowTemplate| { &mut m.hydratedFooterText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hydratedButtons",
            |m: &HydratedFourRowTemplate| { &m.hydratedButtons },
            |m: &mut HydratedFourRowTemplate| { &mut m.hydratedButtons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "templateId",
            |m: &HydratedFourRowTemplate| { &m.templateId },
            |m: &mut HydratedFourRowTemplate| { &mut m.templateId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DocumentMessage>(
            "documentMessage",
            HydratedFourRowTemplate::has_documentMessage,
            HydratedFourRowTemplate::documentMessage,
            HydratedFourRowTemplate::mut_documentMessage,
            HydratedFourRowTemplate::set_documentMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "hydratedTitleText",
            HydratedFourRowTemplate::has_hydratedTitleText,
            HydratedFourRowTemplate::hydratedTitleText,
            HydratedFourRowTemplate::set_hydratedTitleText,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ImageMessage>(
            "imageMessage",
            HydratedFourRowTemplate::has_imageMessage,
            HydratedFourRowTemplate::imageMessage,
            HydratedFourRowTemplate::mut_imageMessage,
            HydratedFourRowTemplate::set_imageMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoMessage>(
            "videoMessage",
            HydratedFourRowTemplate::has_videoMessage,
            HydratedFourRowTemplate::videoMessage,
            HydratedFourRowTemplate::mut_videoMessage,
            HydratedFourRowTemplate::set_videoMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LocationMessage>(
            "locationMessage",
            HydratedFourRowTemplate::has_locationMessage,
            HydratedFourRowTemplate::locationMessage,
            HydratedFourRowTemplate::mut_locationMessage,
            HydratedFourRowTemplate::set_locationMessage,
        ));
        oneofs.push(hydrated_four_row_template::Title::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedFourRowTemplate>(
            "HydratedFourRowTemplate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HydratedFourRowTemplate {
    const NAME: &'static str = "HydratedFourRowTemplate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.hydratedContentText = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.hydratedFooterText = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.hydratedButtons.push(is.read_message()?);
                },
                74 => {
                    self.templateId = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(is.read_message()?));
                },
                18 => {
                    self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(is.read_string()?));
                },
                26 => {
                    self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(is.read_message()?));
                },
                34 => {
                    self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(is.read_message()?));
                },
                42 => {
                    self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hydratedContentText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.hydratedFooterText.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.hydratedButtons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.templateId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.title {
            match v {
                &hydrated_four_row_template::Title::DocumentMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hydrated_four_row_template::Title::HydratedTitleText(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &hydrated_four_row_template::Title::ImageMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hydrated_four_row_template::Title::VideoMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hydrated_four_row_template::Title::LocationMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hydratedContentText.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.hydratedFooterText.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.hydratedButtons {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.templateId.as_ref() {
            os.write_string(9, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.title {
            match v {
                &hydrated_four_row_template::Title::DocumentMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &hydrated_four_row_template::Title::HydratedTitleText(ref v) => {
                    os.write_string(2, v)?;
                },
                &hydrated_four_row_template::Title::ImageMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &hydrated_four_row_template::Title::VideoMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &hydrated_four_row_template::Title::LocationMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HydratedFourRowTemplate {
        HydratedFourRowTemplate::new()
    }

    fn clear(&mut self) {
        self.hydratedContentText = ::std::option::Option::None;
        self.hydratedFooterText = ::std::option::Option::None;
        self.hydratedButtons.clear();
        self.templateId = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HydratedFourRowTemplate {
        static instance: HydratedFourRowTemplate = HydratedFourRowTemplate {
            hydratedContentText: ::std::option::Option::None,
            hydratedFooterText: ::std::option::Option::None,
            hydratedButtons: ::std::vec::Vec::new(),
            templateId: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HydratedFourRowTemplate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HydratedFourRowTemplate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HydratedFourRowTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HydratedFourRowTemplate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HydratedFourRowTemplate`
pub mod hydrated_four_row_template {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:HydratedFourRowTemplate.title)
    pub enum Title {
        // @@protoc_insertion_point(oneof_field:HydratedFourRowTemplate.documentMessage)
        DocumentMessage(super::DocumentMessage),
        // @@protoc_insertion_point(oneof_field:HydratedFourRowTemplate.hydratedTitleText)
        HydratedTitleText(::std::string::String),
        // @@protoc_insertion_point(oneof_field:HydratedFourRowTemplate.imageMessage)
        ImageMessage(super::ImageMessage),
        // @@protoc_insertion_point(oneof_field:HydratedFourRowTemplate.videoMessage)
        VideoMessage(super::VideoMessage),
        // @@protoc_insertion_point(oneof_field:HydratedFourRowTemplate.locationMessage)
        LocationMessage(super::LocationMessage),
    }

    impl ::protobuf::Oneof for Title {
    }

    impl ::protobuf::OneofFull for Title {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::HydratedFourRowTemplate as ::protobuf::MessageFull>::descriptor().oneof_by_name("title").unwrap()).clone()
        }
    }

    impl Title {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Title>("title")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TemplateMessage)
pub struct TemplateMessage {
    // message fields
    // @@protoc_insertion_point(field:TemplateMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:TemplateMessage.hydratedTemplate)
    pub hydratedTemplate: ::protobuf::MessageField<HydratedFourRowTemplate>,
    // message oneof groups
    pub format: ::std::option::Option<template_message::Format>,
    // special fields
    // @@protoc_insertion_point(special_field:TemplateMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TemplateMessage {
    fn default() -> &'a TemplateMessage {
        <TemplateMessage as ::protobuf::Message>::default_instance()
    }
}

impl TemplateMessage {
    pub fn new() -> TemplateMessage {
        ::std::default::Default::default()
    }

    // optional .FourRowTemplate fourRowTemplate = 1;

    pub fn fourRowTemplate(&self) -> &FourRowTemplate {
        match self.format {
            ::std::option::Option::Some(template_message::Format::FourRowTemplate(ref v)) => v,
            _ => <FourRowTemplate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fourRowTemplate(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_fourRowTemplate(&self) -> bool {
        match self.format {
            ::std::option::Option::Some(template_message::Format::FourRowTemplate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fourRowTemplate(&mut self, v: FourRowTemplate) {
        self.format = ::std::option::Option::Some(template_message::Format::FourRowTemplate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fourRowTemplate(&mut self) -> &mut FourRowTemplate {
        if let ::std::option::Option::Some(template_message::Format::FourRowTemplate(_)) = self.format {
        } else {
            self.format = ::std::option::Option::Some(template_message::Format::FourRowTemplate(FourRowTemplate::new()));
        }
        match self.format {
            ::std::option::Option::Some(template_message::Format::FourRowTemplate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fourRowTemplate(&mut self) -> FourRowTemplate {
        if self.has_fourRowTemplate() {
            match self.format.take() {
                ::std::option::Option::Some(template_message::Format::FourRowTemplate(v)) => v,
                _ => panic!(),
            }
        } else {
            FourRowTemplate::new()
        }
    }

    // optional .HydratedFourRowTemplate hydratedFourRowTemplate = 2;

    pub fn hydratedFourRowTemplate(&self) -> &HydratedFourRowTemplate {
        match self.format {
            ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(ref v)) => v,
            _ => <HydratedFourRowTemplate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hydratedFourRowTemplate(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_hydratedFourRowTemplate(&self) -> bool {
        match self.format {
            ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hydratedFourRowTemplate(&mut self, v: HydratedFourRowTemplate) {
        self.format = ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hydratedFourRowTemplate(&mut self) -> &mut HydratedFourRowTemplate {
        if let ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(_)) = self.format {
        } else {
            self.format = ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(HydratedFourRowTemplate::new()));
        }
        match self.format {
            ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hydratedFourRowTemplate(&mut self) -> HydratedFourRowTemplate {
        if self.has_hydratedFourRowTemplate() {
            match self.format.take() {
                ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(v)) => v,
                _ => panic!(),
            }
        } else {
            HydratedFourRowTemplate::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &TemplateMessage| { &m.contextInfo },
            |m: &mut TemplateMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HydratedFourRowTemplate>(
            "hydratedTemplate",
            |m: &TemplateMessage| { &m.hydratedTemplate },
            |m: &mut TemplateMessage| { &mut m.hydratedTemplate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FourRowTemplate>(
            "fourRowTemplate",
            TemplateMessage::has_fourRowTemplate,
            TemplateMessage::fourRowTemplate,
            TemplateMessage::mut_fourRowTemplate,
            TemplateMessage::set_fourRowTemplate,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HydratedFourRowTemplate>(
            "hydratedFourRowTemplate",
            TemplateMessage::has_hydratedFourRowTemplate,
            TemplateMessage::hydratedFourRowTemplate,
            TemplateMessage::mut_hydratedFourRowTemplate,
            TemplateMessage::set_hydratedFourRowTemplate,
        ));
        oneofs.push(template_message::Format::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TemplateMessage>(
            "TemplateMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TemplateMessage {
    const NAME: &'static str = "TemplateMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hydratedTemplate)?;
                },
                10 => {
                    self.format = ::std::option::Option::Some(template_message::Format::FourRowTemplate(is.read_message()?));
                },
                18 => {
                    self.format = ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hydratedTemplate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.format {
            match v {
                &template_message::Format::FourRowTemplate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &template_message::Format::HydratedFourRowTemplate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.hydratedTemplate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.format {
            match v {
                &template_message::Format::FourRowTemplate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &template_message::Format::HydratedFourRowTemplate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TemplateMessage {
        TemplateMessage::new()
    }

    fn clear(&mut self) {
        self.contextInfo.clear();
        self.hydratedTemplate.clear();
        self.format = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TemplateMessage {
        static instance: TemplateMessage = TemplateMessage {
            contextInfo: ::protobuf::MessageField::none(),
            hydratedTemplate: ::protobuf::MessageField::none(),
            format: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TemplateMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TemplateMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TemplateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TemplateMessage`
pub mod template_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TemplateMessage.format)
    pub enum Format {
        // @@protoc_insertion_point(oneof_field:TemplateMessage.fourRowTemplate)
        FourRowTemplate(super::FourRowTemplate),
        // @@protoc_insertion_point(oneof_field:TemplateMessage.hydratedFourRowTemplate)
        HydratedFourRowTemplate(super::HydratedFourRowTemplate),
    }

    impl ::protobuf::Oneof for Format {
    }

    impl ::protobuf::OneofFull for Format {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TemplateMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("format").unwrap()).clone()
        }
    }

    impl Format {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Format>("format")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TemplateButtonReplyMessage)
pub struct TemplateButtonReplyMessage {
    // message fields
    // @@protoc_insertion_point(field:TemplateButtonReplyMessage.selectedId)
    pub selectedId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TemplateButtonReplyMessage.selectedDisplayText)
    pub selectedDisplayText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TemplateButtonReplyMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:TemplateButtonReplyMessage.selectedIndex)
    pub selectedIndex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TemplateButtonReplyMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TemplateButtonReplyMessage {
    fn default() -> &'a TemplateButtonReplyMessage {
        <TemplateButtonReplyMessage as ::protobuf::Message>::default_instance()
    }
}

impl TemplateButtonReplyMessage {
    pub fn new() -> TemplateButtonReplyMessage {
        ::std::default::Default::default()
    }

    // optional string selectedId = 1;

    pub fn selectedId(&self) -> &str {
        match self.selectedId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedId(&mut self) {
        self.selectedId = ::std::option::Option::None;
    }

    pub fn has_selectedId(&self) -> bool {
        self.selectedId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedId(&mut self, v: ::std::string::String) {
        self.selectedId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedId(&mut self) -> &mut ::std::string::String {
        if self.selectedId.is_none() {
            self.selectedId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedId.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedId(&mut self) -> ::std::string::String {
        self.selectedId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string selectedDisplayText = 2;

    pub fn selectedDisplayText(&self) -> &str {
        match self.selectedDisplayText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedDisplayText(&mut self) {
        self.selectedDisplayText = ::std::option::Option::None;
    }

    pub fn has_selectedDisplayText(&self) -> bool {
        self.selectedDisplayText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedDisplayText(&mut self, v: ::std::string::String) {
        self.selectedDisplayText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedDisplayText(&mut self) -> &mut ::std::string::String {
        if self.selectedDisplayText.is_none() {
            self.selectedDisplayText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedDisplayText.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedDisplayText(&mut self) -> ::std::string::String {
        self.selectedDisplayText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 selectedIndex = 4;

    pub fn selectedIndex(&self) -> u32 {
        self.selectedIndex.unwrap_or(0)
    }

    pub fn clear_selectedIndex(&mut self) {
        self.selectedIndex = ::std::option::Option::None;
    }

    pub fn has_selectedIndex(&self) -> bool {
        self.selectedIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedIndex(&mut self, v: u32) {
        self.selectedIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedId",
            |m: &TemplateButtonReplyMessage| { &m.selectedId },
            |m: &mut TemplateButtonReplyMessage| { &mut m.selectedId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedDisplayText",
            |m: &TemplateButtonReplyMessage| { &m.selectedDisplayText },
            |m: &mut TemplateButtonReplyMessage| { &mut m.selectedDisplayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &TemplateButtonReplyMessage| { &m.contextInfo },
            |m: &mut TemplateButtonReplyMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedIndex",
            |m: &TemplateButtonReplyMessage| { &m.selectedIndex },
            |m: &mut TemplateButtonReplyMessage| { &mut m.selectedIndex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TemplateButtonReplyMessage>(
            "TemplateButtonReplyMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TemplateButtonReplyMessage {
    const NAME: &'static str = "TemplateButtonReplyMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectedId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.selectedDisplayText = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                32 => {
                    self.selectedIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selectedId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.selectedDisplayText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.selectedIndex {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selectedId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.selectedDisplayText.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.selectedIndex {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TemplateButtonReplyMessage {
        TemplateButtonReplyMessage::new()
    }

    fn clear(&mut self) {
        self.selectedId = ::std::option::Option::None;
        self.selectedDisplayText = ::std::option::Option::None;
        self.contextInfo.clear();
        self.selectedIndex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TemplateButtonReplyMessage {
        static instance: TemplateButtonReplyMessage = TemplateButtonReplyMessage {
            selectedId: ::std::option::Option::None,
            selectedDisplayText: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            selectedIndex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TemplateButtonReplyMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TemplateButtonReplyMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TemplateButtonReplyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateButtonReplyMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CatalogSnapshot)
pub struct CatalogSnapshot {
    // message fields
    // @@protoc_insertion_point(field:CatalogSnapshot.catalogImage)
    pub catalogImage: ::protobuf::MessageField<ImageMessage>,
    // @@protoc_insertion_point(field:CatalogSnapshot.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CatalogSnapshot.description)
    pub description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CatalogSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CatalogSnapshot {
    fn default() -> &'a CatalogSnapshot {
        <CatalogSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl CatalogSnapshot {
    pub fn new() -> CatalogSnapshot {
        ::std::default::Default::default()
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 3;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageMessage>(
            "catalogImage",
            |m: &CatalogSnapshot| { &m.catalogImage },
            |m: &mut CatalogSnapshot| { &mut m.catalogImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CatalogSnapshot| { &m.title },
            |m: &mut CatalogSnapshot| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CatalogSnapshot| { &m.description },
            |m: &mut CatalogSnapshot| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CatalogSnapshot>(
            "CatalogSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CatalogSnapshot {
    const NAME: &'static str = "CatalogSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.catalogImage)?;
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.catalogImage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.catalogImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CatalogSnapshot {
        CatalogSnapshot::new()
    }

    fn clear(&mut self) {
        self.catalogImage.clear();
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CatalogSnapshot {
        static instance: CatalogSnapshot = CatalogSnapshot {
            catalogImage: ::protobuf::MessageField::none(),
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CatalogSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CatalogSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CatalogSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CatalogSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ProductSnapshot)
pub struct ProductSnapshot {
    // message fields
    // @@protoc_insertion_point(field:ProductSnapshot.productImage)
    pub productImage: ::protobuf::MessageField<ImageMessage>,
    // @@protoc_insertion_point(field:ProductSnapshot.productId)
    pub productId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSnapshot.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSnapshot.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSnapshot.currencyCode)
    pub currencyCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSnapshot.priceAmount1000)
    pub priceAmount1000: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProductSnapshot.retailerId)
    pub retailerId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSnapshot.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSnapshot.productImageCount)
    pub productImageCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProductSnapshot.firstImageId)
    pub firstImageId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSnapshot.salePriceAmount1000)
    pub salePriceAmount1000: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProductSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSnapshot {
    fn default() -> &'a ProductSnapshot {
        <ProductSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl ProductSnapshot {
    pub fn new() -> ProductSnapshot {
        ::std::default::Default::default()
    }

    // optional string productId = 2;

    pub fn productId(&self) -> &str {
        match self.productId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_productId(&mut self) {
        self.productId = ::std::option::Option::None;
    }

    pub fn has_productId(&self) -> bool {
        self.productId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_productId(&mut self, v: ::std::string::String) {
        self.productId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productId(&mut self) -> &mut ::std::string::String {
        if self.productId.is_none() {
            self.productId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.productId.as_mut().unwrap()
    }

    // Take field
    pub fn take_productId(&mut self) -> ::std::string::String {
        self.productId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string currencyCode = 5;

    pub fn currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currencyCode(&mut self) {
        self.currencyCode = ::std::option::Option::None;
    }

    pub fn has_currencyCode(&self) -> bool {
        self.currencyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyCode(&mut self, v: ::std::string::String) {
        self.currencyCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currencyCode(&mut self) -> &mut ::std::string::String {
        if self.currencyCode.is_none() {
            self.currencyCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currencyCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_currencyCode(&mut self) -> ::std::string::String {
        self.currencyCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 priceAmount1000 = 6;

    pub fn priceAmount1000(&self) -> i64 {
        self.priceAmount1000.unwrap_or(0)
    }

    pub fn clear_priceAmount1000(&mut self) {
        self.priceAmount1000 = ::std::option::Option::None;
    }

    pub fn has_priceAmount1000(&self) -> bool {
        self.priceAmount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priceAmount1000(&mut self, v: i64) {
        self.priceAmount1000 = ::std::option::Option::Some(v);
    }

    // optional string retailerId = 7;

    pub fn retailerId(&self) -> &str {
        match self.retailerId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_retailerId(&mut self) {
        self.retailerId = ::std::option::Option::None;
    }

    pub fn has_retailerId(&self) -> bool {
        self.retailerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retailerId(&mut self, v: ::std::string::String) {
        self.retailerId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retailerId(&mut self) -> &mut ::std::string::String {
        if self.retailerId.is_none() {
            self.retailerId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.retailerId.as_mut().unwrap()
    }

    // Take field
    pub fn take_retailerId(&mut self) -> ::std::string::String {
        self.retailerId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 8;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 productImageCount = 9;

    pub fn productImageCount(&self) -> u32 {
        self.productImageCount.unwrap_or(0)
    }

    pub fn clear_productImageCount(&mut self) {
        self.productImageCount = ::std::option::Option::None;
    }

    pub fn has_productImageCount(&self) -> bool {
        self.productImageCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_productImageCount(&mut self, v: u32) {
        self.productImageCount = ::std::option::Option::Some(v);
    }

    // optional string firstImageId = 11;

    pub fn firstImageId(&self) -> &str {
        match self.firstImageId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_firstImageId(&mut self) {
        self.firstImageId = ::std::option::Option::None;
    }

    pub fn has_firstImageId(&self) -> bool {
        self.firstImageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstImageId(&mut self, v: ::std::string::String) {
        self.firstImageId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstImageId(&mut self) -> &mut ::std::string::String {
        if self.firstImageId.is_none() {
            self.firstImageId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.firstImageId.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstImageId(&mut self) -> ::std::string::String {
        self.firstImageId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 salePriceAmount1000 = 12;

    pub fn salePriceAmount1000(&self) -> i64 {
        self.salePriceAmount1000.unwrap_or(0)
    }

    pub fn clear_salePriceAmount1000(&mut self) {
        self.salePriceAmount1000 = ::std::option::Option::None;
    }

    pub fn has_salePriceAmount1000(&self) -> bool {
        self.salePriceAmount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salePriceAmount1000(&mut self, v: i64) {
        self.salePriceAmount1000 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageMessage>(
            "productImage",
            |m: &ProductSnapshot| { &m.productImage },
            |m: &mut ProductSnapshot| { &mut m.productImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "productId",
            |m: &ProductSnapshot| { &m.productId },
            |m: &mut ProductSnapshot| { &mut m.productId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ProductSnapshot| { &m.title },
            |m: &mut ProductSnapshot| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ProductSnapshot| { &m.description },
            |m: &mut ProductSnapshot| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyCode",
            |m: &ProductSnapshot| { &m.currencyCode },
            |m: &mut ProductSnapshot| { &mut m.currencyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priceAmount1000",
            |m: &ProductSnapshot| { &m.priceAmount1000 },
            |m: &mut ProductSnapshot| { &mut m.priceAmount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "retailerId",
            |m: &ProductSnapshot| { &m.retailerId },
            |m: &mut ProductSnapshot| { &mut m.retailerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &ProductSnapshot| { &m.url },
            |m: &mut ProductSnapshot| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "productImageCount",
            |m: &ProductSnapshot| { &m.productImageCount },
            |m: &mut ProductSnapshot| { &mut m.productImageCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstImageId",
            |m: &ProductSnapshot| { &m.firstImageId },
            |m: &mut ProductSnapshot| { &mut m.firstImageId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "salePriceAmount1000",
            |m: &ProductSnapshot| { &m.salePriceAmount1000 },
            |m: &mut ProductSnapshot| { &mut m.salePriceAmount1000 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSnapshot>(
            "ProductSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSnapshot {
    const NAME: &'static str = "ProductSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.productImage)?;
                },
                18 => {
                    self.productId = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.currencyCode = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.priceAmount1000 = ::std::option::Option::Some(is.read_int64()?);
                },
                58 => {
                    self.retailerId = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.productImageCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.firstImageId = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.salePriceAmount1000 = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.productImage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.productId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.priceAmount1000 {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.retailerId.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.productImageCount {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.firstImageId.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.salePriceAmount1000 {
            my_size += ::protobuf::rt::int64_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.productImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.productId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.priceAmount1000 {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.retailerId.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.productImageCount {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.firstImageId.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.salePriceAmount1000 {
            os.write_int64(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSnapshot {
        ProductSnapshot::new()
    }

    fn clear(&mut self) {
        self.productImage.clear();
        self.productId = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.currencyCode = ::std::option::Option::None;
        self.priceAmount1000 = ::std::option::Option::None;
        self.retailerId = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.productImageCount = ::std::option::Option::None;
        self.firstImageId = ::std::option::Option::None;
        self.salePriceAmount1000 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSnapshot {
        static instance: ProductSnapshot = ProductSnapshot {
            productImage: ::protobuf::MessageField::none(),
            productId: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            currencyCode: ::std::option::Option::None,
            priceAmount1000: ::std::option::Option::None,
            retailerId: ::std::option::Option::None,
            url: ::std::option::Option::None,
            productImageCount: ::std::option::Option::None,
            firstImageId: ::std::option::Option::None,
            salePriceAmount1000: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ProductMessage)
pub struct ProductMessage {
    // message fields
    // @@protoc_insertion_point(field:ProductMessage.product)
    pub product: ::protobuf::MessageField<ProductSnapshot>,
    // @@protoc_insertion_point(field:ProductMessage.businessOwnerJid)
    pub businessOwnerJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductMessage.catalog)
    pub catalog: ::protobuf::MessageField<CatalogSnapshot>,
    // @@protoc_insertion_point(field:ProductMessage.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductMessage.footer)
    pub footer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ProductMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductMessage {
    fn default() -> &'a ProductMessage {
        <ProductMessage as ::protobuf::Message>::default_instance()
    }
}

impl ProductMessage {
    pub fn new() -> ProductMessage {
        ::std::default::Default::default()
    }

    // optional string businessOwnerJid = 2;

    pub fn businessOwnerJid(&self) -> &str {
        match self.businessOwnerJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_businessOwnerJid(&mut self) {
        self.businessOwnerJid = ::std::option::Option::None;
    }

    pub fn has_businessOwnerJid(&self) -> bool {
        self.businessOwnerJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_businessOwnerJid(&mut self, v: ::std::string::String) {
        self.businessOwnerJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_businessOwnerJid(&mut self) -> &mut ::std::string::String {
        if self.businessOwnerJid.is_none() {
            self.businessOwnerJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.businessOwnerJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_businessOwnerJid(&mut self) -> ::std::string::String {
        self.businessOwnerJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 5;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string footer = 6;

    pub fn footer(&self) -> &str {
        match self.footer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_footer(&mut self) {
        self.footer = ::std::option::Option::None;
    }

    pub fn has_footer(&self) -> bool {
        self.footer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footer(&mut self, v: ::std::string::String) {
        self.footer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footer(&mut self) -> &mut ::std::string::String {
        if self.footer.is_none() {
            self.footer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.footer.as_mut().unwrap()
    }

    // Take field
    pub fn take_footer(&mut self) -> ::std::string::String {
        self.footer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductSnapshot>(
            "product",
            |m: &ProductMessage| { &m.product },
            |m: &mut ProductMessage| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "businessOwnerJid",
            |m: &ProductMessage| { &m.businessOwnerJid },
            |m: &mut ProductMessage| { &mut m.businessOwnerJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CatalogSnapshot>(
            "catalog",
            |m: &ProductMessage| { &m.catalog },
            |m: &mut ProductMessage| { &mut m.catalog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &ProductMessage| { &m.body },
            |m: &mut ProductMessage| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footer",
            |m: &ProductMessage| { &m.footer },
            |m: &mut ProductMessage| { &mut m.footer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ProductMessage| { &m.contextInfo },
            |m: &mut ProductMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductMessage>(
            "ProductMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductMessage {
    const NAME: &'static str = "ProductMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.product)?;
                },
                18 => {
                    self.businessOwnerJid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.catalog)?;
                },
                42 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.footer = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.businessOwnerJid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.catalog.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.footer.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.product.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.businessOwnerJid.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.catalog.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.footer.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductMessage {
        ProductMessage::new()
    }

    fn clear(&mut self) {
        self.product.clear();
        self.businessOwnerJid = ::std::option::Option::None;
        self.catalog.clear();
        self.body = ::std::option::Option::None;
        self.footer = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductMessage {
        static instance: ProductMessage = ProductMessage {
            product: ::protobuf::MessageField::none(),
            businessOwnerJid: ::std::option::Option::None,
            catalog: ::protobuf::MessageField::none(),
            body: ::std::option::Option::None,
            footer: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OrderMessage)
pub struct OrderMessage {
    // message fields
    // @@protoc_insertion_point(field:OrderMessage.orderId)
    pub orderId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OrderMessage.thumbnail)
    pub thumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:OrderMessage.itemCount)
    pub itemCount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OrderMessage.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<order_message::OrderMessageOrderStatus>>,
    // @@protoc_insertion_point(field:OrderMessage.surface)
    pub surface: ::std::option::Option<::protobuf::EnumOrUnknown<order_message::OrderMessageOrderSurface>>,
    // @@protoc_insertion_point(field:OrderMessage.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OrderMessage.orderTitle)
    pub orderTitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OrderMessage.sellerJid)
    pub sellerJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OrderMessage.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OrderMessage.totalAmount1000)
    pub totalAmount1000: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OrderMessage.totalCurrencyCode)
    pub totalCurrencyCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OrderMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:OrderMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OrderMessage {
    fn default() -> &'a OrderMessage {
        <OrderMessage as ::protobuf::Message>::default_instance()
    }
}

impl OrderMessage {
    pub fn new() -> OrderMessage {
        ::std::default::Default::default()
    }

    // optional string orderId = 1;

    pub fn orderId(&self) -> &str {
        match self.orderId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: ::std::string::String) {
        self.orderId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderId(&mut self) -> &mut ::std::string::String {
        if self.orderId.is_none() {
            self.orderId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.orderId.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderId(&mut self) -> ::std::string::String {
        self.orderId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnail = 2;

    pub fn thumbnail(&self) -> &[u8] {
        match self.thumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnail(&mut self) {
        self.thumbnail = ::std::option::Option::None;
    }

    pub fn has_thumbnail(&self) -> bool {
        self.thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnail.is_none() {
            self.thumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 itemCount = 3;

    pub fn itemCount(&self) -> i32 {
        self.itemCount.unwrap_or(0)
    }

    pub fn clear_itemCount(&mut self) {
        self.itemCount = ::std::option::Option::None;
    }

    pub fn has_itemCount(&self) -> bool {
        self.itemCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemCount(&mut self, v: i32) {
        self.itemCount = ::std::option::Option::Some(v);
    }

    // optional .OrderMessage.OrderMessageOrderStatus status = 4;

    pub fn status(&self) -> order_message::OrderMessageOrderStatus {
        match self.status {
            Some(e) => e.enum_value_or(order_message::OrderMessageOrderStatus::INQUIRY),
            None => order_message::OrderMessageOrderStatus::INQUIRY,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: order_message::OrderMessageOrderStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .OrderMessage.OrderMessageOrderSurface surface = 5;

    pub fn surface(&self) -> order_message::OrderMessageOrderSurface {
        match self.surface {
            Some(e) => e.enum_value_or(order_message::OrderMessageOrderSurface::CATALOG),
            None => order_message::OrderMessageOrderSurface::CATALOG,
        }
    }

    pub fn clear_surface(&mut self) {
        self.surface = ::std::option::Option::None;
    }

    pub fn has_surface(&self) -> bool {
        self.surface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface(&mut self, v: order_message::OrderMessageOrderSurface) {
        self.surface = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string message = 6;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string orderTitle = 7;

    pub fn orderTitle(&self) -> &str {
        match self.orderTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_orderTitle(&mut self) {
        self.orderTitle = ::std::option::Option::None;
    }

    pub fn has_orderTitle(&self) -> bool {
        self.orderTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderTitle(&mut self, v: ::std::string::String) {
        self.orderTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderTitle(&mut self) -> &mut ::std::string::String {
        if self.orderTitle.is_none() {
            self.orderTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.orderTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderTitle(&mut self) -> ::std::string::String {
        self.orderTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sellerJid = 8;

    pub fn sellerJid(&self) -> &str {
        match self.sellerJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sellerJid(&mut self) {
        self.sellerJid = ::std::option::Option::None;
    }

    pub fn has_sellerJid(&self) -> bool {
        self.sellerJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sellerJid(&mut self, v: ::std::string::String) {
        self.sellerJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sellerJid(&mut self) -> &mut ::std::string::String {
        if self.sellerJid.is_none() {
            self.sellerJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sellerJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sellerJid(&mut self) -> ::std::string::String {
        self.sellerJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string token = 9;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 totalAmount1000 = 10;

    pub fn totalAmount1000(&self) -> i64 {
        self.totalAmount1000.unwrap_or(0)
    }

    pub fn clear_totalAmount1000(&mut self) {
        self.totalAmount1000 = ::std::option::Option::None;
    }

    pub fn has_totalAmount1000(&self) -> bool {
        self.totalAmount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalAmount1000(&mut self, v: i64) {
        self.totalAmount1000 = ::std::option::Option::Some(v);
    }

    // optional string totalCurrencyCode = 11;

    pub fn totalCurrencyCode(&self) -> &str {
        match self.totalCurrencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_totalCurrencyCode(&mut self) {
        self.totalCurrencyCode = ::std::option::Option::None;
    }

    pub fn has_totalCurrencyCode(&self) -> bool {
        self.totalCurrencyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalCurrencyCode(&mut self, v: ::std::string::String) {
        self.totalCurrencyCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalCurrencyCode(&mut self) -> &mut ::std::string::String {
        if self.totalCurrencyCode.is_none() {
            self.totalCurrencyCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.totalCurrencyCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_totalCurrencyCode(&mut self) -> ::std::string::String {
        self.totalCurrencyCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &OrderMessage| { &m.orderId },
            |m: &mut OrderMessage| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnail",
            |m: &OrderMessage| { &m.thumbnail },
            |m: &mut OrderMessage| { &mut m.thumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemCount",
            |m: &OrderMessage| { &m.itemCount },
            |m: &mut OrderMessage| { &mut m.itemCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &OrderMessage| { &m.status },
            |m: &mut OrderMessage| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "surface",
            |m: &OrderMessage| { &m.surface },
            |m: &mut OrderMessage| { &mut m.surface },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &OrderMessage| { &m.message },
            |m: &mut OrderMessage| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderTitle",
            |m: &OrderMessage| { &m.orderTitle },
            |m: &mut OrderMessage| { &mut m.orderTitle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sellerJid",
            |m: &OrderMessage| { &m.sellerJid },
            |m: &mut OrderMessage| { &mut m.sellerJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &OrderMessage| { &m.token },
            |m: &mut OrderMessage| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "totalAmount1000",
            |m: &OrderMessage| { &m.totalAmount1000 },
            |m: &mut OrderMessage| { &mut m.totalAmount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "totalCurrencyCode",
            |m: &OrderMessage| { &m.totalCurrencyCode },
            |m: &mut OrderMessage| { &mut m.totalCurrencyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &OrderMessage| { &m.contextInfo },
            |m: &mut OrderMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OrderMessage>(
            "OrderMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OrderMessage {
    const NAME: &'static str = "OrderMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orderId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.thumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.itemCount = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.surface = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.orderTitle = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.sellerJid = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.totalAmount1000 = ::std::option::Option::Some(is.read_int64()?);
                },
                90 => {
                    self.totalCurrencyCode = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.orderId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.thumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.itemCount {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.surface {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.orderTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.sellerJid.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.totalAmount1000 {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.totalCurrencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.orderId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.thumbnail.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.itemCount {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.surface {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.orderTitle.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.sellerJid.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.totalAmount1000 {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.totalCurrencyCode.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OrderMessage {
        OrderMessage::new()
    }

    fn clear(&mut self) {
        self.orderId = ::std::option::Option::None;
        self.thumbnail = ::std::option::Option::None;
        self.itemCount = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.surface = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.orderTitle = ::std::option::Option::None;
        self.sellerJid = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.totalAmount1000 = ::std::option::Option::None;
        self.totalCurrencyCode = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OrderMessage {
        static instance: OrderMessage = OrderMessage {
            orderId: ::std::option::Option::None,
            thumbnail: ::std::option::Option::None,
            itemCount: ::std::option::Option::None,
            status: ::std::option::Option::None,
            surface: ::std::option::Option::None,
            message: ::std::option::Option::None,
            orderTitle: ::std::option::Option::None,
            sellerJid: ::std::option::Option::None,
            token: ::std::option::Option::None,
            totalAmount1000: ::std::option::Option::None,
            totalCurrencyCode: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OrderMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OrderMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OrderMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OrderMessage`
pub mod order_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:OrderMessage.OrderMessageOrderStatus)
    pub enum OrderMessageOrderStatus {
        // @@protoc_insertion_point(enum_value:OrderMessage.OrderMessageOrderStatus.INQUIRY)
        INQUIRY = 1,
    }

    impl ::protobuf::Enum for OrderMessageOrderStatus {
        const NAME: &'static str = "OrderMessageOrderStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OrderMessageOrderStatus> {
            match value {
                1 => ::std::option::Option::Some(OrderMessageOrderStatus::INQUIRY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OrderMessageOrderStatus] = &[
            OrderMessageOrderStatus::INQUIRY,
        ];
    }

    impl ::protobuf::EnumFull for OrderMessageOrderStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OrderMessage.OrderMessageOrderStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                OrderMessageOrderStatus::INQUIRY => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OrderMessageOrderStatus {
        fn default() -> Self {
            OrderMessageOrderStatus::INQUIRY
        }
    }

    impl OrderMessageOrderStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrderMessageOrderStatus>("OrderMessage.OrderMessageOrderStatus")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:OrderMessage.OrderMessageOrderSurface)
    pub enum OrderMessageOrderSurface {
        // @@protoc_insertion_point(enum_value:OrderMessage.OrderMessageOrderSurface.CATALOG)
        CATALOG = 1,
    }

    impl ::protobuf::Enum for OrderMessageOrderSurface {
        const NAME: &'static str = "OrderMessageOrderSurface";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OrderMessageOrderSurface> {
            match value {
                1 => ::std::option::Option::Some(OrderMessageOrderSurface::CATALOG),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OrderMessageOrderSurface] = &[
            OrderMessageOrderSurface::CATALOG,
        ];
    }

    impl ::protobuf::EnumFull for OrderMessageOrderSurface {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OrderMessage.OrderMessageOrderSurface").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                OrderMessageOrderSurface::CATALOG => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OrderMessageOrderSurface {
        fn default() -> Self {
            OrderMessageOrderSurface::CATALOG
        }
    }

    impl OrderMessageOrderSurface {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrderMessageOrderSurface>("OrderMessage.OrderMessageOrderSurface")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Row)
pub struct Row {
    // message fields
    // @@protoc_insertion_point(field:Row.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Row.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Row.rowId)
    pub rowId: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Row.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Row {
    fn default() -> &'a Row {
        <Row as ::protobuf::Message>::default_instance()
    }
}

impl Row {
    pub fn new() -> Row {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 2;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rowId = 3;

    pub fn rowId(&self) -> &str {
        match self.rowId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rowId(&mut self) {
        self.rowId = ::std::option::Option::None;
    }

    pub fn has_rowId(&self) -> bool {
        self.rowId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rowId(&mut self, v: ::std::string::String) {
        self.rowId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rowId(&mut self) -> &mut ::std::string::String {
        if self.rowId.is_none() {
            self.rowId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rowId.as_mut().unwrap()
    }

    // Take field
    pub fn take_rowId(&mut self) -> ::std::string::String {
        self.rowId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &Row| { &m.title },
            |m: &mut Row| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &Row| { &m.description },
            |m: &mut Row| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rowId",
            |m: &Row| { &m.rowId },
            |m: &mut Row| { &mut m.rowId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Row>(
            "Row",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Row {
    const NAME: &'static str = "Row";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.rowId = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.rowId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.rowId.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Row {
        Row::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.rowId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Row {
        static instance: Row = Row {
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            rowId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Row {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Row").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Row {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Row {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Section)
pub struct Section {
    // message fields
    // @@protoc_insertion_point(field:Section.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Section.rows)
    pub rows: ::std::vec::Vec<Row>,
    // special fields
    // @@protoc_insertion_point(special_field:Section.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Section {
    fn default() -> &'a Section {
        <Section as ::protobuf::Message>::default_instance()
    }
}

impl Section {
    pub fn new() -> Section {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &Section| { &m.title },
            |m: &mut Section| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rows",
            |m: &Section| { &m.rows },
            |m: &mut Section| { &mut m.rows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Section>(
            "Section",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Section {
    const NAME: &'static str = "Section";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.rows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.rows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Section {
        Section::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.rows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Section {
        static instance: Section = Section {
            title: ::std::option::Option::None,
            rows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Section {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Section").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Section {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Section {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Product)
pub struct Product {
    // message fields
    // @@protoc_insertion_point(field:Product.productId)
    pub productId: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Product.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Product {
    fn default() -> &'a Product {
        <Product as ::protobuf::Message>::default_instance()
    }
}

impl Product {
    pub fn new() -> Product {
        ::std::default::Default::default()
    }

    // optional string productId = 1;

    pub fn productId(&self) -> &str {
        match self.productId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_productId(&mut self) {
        self.productId = ::std::option::Option::None;
    }

    pub fn has_productId(&self) -> bool {
        self.productId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_productId(&mut self, v: ::std::string::String) {
        self.productId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productId(&mut self) -> &mut ::std::string::String {
        if self.productId.is_none() {
            self.productId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.productId.as_mut().unwrap()
    }

    // Take field
    pub fn take_productId(&mut self) -> ::std::string::String {
        self.productId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "productId",
            |m: &Product| { &m.productId },
            |m: &mut Product| { &mut m.productId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Product>(
            "Product",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Product {
    const NAME: &'static str = "Product";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.productId = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.productId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.productId.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Product {
        Product::new()
    }

    fn clear(&mut self) {
        self.productId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Product {
        static instance: Product = Product {
            productId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Product {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Product").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Product {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Product {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ProductSection)
pub struct ProductSection {
    // message fields
    // @@protoc_insertion_point(field:ProductSection.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductSection.products)
    pub products: ::std::vec::Vec<Product>,
    // special fields
    // @@protoc_insertion_point(special_field:ProductSection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSection {
    fn default() -> &'a ProductSection {
        <ProductSection as ::protobuf::Message>::default_instance()
    }
}

impl ProductSection {
    pub fn new() -> ProductSection {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ProductSection| { &m.title },
            |m: &mut ProductSection| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "products",
            |m: &ProductSection| { &m.products },
            |m: &mut ProductSection| { &mut m.products },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSection>(
            "ProductSection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSection {
    const NAME: &'static str = "ProductSection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.products.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.products {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.products {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSection {
        ProductSection::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.products.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSection {
        static instance: ProductSection = ProductSection {
            title: ::std::option::Option::None,
            products: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ProductListHeaderImage)
pub struct ProductListHeaderImage {
    // message fields
    // @@protoc_insertion_point(field:ProductListHeaderImage.productId)
    pub productId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProductListHeaderImage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProductListHeaderImage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductListHeaderImage {
    fn default() -> &'a ProductListHeaderImage {
        <ProductListHeaderImage as ::protobuf::Message>::default_instance()
    }
}

impl ProductListHeaderImage {
    pub fn new() -> ProductListHeaderImage {
        ::std::default::Default::default()
    }

    // optional string productId = 1;

    pub fn productId(&self) -> &str {
        match self.productId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_productId(&mut self) {
        self.productId = ::std::option::Option::None;
    }

    pub fn has_productId(&self) -> bool {
        self.productId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_productId(&mut self, v: ::std::string::String) {
        self.productId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_productId(&mut self) -> &mut ::std::string::String {
        if self.productId.is_none() {
            self.productId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.productId.as_mut().unwrap()
    }

    // Take field
    pub fn take_productId(&mut self) -> ::std::string::String {
        self.productId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes jpegThumbnail = 2;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "productId",
            |m: &ProductListHeaderImage| { &m.productId },
            |m: &mut ProductListHeaderImage| { &mut m.productId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &ProductListHeaderImage| { &m.jpegThumbnail },
            |m: &mut ProductListHeaderImage| { &mut m.jpegThumbnail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductListHeaderImage>(
            "ProductListHeaderImage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductListHeaderImage {
    const NAME: &'static str = "ProductListHeaderImage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.productId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.productId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.productId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductListHeaderImage {
        ProductListHeaderImage::new()
    }

    fn clear(&mut self) {
        self.productId = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductListHeaderImage {
        static instance: ProductListHeaderImage = ProductListHeaderImage {
            productId: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductListHeaderImage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductListHeaderImage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductListHeaderImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductListHeaderImage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ProductListInfo)
pub struct ProductListInfo {
    // message fields
    // @@protoc_insertion_point(field:ProductListInfo.productSections)
    pub productSections: ::std::vec::Vec<ProductSection>,
    // @@protoc_insertion_point(field:ProductListInfo.headerImage)
    pub headerImage: ::protobuf::MessageField<ProductListHeaderImage>,
    // @@protoc_insertion_point(field:ProductListInfo.businessOwnerJid)
    pub businessOwnerJid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProductListInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductListInfo {
    fn default() -> &'a ProductListInfo {
        <ProductListInfo as ::protobuf::Message>::default_instance()
    }
}

impl ProductListInfo {
    pub fn new() -> ProductListInfo {
        ::std::default::Default::default()
    }

    // optional string businessOwnerJid = 3;

    pub fn businessOwnerJid(&self) -> &str {
        match self.businessOwnerJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_businessOwnerJid(&mut self) {
        self.businessOwnerJid = ::std::option::Option::None;
    }

    pub fn has_businessOwnerJid(&self) -> bool {
        self.businessOwnerJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_businessOwnerJid(&mut self, v: ::std::string::String) {
        self.businessOwnerJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_businessOwnerJid(&mut self) -> &mut ::std::string::String {
        if self.businessOwnerJid.is_none() {
            self.businessOwnerJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.businessOwnerJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_businessOwnerJid(&mut self) -> ::std::string::String {
        self.businessOwnerJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "productSections",
            |m: &ProductListInfo| { &m.productSections },
            |m: &mut ProductListInfo| { &mut m.productSections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductListHeaderImage>(
            "headerImage",
            |m: &ProductListInfo| { &m.headerImage },
            |m: &mut ProductListInfo| { &mut m.headerImage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "businessOwnerJid",
            |m: &ProductListInfo| { &m.businessOwnerJid },
            |m: &mut ProductListInfo| { &mut m.businessOwnerJid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductListInfo>(
            "ProductListInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductListInfo {
    const NAME: &'static str = "ProductListInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.productSections.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.headerImage)?;
                },
                26 => {
                    self.businessOwnerJid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.productSections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.headerImage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.businessOwnerJid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.productSections {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.headerImage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.businessOwnerJid.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductListInfo {
        ProductListInfo::new()
    }

    fn clear(&mut self) {
        self.productSections.clear();
        self.headerImage.clear();
        self.businessOwnerJid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductListInfo {
        static instance: ProductListInfo = ProductListInfo {
            productSections: ::std::vec::Vec::new(),
            headerImage: ::protobuf::MessageField::none(),
            businessOwnerJid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductListInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductListInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductListInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductListInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListMessage)
pub struct ListMessage {
    // message fields
    // @@protoc_insertion_point(field:ListMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ListMessage.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ListMessage.buttonText)
    pub buttonText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ListMessage.listType)
    pub listType: ::std::option::Option<::protobuf::EnumOrUnknown<list_message::ListMessageListType>>,
    // @@protoc_insertion_point(field:ListMessage.sections)
    pub sections: ::std::vec::Vec<Section>,
    // @@protoc_insertion_point(field:ListMessage.productListInfo)
    pub productListInfo: ::protobuf::MessageField<ProductListInfo>,
    // @@protoc_insertion_point(field:ListMessage.footerText)
    pub footerText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ListMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ListMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListMessage {
    fn default() -> &'a ListMessage {
        <ListMessage as ::protobuf::Message>::default_instance()
    }
}

impl ListMessage {
    pub fn new() -> ListMessage {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 2;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string buttonText = 3;

    pub fn buttonText(&self) -> &str {
        match self.buttonText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_buttonText(&mut self) {
        self.buttonText = ::std::option::Option::None;
    }

    pub fn has_buttonText(&self) -> bool {
        self.buttonText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buttonText(&mut self, v: ::std::string::String) {
        self.buttonText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buttonText(&mut self) -> &mut ::std::string::String {
        if self.buttonText.is_none() {
            self.buttonText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.buttonText.as_mut().unwrap()
    }

    // Take field
    pub fn take_buttonText(&mut self) -> ::std::string::String {
        self.buttonText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ListMessage.ListMessageListType listType = 4;

    pub fn listType(&self) -> list_message::ListMessageListType {
        match self.listType {
            Some(e) => e.enum_value_or(list_message::ListMessageListType::UNKNOWN),
            None => list_message::ListMessageListType::UNKNOWN,
        }
    }

    pub fn clear_listType(&mut self) {
        self.listType = ::std::option::Option::None;
    }

    pub fn has_listType(&self) -> bool {
        self.listType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listType(&mut self, v: list_message::ListMessageListType) {
        self.listType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string footerText = 7;

    pub fn footerText(&self) -> &str {
        match self.footerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_footerText(&mut self) {
        self.footerText = ::std::option::Option::None;
    }

    pub fn has_footerText(&self) -> bool {
        self.footerText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerText(&mut self, v: ::std::string::String) {
        self.footerText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footerText(&mut self) -> &mut ::std::string::String {
        if self.footerText.is_none() {
            self.footerText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.footerText.as_mut().unwrap()
    }

    // Take field
    pub fn take_footerText(&mut self) -> ::std::string::String {
        self.footerText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ListMessage| { &m.title },
            |m: &mut ListMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ListMessage| { &m.description },
            |m: &mut ListMessage| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buttonText",
            |m: &ListMessage| { &m.buttonText },
            |m: &mut ListMessage| { &mut m.buttonText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "listType",
            |m: &ListMessage| { &m.listType },
            |m: &mut ListMessage| { &mut m.listType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sections",
            |m: &ListMessage| { &m.sections },
            |m: &mut ListMessage| { &mut m.sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductListInfo>(
            "productListInfo",
            |m: &ListMessage| { &m.productListInfo },
            |m: &mut ListMessage| { &mut m.productListInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footerText",
            |m: &ListMessage| { &m.footerText },
            |m: &mut ListMessage| { &mut m.footerText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ListMessage| { &m.contextInfo },
            |m: &mut ListMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListMessage>(
            "ListMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListMessage {
    const NAME: &'static str = "ListMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.buttonText = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.listType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.sections.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.productListInfo)?;
                },
                58 => {
                    self.footerText = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.buttonText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.listType {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.productListInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.footerText.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.buttonText.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.listType {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.sections {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.productListInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.footerText.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListMessage {
        ListMessage::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.buttonText = ::std::option::Option::None;
        self.listType = ::std::option::Option::None;
        self.sections.clear();
        self.productListInfo.clear();
        self.footerText = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListMessage {
        static instance: ListMessage = ListMessage {
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            buttonText: ::std::option::Option::None,
            listType: ::std::option::Option::None,
            sections: ::std::vec::Vec::new(),
            productListInfo: ::protobuf::MessageField::none(),
            footerText: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListMessage`
pub mod list_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ListMessage.ListMessageListType)
    pub enum ListMessageListType {
        // @@protoc_insertion_point(enum_value:ListMessage.ListMessageListType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:ListMessage.ListMessageListType.SINGLE_SELECT)
        SINGLE_SELECT = 1,
        // @@protoc_insertion_point(enum_value:ListMessage.ListMessageListType.PRODUCT_LIST)
        PRODUCT_LIST = 2,
    }

    impl ::protobuf::Enum for ListMessageListType {
        const NAME: &'static str = "ListMessageListType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ListMessageListType> {
            match value {
                0 => ::std::option::Option::Some(ListMessageListType::UNKNOWN),
                1 => ::std::option::Option::Some(ListMessageListType::SINGLE_SELECT),
                2 => ::std::option::Option::Some(ListMessageListType::PRODUCT_LIST),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ListMessageListType] = &[
            ListMessageListType::UNKNOWN,
            ListMessageListType::SINGLE_SELECT,
            ListMessageListType::PRODUCT_LIST,
        ];
    }

    impl ::protobuf::EnumFull for ListMessageListType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ListMessage.ListMessageListType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ListMessageListType {
        fn default() -> Self {
            ListMessageListType::UNKNOWN
        }
    }

    impl ListMessageListType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ListMessageListType>("ListMessage.ListMessageListType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SingleSelectReply)
pub struct SingleSelectReply {
    // message fields
    // @@protoc_insertion_point(field:SingleSelectReply.selectedRowId)
    pub selectedRowId: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SingleSelectReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleSelectReply {
    fn default() -> &'a SingleSelectReply {
        <SingleSelectReply as ::protobuf::Message>::default_instance()
    }
}

impl SingleSelectReply {
    pub fn new() -> SingleSelectReply {
        ::std::default::Default::default()
    }

    // optional string selectedRowId = 1;

    pub fn selectedRowId(&self) -> &str {
        match self.selectedRowId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedRowId(&mut self) {
        self.selectedRowId = ::std::option::Option::None;
    }

    pub fn has_selectedRowId(&self) -> bool {
        self.selectedRowId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedRowId(&mut self, v: ::std::string::String) {
        self.selectedRowId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedRowId(&mut self) -> &mut ::std::string::String {
        if self.selectedRowId.is_none() {
            self.selectedRowId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedRowId.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedRowId(&mut self) -> ::std::string::String {
        self.selectedRowId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedRowId",
            |m: &SingleSelectReply| { &m.selectedRowId },
            |m: &mut SingleSelectReply| { &mut m.selectedRowId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleSelectReply>(
            "SingleSelectReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleSelectReply {
    const NAME: &'static str = "SingleSelectReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectedRowId = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selectedRowId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selectedRowId.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleSelectReply {
        SingleSelectReply::new()
    }

    fn clear(&mut self) {
        self.selectedRowId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleSelectReply {
        static instance: SingleSelectReply = SingleSelectReply {
            selectedRowId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleSelectReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleSelectReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleSelectReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleSelectReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListResponseMessage)
pub struct ListResponseMessage {
    // message fields
    // @@protoc_insertion_point(field:ListResponseMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ListResponseMessage.listType)
    pub listType: ::std::option::Option<::protobuf::EnumOrUnknown<list_response_message::ListResponseMessageListType>>,
    // @@protoc_insertion_point(field:ListResponseMessage.singleSelectReply)
    pub singleSelectReply: ::protobuf::MessageField<SingleSelectReply>,
    // @@protoc_insertion_point(field:ListResponseMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:ListResponseMessage.description)
    pub description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ListResponseMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListResponseMessage {
    fn default() -> &'a ListResponseMessage {
        <ListResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl ListResponseMessage {
    pub fn new() -> ListResponseMessage {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ListResponseMessage.ListResponseMessageListType listType = 2;

    pub fn listType(&self) -> list_response_message::ListResponseMessageListType {
        match self.listType {
            Some(e) => e.enum_value_or(list_response_message::ListResponseMessageListType::UNKNOWN),
            None => list_response_message::ListResponseMessageListType::UNKNOWN,
        }
    }

    pub fn clear_listType(&mut self) {
        self.listType = ::std::option::Option::None;
    }

    pub fn has_listType(&self) -> bool {
        self.listType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listType(&mut self, v: list_response_message::ListResponseMessageListType) {
        self.listType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string description = 5;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ListResponseMessage| { &m.title },
            |m: &mut ListResponseMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "listType",
            |m: &ListResponseMessage| { &m.listType },
            |m: &mut ListResponseMessage| { &mut m.listType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SingleSelectReply>(
            "singleSelectReply",
            |m: &ListResponseMessage| { &m.singleSelectReply },
            |m: &mut ListResponseMessage| { &mut m.singleSelectReply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ListResponseMessage| { &m.contextInfo },
            |m: &mut ListResponseMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ListResponseMessage| { &m.description },
            |m: &mut ListResponseMessage| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListResponseMessage>(
            "ListResponseMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListResponseMessage {
    const NAME: &'static str = "ListResponseMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.listType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.singleSelectReply)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                42 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.listType {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.singleSelectReply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.listType {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.singleSelectReply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListResponseMessage {
        ListResponseMessage::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.listType = ::std::option::Option::None;
        self.singleSelectReply.clear();
        self.contextInfo.clear();
        self.description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListResponseMessage {
        static instance: ListResponseMessage = ListResponseMessage {
            title: ::std::option::Option::None,
            listType: ::std::option::Option::None,
            singleSelectReply: ::protobuf::MessageField::none(),
            contextInfo: ::protobuf::MessageField::none(),
            description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListResponseMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListResponseMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponseMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListResponseMessage`
pub mod list_response_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ListResponseMessage.ListResponseMessageListType)
    pub enum ListResponseMessageListType {
        // @@protoc_insertion_point(enum_value:ListResponseMessage.ListResponseMessageListType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:ListResponseMessage.ListResponseMessageListType.SINGLE_SELECT)
        SINGLE_SELECT = 1,
    }

    impl ::protobuf::Enum for ListResponseMessageListType {
        const NAME: &'static str = "ListResponseMessageListType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ListResponseMessageListType> {
            match value {
                0 => ::std::option::Option::Some(ListResponseMessageListType::UNKNOWN),
                1 => ::std::option::Option::Some(ListResponseMessageListType::SINGLE_SELECT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ListResponseMessageListType] = &[
            ListResponseMessageListType::UNKNOWN,
            ListResponseMessageListType::SINGLE_SELECT,
        ];
    }

    impl ::protobuf::EnumFull for ListResponseMessageListType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ListResponseMessage.ListResponseMessageListType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ListResponseMessageListType {
        fn default() -> Self {
            ListResponseMessageListType::UNKNOWN
        }
    }

    impl ListResponseMessageListType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ListResponseMessageListType>("ListResponseMessage.ListResponseMessageListType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Header)
pub struct Header {
    // message fields
    // @@protoc_insertion_point(field:Header.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Header.subtitle)
    pub subtitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Header.hasMediaAttachment)
    pub hasMediaAttachment: ::std::option::Option<bool>,
    // message oneof groups
    pub media: ::std::option::Option<header::Media>,
    // special fields
    // @@protoc_insertion_point(special_field:Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subtitle = 2;

    pub fn subtitle(&self) -> &str {
        match self.subtitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_subtitle(&mut self) {
        self.subtitle = ::std::option::Option::None;
    }

    pub fn has_subtitle(&self) -> bool {
        self.subtitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subtitle(&mut self, v: ::std::string::String) {
        self.subtitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subtitle(&mut self) -> &mut ::std::string::String {
        if self.subtitle.is_none() {
            self.subtitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.subtitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_subtitle(&mut self) -> ::std::string::String {
        self.subtitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool hasMediaAttachment = 5;

    pub fn hasMediaAttachment(&self) -> bool {
        self.hasMediaAttachment.unwrap_or(false)
    }

    pub fn clear_hasMediaAttachment(&mut self) {
        self.hasMediaAttachment = ::std::option::Option::None;
    }

    pub fn has_hasMediaAttachment(&self) -> bool {
        self.hasMediaAttachment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMediaAttachment(&mut self, v: bool) {
        self.hasMediaAttachment = ::std::option::Option::Some(v);
    }

    // optional .DocumentMessage documentMessage = 3;

    pub fn documentMessage(&self) -> &DocumentMessage {
        match self.media {
            ::std::option::Option::Some(header::Media::DocumentMessage(ref v)) => v,
            _ => <DocumentMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_documentMessage(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_documentMessage(&self) -> bool {
        match self.media {
            ::std::option::Option::Some(header::Media::DocumentMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_documentMessage(&mut self, v: DocumentMessage) {
        self.media = ::std::option::Option::Some(header::Media::DocumentMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_documentMessage(&mut self) -> &mut DocumentMessage {
        if let ::std::option::Option::Some(header::Media::DocumentMessage(_)) = self.media {
        } else {
            self.media = ::std::option::Option::Some(header::Media::DocumentMessage(DocumentMessage::new()));
        }
        match self.media {
            ::std::option::Option::Some(header::Media::DocumentMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_documentMessage(&mut self) -> DocumentMessage {
        if self.has_documentMessage() {
            match self.media.take() {
                ::std::option::Option::Some(header::Media::DocumentMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            DocumentMessage::new()
        }
    }

    // optional .ImageMessage imageMessage = 4;

    pub fn imageMessage(&self) -> &ImageMessage {
        match self.media {
            ::std::option::Option::Some(header::Media::ImageMessage(ref v)) => v,
            _ => <ImageMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_imageMessage(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_imageMessage(&self) -> bool {
        match self.media {
            ::std::option::Option::Some(header::Media::ImageMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_imageMessage(&mut self, v: ImageMessage) {
        self.media = ::std::option::Option::Some(header::Media::ImageMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_imageMessage(&mut self) -> &mut ImageMessage {
        if let ::std::option::Option::Some(header::Media::ImageMessage(_)) = self.media {
        } else {
            self.media = ::std::option::Option::Some(header::Media::ImageMessage(ImageMessage::new()));
        }
        match self.media {
            ::std::option::Option::Some(header::Media::ImageMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_imageMessage(&mut self) -> ImageMessage {
        if self.has_imageMessage() {
            match self.media.take() {
                ::std::option::Option::Some(header::Media::ImageMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ImageMessage::new()
        }
    }

    // optional bytes jpegThumbnail = 6;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.media {
            ::std::option::Option::Some(header::Media::JpegThumbnail(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        match self.media {
            ::std::option::Option::Some(header::Media::JpegThumbnail(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.media = ::std::option::Option::Some(header::Media::JpegThumbnail(v))
    }

    // Mutable pointer to the field.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(header::Media::JpegThumbnail(_)) = self.media {
        } else {
            self.media = ::std::option::Option::Some(header::Media::JpegThumbnail(::std::vec::Vec::new()));
        }
        match self.media {
            ::std::option::Option::Some(header::Media::JpegThumbnail(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_jpegThumbnail() {
            match self.media.take() {
                ::std::option::Option::Some(header::Media::JpegThumbnail(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // optional .VideoMessage videoMessage = 7;

    pub fn videoMessage(&self) -> &VideoMessage {
        match self.media {
            ::std::option::Option::Some(header::Media::VideoMessage(ref v)) => v,
            _ => <VideoMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoMessage(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_videoMessage(&self) -> bool {
        match self.media {
            ::std::option::Option::Some(header::Media::VideoMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoMessage(&mut self, v: VideoMessage) {
        self.media = ::std::option::Option::Some(header::Media::VideoMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoMessage(&mut self) -> &mut VideoMessage {
        if let ::std::option::Option::Some(header::Media::VideoMessage(_)) = self.media {
        } else {
            self.media = ::std::option::Option::Some(header::Media::VideoMessage(VideoMessage::new()));
        }
        match self.media {
            ::std::option::Option::Some(header::Media::VideoMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoMessage(&mut self) -> VideoMessage {
        if self.has_videoMessage() {
            match self.media.take() {
                ::std::option::Option::Some(header::Media::VideoMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &Header| { &m.title },
            |m: &mut Header| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subtitle",
            |m: &Header| { &m.subtitle },
            |m: &mut Header| { &mut m.subtitle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasMediaAttachment",
            |m: &Header| { &m.hasMediaAttachment },
            |m: &mut Header| { &mut m.hasMediaAttachment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DocumentMessage>(
            "documentMessage",
            Header::has_documentMessage,
            Header::documentMessage,
            Header::mut_documentMessage,
            Header::set_documentMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ImageMessage>(
            "imageMessage",
            Header::has_imageMessage,
            Header::imageMessage,
            Header::mut_imageMessage,
            Header::set_imageMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "jpegThumbnail",
            Header::has_jpegThumbnail,
            Header::jpegThumbnail,
            Header::set_jpegThumbnail,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoMessage>(
            "videoMessage",
            Header::has_videoMessage,
            Header::videoMessage,
            Header::mut_videoMessage,
            Header::set_videoMessage,
        ));
        oneofs.push(header::Media::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
            "Header",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.subtitle = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.hasMediaAttachment = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.media = ::std::option::Option::Some(header::Media::DocumentMessage(is.read_message()?));
                },
                34 => {
                    self.media = ::std::option::Option::Some(header::Media::ImageMessage(is.read_message()?));
                },
                50 => {
                    self.media = ::std::option::Option::Some(header::Media::JpegThumbnail(is.read_bytes()?));
                },
                58 => {
                    self.media = ::std::option::Option::Some(header::Media::VideoMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.subtitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.hasMediaAttachment {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.media {
            match v {
                &header::Media::DocumentMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &header::Media::ImageMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &header::Media::JpegThumbnail(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(6, &v);
                },
                &header::Media::VideoMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.subtitle.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.hasMediaAttachment {
            os.write_bool(5, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.media {
            match v {
                &header::Media::DocumentMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &header::Media::ImageMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &header::Media::JpegThumbnail(ref v) => {
                    os.write_bytes(6, v)?;
                },
                &header::Media::VideoMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.subtitle = ::std::option::Option::None;
        self.hasMediaAttachment = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            title: ::std::option::Option::None,
            subtitle: ::std::option::Option::None,
            hasMediaAttachment: ::std::option::Option::None,
            media: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Header {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Header").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Header`
pub mod header {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Header.media)
    pub enum Media {
        // @@protoc_insertion_point(oneof_field:Header.documentMessage)
        DocumentMessage(super::DocumentMessage),
        // @@protoc_insertion_point(oneof_field:Header.imageMessage)
        ImageMessage(super::ImageMessage),
        // @@protoc_insertion_point(oneof_field:Header.jpegThumbnail)
        JpegThumbnail(::std::vec::Vec<u8>),
        // @@protoc_insertion_point(oneof_field:Header.videoMessage)
        VideoMessage(super::VideoMessage),
    }

    impl ::protobuf::Oneof for Media {
    }

    impl ::protobuf::OneofFull for Media {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Header as ::protobuf::MessageFull>::descriptor().oneof_by_name("media").unwrap()).clone()
        }
    }

    impl Media {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Media>("media")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Body)
pub struct Body {
    // message fields
    // @@protoc_insertion_point(field:Body.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Body.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Body {
    fn default() -> &'a Body {
        <Body as ::protobuf::Message>::default_instance()
    }
}

impl Body {
    pub fn new() -> Body {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &Body| { &m.text },
            |m: &mut Body| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Body>(
            "Body",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Body {
    const NAME: &'static str = "Body";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Body {
        Body::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Body {
        static instance: Body = Body {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Body {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Body").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Body {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Body {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Footer)
pub struct Footer {
    // message fields
    // @@protoc_insertion_point(field:Footer.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Footer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Footer {
    fn default() -> &'a Footer {
        <Footer as ::protobuf::Message>::default_instance()
    }
}

impl Footer {
    pub fn new() -> Footer {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &Footer| { &m.text },
            |m: &mut Footer| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Footer>(
            "Footer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Footer {
    const NAME: &'static str = "Footer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Footer {
        Footer::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Footer {
        static instance: Footer = Footer {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Footer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Footer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Footer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Footer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ShopMessage)
pub struct ShopMessage {
    // message fields
    // @@protoc_insertion_point(field:ShopMessage.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ShopMessage.surface)
    pub surface: ::std::option::Option<::protobuf::EnumOrUnknown<shop_message::ShopMessageSurface>>,
    // @@protoc_insertion_point(field:ShopMessage.messageVersion)
    pub messageVersion: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ShopMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShopMessage {
    fn default() -> &'a ShopMessage {
        <ShopMessage as ::protobuf::Message>::default_instance()
    }
}

impl ShopMessage {
    pub fn new() -> ShopMessage {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ShopMessage.ShopMessageSurface surface = 2;

    pub fn surface(&self) -> shop_message::ShopMessageSurface {
        match self.surface {
            Some(e) => e.enum_value_or(shop_message::ShopMessageSurface::UNKNOWN_SURFACE),
            None => shop_message::ShopMessageSurface::UNKNOWN_SURFACE,
        }
    }

    pub fn clear_surface(&mut self) {
        self.surface = ::std::option::Option::None;
    }

    pub fn has_surface(&self) -> bool {
        self.surface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface(&mut self, v: shop_message::ShopMessageSurface) {
        self.surface = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 messageVersion = 3;

    pub fn messageVersion(&self) -> i32 {
        self.messageVersion.unwrap_or(0)
    }

    pub fn clear_messageVersion(&mut self) {
        self.messageVersion = ::std::option::Option::None;
    }

    pub fn has_messageVersion(&self) -> bool {
        self.messageVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageVersion(&mut self, v: i32) {
        self.messageVersion = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ShopMessage| { &m.id },
            |m: &mut ShopMessage| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "surface",
            |m: &ShopMessage| { &m.surface },
            |m: &mut ShopMessage| { &mut m.surface },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageVersion",
            |m: &ShopMessage| { &m.messageVersion },
            |m: &mut ShopMessage| { &mut m.messageVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShopMessage>(
            "ShopMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ShopMessage {
    const NAME: &'static str = "ShopMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.surface = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.messageVersion = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.surface {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.messageVersion {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.surface {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.messageVersion {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShopMessage {
        ShopMessage::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.surface = ::std::option::Option::None;
        self.messageVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShopMessage {
        static instance: ShopMessage = ShopMessage {
            id: ::std::option::Option::None,
            surface: ::std::option::Option::None,
            messageVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ShopMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ShopMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ShopMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShopMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ShopMessage`
pub mod shop_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ShopMessage.ShopMessageSurface)
    pub enum ShopMessageSurface {
        // @@protoc_insertion_point(enum_value:ShopMessage.ShopMessageSurface.UNKNOWN_SURFACE)
        UNKNOWN_SURFACE = 0,
        // @@protoc_insertion_point(enum_value:ShopMessage.ShopMessageSurface.FB)
        FB = 1,
        // @@protoc_insertion_point(enum_value:ShopMessage.ShopMessageSurface.IG)
        IG = 2,
        // @@protoc_insertion_point(enum_value:ShopMessage.ShopMessageSurface.WA)
        WA = 3,
    }

    impl ::protobuf::Enum for ShopMessageSurface {
        const NAME: &'static str = "ShopMessageSurface";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ShopMessageSurface> {
            match value {
                0 => ::std::option::Option::Some(ShopMessageSurface::UNKNOWN_SURFACE),
                1 => ::std::option::Option::Some(ShopMessageSurface::FB),
                2 => ::std::option::Option::Some(ShopMessageSurface::IG),
                3 => ::std::option::Option::Some(ShopMessageSurface::WA),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ShopMessageSurface] = &[
            ShopMessageSurface::UNKNOWN_SURFACE,
            ShopMessageSurface::FB,
            ShopMessageSurface::IG,
            ShopMessageSurface::WA,
        ];
    }

    impl ::protobuf::EnumFull for ShopMessageSurface {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ShopMessage.ShopMessageSurface").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ShopMessageSurface {
        fn default() -> Self {
            ShopMessageSurface::UNKNOWN_SURFACE
        }
    }

    impl ShopMessageSurface {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ShopMessageSurface>("ShopMessage.ShopMessageSurface")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CollectionMessage)
pub struct CollectionMessage {
    // message fields
    // @@protoc_insertion_point(field:CollectionMessage.bizJid)
    pub bizJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CollectionMessage.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CollectionMessage.messageVersion)
    pub messageVersion: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CollectionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectionMessage {
    fn default() -> &'a CollectionMessage {
        <CollectionMessage as ::protobuf::Message>::default_instance()
    }
}

impl CollectionMessage {
    pub fn new() -> CollectionMessage {
        ::std::default::Default::default()
    }

    // optional string bizJid = 1;

    pub fn bizJid(&self) -> &str {
        match self.bizJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bizJid(&mut self) {
        self.bizJid = ::std::option::Option::None;
    }

    pub fn has_bizJid(&self) -> bool {
        self.bizJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bizJid(&mut self, v: ::std::string::String) {
        self.bizJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bizJid(&mut self) -> &mut ::std::string::String {
        if self.bizJid.is_none() {
            self.bizJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bizJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_bizJid(&mut self) -> ::std::string::String {
        self.bizJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 messageVersion = 3;

    pub fn messageVersion(&self) -> i32 {
        self.messageVersion.unwrap_or(0)
    }

    pub fn clear_messageVersion(&mut self) {
        self.messageVersion = ::std::option::Option::None;
    }

    pub fn has_messageVersion(&self) -> bool {
        self.messageVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageVersion(&mut self, v: i32) {
        self.messageVersion = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bizJid",
            |m: &CollectionMessage| { &m.bizJid },
            |m: &mut CollectionMessage| { &mut m.bizJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CollectionMessage| { &m.id },
            |m: &mut CollectionMessage| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageVersion",
            |m: &CollectionMessage| { &m.messageVersion },
            |m: &mut CollectionMessage| { &mut m.messageVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectionMessage>(
            "CollectionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectionMessage {
    const NAME: &'static str = "CollectionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bizJid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.messageVersion = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bizJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.messageVersion {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bizJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.messageVersion {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectionMessage {
        CollectionMessage::new()
    }

    fn clear(&mut self) {
        self.bizJid = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.messageVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectionMessage {
        static instance: CollectionMessage = CollectionMessage {
            bizJid: ::std::option::Option::None,
            id: ::std::option::Option::None,
            messageVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NativeFlowButton)
pub struct NativeFlowButton {
    // message fields
    // @@protoc_insertion_point(field:NativeFlowButton.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NativeFlowButton.buttonParamsJson)
    pub buttonParamsJson: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:NativeFlowButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeFlowButton {
    fn default() -> &'a NativeFlowButton {
        <NativeFlowButton as ::protobuf::Message>::default_instance()
    }
}

impl NativeFlowButton {
    pub fn new() -> NativeFlowButton {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string buttonParamsJson = 2;

    pub fn buttonParamsJson(&self) -> &str {
        match self.buttonParamsJson.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_buttonParamsJson(&mut self) {
        self.buttonParamsJson = ::std::option::Option::None;
    }

    pub fn has_buttonParamsJson(&self) -> bool {
        self.buttonParamsJson.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buttonParamsJson(&mut self, v: ::std::string::String) {
        self.buttonParamsJson = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buttonParamsJson(&mut self) -> &mut ::std::string::String {
        if self.buttonParamsJson.is_none() {
            self.buttonParamsJson = ::std::option::Option::Some(::std::string::String::new());
        }
        self.buttonParamsJson.as_mut().unwrap()
    }

    // Take field
    pub fn take_buttonParamsJson(&mut self) -> ::std::string::String {
        self.buttonParamsJson.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &NativeFlowButton| { &m.name },
            |m: &mut NativeFlowButton| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buttonParamsJson",
            |m: &NativeFlowButton| { &m.buttonParamsJson },
            |m: &mut NativeFlowButton| { &mut m.buttonParamsJson },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeFlowButton>(
            "NativeFlowButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeFlowButton {
    const NAME: &'static str = "NativeFlowButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.buttonParamsJson = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.buttonParamsJson.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.buttonParamsJson.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeFlowButton {
        NativeFlowButton::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.buttonParamsJson = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeFlowButton {
        static instance: NativeFlowButton = NativeFlowButton {
            name: ::std::option::Option::None,
            buttonParamsJson: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeFlowButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeFlowButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeFlowButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeFlowButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NativeFlowMessage)
pub struct NativeFlowMessage {
    // message fields
    // @@protoc_insertion_point(field:NativeFlowMessage.buttons)
    pub buttons: ::std::vec::Vec<NativeFlowButton>,
    // @@protoc_insertion_point(field:NativeFlowMessage.messageParamsJson)
    pub messageParamsJson: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NativeFlowMessage.messageVersion)
    pub messageVersion: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:NativeFlowMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeFlowMessage {
    fn default() -> &'a NativeFlowMessage {
        <NativeFlowMessage as ::protobuf::Message>::default_instance()
    }
}

impl NativeFlowMessage {
    pub fn new() -> NativeFlowMessage {
        ::std::default::Default::default()
    }

    // optional string messageParamsJson = 2;

    pub fn messageParamsJson(&self) -> &str {
        match self.messageParamsJson.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_messageParamsJson(&mut self) {
        self.messageParamsJson = ::std::option::Option::None;
    }

    pub fn has_messageParamsJson(&self) -> bool {
        self.messageParamsJson.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageParamsJson(&mut self, v: ::std::string::String) {
        self.messageParamsJson = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageParamsJson(&mut self) -> &mut ::std::string::String {
        if self.messageParamsJson.is_none() {
            self.messageParamsJson = ::std::option::Option::Some(::std::string::String::new());
        }
        self.messageParamsJson.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageParamsJson(&mut self) -> ::std::string::String {
        self.messageParamsJson.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 messageVersion = 3;

    pub fn messageVersion(&self) -> i32 {
        self.messageVersion.unwrap_or(0)
    }

    pub fn clear_messageVersion(&mut self) {
        self.messageVersion = ::std::option::Option::None;
    }

    pub fn has_messageVersion(&self) -> bool {
        self.messageVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageVersion(&mut self, v: i32) {
        self.messageVersion = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buttons",
            |m: &NativeFlowMessage| { &m.buttons },
            |m: &mut NativeFlowMessage| { &mut m.buttons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageParamsJson",
            |m: &NativeFlowMessage| { &m.messageParamsJson },
            |m: &mut NativeFlowMessage| { &mut m.messageParamsJson },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageVersion",
            |m: &NativeFlowMessage| { &m.messageVersion },
            |m: &mut NativeFlowMessage| { &mut m.messageVersion },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeFlowMessage>(
            "NativeFlowMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeFlowMessage {
    const NAME: &'static str = "NativeFlowMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.buttons.push(is.read_message()?);
                },
                18 => {
                    self.messageParamsJson = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.messageVersion = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.buttons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.messageParamsJson.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.messageVersion {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.buttons {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.messageParamsJson.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.messageVersion {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeFlowMessage {
        NativeFlowMessage::new()
    }

    fn clear(&mut self) {
        self.buttons.clear();
        self.messageParamsJson = ::std::option::Option::None;
        self.messageVersion = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeFlowMessage {
        static instance: NativeFlowMessage = NativeFlowMessage {
            buttons: ::std::vec::Vec::new(),
            messageParamsJson: ::std::option::Option::None,
            messageVersion: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeFlowMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeFlowMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeFlowMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeFlowMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:InteractiveMessage)
pub struct InteractiveMessage {
    // message fields
    // @@protoc_insertion_point(field:InteractiveMessage.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:InteractiveMessage.body)
    pub body: ::protobuf::MessageField<Body>,
    // @@protoc_insertion_point(field:InteractiveMessage.footer)
    pub footer: ::protobuf::MessageField<Footer>,
    // @@protoc_insertion_point(field:InteractiveMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // message oneof groups
    pub interactiveMessage: ::std::option::Option<interactive_message::InteractiveMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:InteractiveMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractiveMessage {
    fn default() -> &'a InteractiveMessage {
        <InteractiveMessage as ::protobuf::Message>::default_instance()
    }
}

impl InteractiveMessage {
    pub fn new() -> InteractiveMessage {
        ::std::default::Default::default()
    }

    // optional .ShopMessage shopStorefrontMessage = 4;

    pub fn shopStorefrontMessage(&self) -> &ShopMessage {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(ref v)) => v,
            _ => <ShopMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_shopStorefrontMessage(&mut self) {
        self.interactiveMessage = ::std::option::Option::None;
    }

    pub fn has_shopStorefrontMessage(&self) -> bool {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shopStorefrontMessage(&mut self, v: ShopMessage) {
        self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shopStorefrontMessage(&mut self) -> &mut ShopMessage {
        if let ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(_)) = self.interactiveMessage {
        } else {
            self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(ShopMessage::new()));
        }
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shopStorefrontMessage(&mut self) -> ShopMessage {
        if self.has_shopStorefrontMessage() {
            match self.interactiveMessage.take() {
                ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ShopMessage::new()
        }
    }

    // optional .CollectionMessage collectionMessage = 5;

    pub fn collectionMessage(&self) -> &CollectionMessage {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(ref v)) => v,
            _ => <CollectionMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_collectionMessage(&mut self) {
        self.interactiveMessage = ::std::option::Option::None;
    }

    pub fn has_collectionMessage(&self) -> bool {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_collectionMessage(&mut self, v: CollectionMessage) {
        self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_collectionMessage(&mut self) -> &mut CollectionMessage {
        if let ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(_)) = self.interactiveMessage {
        } else {
            self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(CollectionMessage::new()));
        }
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_collectionMessage(&mut self) -> CollectionMessage {
        if self.has_collectionMessage() {
            match self.interactiveMessage.take() {
                ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            CollectionMessage::new()
        }
    }

    // optional .NativeFlowMessage nativeFlowMessage = 6;

    pub fn nativeFlowMessage(&self) -> &NativeFlowMessage {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(ref v)) => v,
            _ => <NativeFlowMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_nativeFlowMessage(&mut self) {
        self.interactiveMessage = ::std::option::Option::None;
    }

    pub fn has_nativeFlowMessage(&self) -> bool {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nativeFlowMessage(&mut self, v: NativeFlowMessage) {
        self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nativeFlowMessage(&mut self) -> &mut NativeFlowMessage {
        if let ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(_)) = self.interactiveMessage {
        } else {
            self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(NativeFlowMessage::new()));
        }
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nativeFlowMessage(&mut self) -> NativeFlowMessage {
        if self.has_nativeFlowMessage() {
            match self.interactiveMessage.take() {
                ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            NativeFlowMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &InteractiveMessage| { &m.header },
            |m: &mut InteractiveMessage| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Body>(
            "body",
            |m: &InteractiveMessage| { &m.body },
            |m: &mut InteractiveMessage| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Footer>(
            "footer",
            |m: &InteractiveMessage| { &m.footer },
            |m: &mut InteractiveMessage| { &mut m.footer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &InteractiveMessage| { &m.contextInfo },
            |m: &mut InteractiveMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ShopMessage>(
            "shopStorefrontMessage",
            InteractiveMessage::has_shopStorefrontMessage,
            InteractiveMessage::shopStorefrontMessage,
            InteractiveMessage::mut_shopStorefrontMessage,
            InteractiveMessage::set_shopStorefrontMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CollectionMessage>(
            "collectionMessage",
            InteractiveMessage::has_collectionMessage,
            InteractiveMessage::collectionMessage,
            InteractiveMessage::mut_collectionMessage,
            InteractiveMessage::set_collectionMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, NativeFlowMessage>(
            "nativeFlowMessage",
            InteractiveMessage::has_nativeFlowMessage,
            InteractiveMessage::nativeFlowMessage,
            InteractiveMessage::mut_nativeFlowMessage,
            InteractiveMessage::set_nativeFlowMessage,
        ));
        oneofs.push(interactive_message::InteractiveMessage::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractiveMessage>(
            "InteractiveMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractiveMessage {
    const NAME: &'static str = "InteractiveMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.body)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.footer)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                34 => {
                    self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(is.read_message()?));
                },
                42 => {
                    self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(is.read_message()?));
                },
                50 => {
                    self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.footer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.interactiveMessage {
            match v {
                &interactive_message::InteractiveMessage::ShopStorefrontMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &interactive_message::InteractiveMessage::CollectionMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &interactive_message::InteractiveMessage::NativeFlowMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.footer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.interactiveMessage {
            match v {
                &interactive_message::InteractiveMessage::ShopStorefrontMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &interactive_message::InteractiveMessage::CollectionMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &interactive_message::InteractiveMessage::NativeFlowMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractiveMessage {
        InteractiveMessage::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.body.clear();
        self.footer.clear();
        self.contextInfo.clear();
        self.interactiveMessage = ::std::option::Option::None;
        self.interactiveMessage = ::std::option::Option::None;
        self.interactiveMessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractiveMessage {
        static instance: InteractiveMessage = InteractiveMessage {
            header: ::protobuf::MessageField::none(),
            body: ::protobuf::MessageField::none(),
            footer: ::protobuf::MessageField::none(),
            contextInfo: ::protobuf::MessageField::none(),
            interactiveMessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractiveMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractiveMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractiveMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractiveMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InteractiveMessage`
pub mod interactive_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:InteractiveMessage.interactiveMessage)
    pub enum InteractiveMessage {
        // @@protoc_insertion_point(oneof_field:InteractiveMessage.shopStorefrontMessage)
        ShopStorefrontMessage(super::ShopMessage),
        // @@protoc_insertion_point(oneof_field:InteractiveMessage.collectionMessage)
        CollectionMessage(super::CollectionMessage),
        // @@protoc_insertion_point(oneof_field:InteractiveMessage.nativeFlowMessage)
        NativeFlowMessage(super::NativeFlowMessage),
    }

    impl ::protobuf::Oneof for InteractiveMessage {
    }

    impl ::protobuf::OneofFull for InteractiveMessage {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InteractiveMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("interactiveMessage").unwrap()).clone()
        }
    }

    impl InteractiveMessage {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<InteractiveMessage>("interactiveMessage")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GroupInviteMessage)
pub struct GroupInviteMessage {
    // message fields
    // @@protoc_insertion_point(field:GroupInviteMessage.groupJid)
    pub groupJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GroupInviteMessage.inviteCode)
    pub inviteCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GroupInviteMessage.inviteExpiration)
    pub inviteExpiration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:GroupInviteMessage.groupName)
    pub groupName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GroupInviteMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:GroupInviteMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GroupInviteMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:GroupInviteMessage.groupType)
    pub groupType: ::std::option::Option<::protobuf::EnumOrUnknown<group_invite_message::GroupInviteMessageGroupType>>,
    // special fields
    // @@protoc_insertion_point(special_field:GroupInviteMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupInviteMessage {
    fn default() -> &'a GroupInviteMessage {
        <GroupInviteMessage as ::protobuf::Message>::default_instance()
    }
}

impl GroupInviteMessage {
    pub fn new() -> GroupInviteMessage {
        ::std::default::Default::default()
    }

    // optional string groupJid = 1;

    pub fn groupJid(&self) -> &str {
        match self.groupJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupJid(&mut self) {
        self.groupJid = ::std::option::Option::None;
    }

    pub fn has_groupJid(&self) -> bool {
        self.groupJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupJid(&mut self, v: ::std::string::String) {
        self.groupJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupJid(&mut self) -> &mut ::std::string::String {
        if self.groupJid.is_none() {
            self.groupJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupJid(&mut self) -> ::std::string::String {
        self.groupJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string inviteCode = 2;

    pub fn inviteCode(&self) -> &str {
        match self.inviteCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_inviteCode(&mut self) {
        self.inviteCode = ::std::option::Option::None;
    }

    pub fn has_inviteCode(&self) -> bool {
        self.inviteCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteCode(&mut self, v: ::std::string::String) {
        self.inviteCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inviteCode(&mut self) -> &mut ::std::string::String {
        if self.inviteCode.is_none() {
            self.inviteCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.inviteCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_inviteCode(&mut self) -> ::std::string::String {
        self.inviteCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 inviteExpiration = 3;

    pub fn inviteExpiration(&self) -> i64 {
        self.inviteExpiration.unwrap_or(0)
    }

    pub fn clear_inviteExpiration(&mut self) {
        self.inviteExpiration = ::std::option::Option::None;
    }

    pub fn has_inviteExpiration(&self) -> bool {
        self.inviteExpiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteExpiration(&mut self, v: i64) {
        self.inviteExpiration = ::std::option::Option::Some(v);
    }

    // optional string groupName = 4;

    pub fn groupName(&self) -> &str {
        match self.groupName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupName(&mut self) {
        self.groupName = ::std::option::Option::None;
    }

    pub fn has_groupName(&self) -> bool {
        self.groupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupName(&mut self, v: ::std::string::String) {
        self.groupName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupName(&mut self) -> &mut ::std::string::String {
        if self.groupName.is_none() {
            self.groupName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupName(&mut self) -> ::std::string::String {
        self.groupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes jpegThumbnail = 5;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string caption = 6;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .GroupInviteMessage.GroupInviteMessageGroupType groupType = 8;

    pub fn groupType(&self) -> group_invite_message::GroupInviteMessageGroupType {
        match self.groupType {
            Some(e) => e.enum_value_or(group_invite_message::GroupInviteMessageGroupType::DEFAULT),
            None => group_invite_message::GroupInviteMessageGroupType::DEFAULT,
        }
    }

    pub fn clear_groupType(&mut self) {
        self.groupType = ::std::option::Option::None;
    }

    pub fn has_groupType(&self) -> bool {
        self.groupType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupType(&mut self, v: group_invite_message::GroupInviteMessageGroupType) {
        self.groupType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupJid",
            |m: &GroupInviteMessage| { &m.groupJid },
            |m: &mut GroupInviteMessage| { &mut m.groupJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteCode",
            |m: &GroupInviteMessage| { &m.inviteCode },
            |m: &mut GroupInviteMessage| { &mut m.inviteCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteExpiration",
            |m: &GroupInviteMessage| { &m.inviteExpiration },
            |m: &mut GroupInviteMessage| { &mut m.inviteExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupName",
            |m: &GroupInviteMessage| { &m.groupName },
            |m: &mut GroupInviteMessage| { &mut m.groupName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &GroupInviteMessage| { &m.jpegThumbnail },
            |m: &mut GroupInviteMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &GroupInviteMessage| { &m.caption },
            |m: &mut GroupInviteMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &GroupInviteMessage| { &m.contextInfo },
            |m: &mut GroupInviteMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupType",
            |m: &GroupInviteMessage| { &m.groupType },
            |m: &mut GroupInviteMessage| { &mut m.groupType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupInviteMessage>(
            "GroupInviteMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupInviteMessage {
    const NAME: &'static str = "GroupInviteMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupJid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.inviteCode = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.inviteExpiration = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.groupName = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                64 => {
                    self.groupType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inviteCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.inviteExpiration {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.groupName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.groupType {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.inviteCode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.inviteExpiration {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.groupName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.groupType {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupInviteMessage {
        GroupInviteMessage::new()
    }

    fn clear(&mut self) {
        self.groupJid = ::std::option::Option::None;
        self.inviteCode = ::std::option::Option::None;
        self.inviteExpiration = ::std::option::Option::None;
        self.groupName = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.contextInfo.clear();
        self.groupType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupInviteMessage {
        static instance: GroupInviteMessage = GroupInviteMessage {
            groupJid: ::std::option::Option::None,
            inviteCode: ::std::option::Option::None,
            inviteExpiration: ::std::option::Option::None,
            groupName: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            groupType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupInviteMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupInviteMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupInviteMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupInviteMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GroupInviteMessage`
pub mod group_invite_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:GroupInviteMessage.GroupInviteMessageGroupType)
    pub enum GroupInviteMessageGroupType {
        // @@protoc_insertion_point(enum_value:GroupInviteMessage.GroupInviteMessageGroupType.DEFAULT)
        DEFAULT = 0,
        // @@protoc_insertion_point(enum_value:GroupInviteMessage.GroupInviteMessageGroupType.PARENT)
        PARENT = 1,
    }

    impl ::protobuf::Enum for GroupInviteMessageGroupType {
        const NAME: &'static str = "GroupInviteMessageGroupType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GroupInviteMessageGroupType> {
            match value {
                0 => ::std::option::Option::Some(GroupInviteMessageGroupType::DEFAULT),
                1 => ::std::option::Option::Some(GroupInviteMessageGroupType::PARENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [GroupInviteMessageGroupType] = &[
            GroupInviteMessageGroupType::DEFAULT,
            GroupInviteMessageGroupType::PARENT,
        ];
    }

    impl ::protobuf::EnumFull for GroupInviteMessageGroupType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GroupInviteMessage.GroupInviteMessageGroupType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for GroupInviteMessageGroupType {
        fn default() -> Self {
            GroupInviteMessageGroupType::DEFAULT
        }
    }

    impl GroupInviteMessageGroupType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GroupInviteMessageGroupType>("GroupInviteMessage.GroupInviteMessageGroupType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeviceSentMessage)
pub struct DeviceSentMessage {
    // message fields
    // @@protoc_insertion_point(field:DeviceSentMessage.destinationJid)
    pub destinationJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DeviceSentMessage.message)
    pub message: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:DeviceSentMessage.phash)
    pub phash: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:DeviceSentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceSentMessage {
    fn default() -> &'a DeviceSentMessage {
        <DeviceSentMessage as ::protobuf::Message>::default_instance()
    }
}

impl DeviceSentMessage {
    pub fn new() -> DeviceSentMessage {
        ::std::default::Default::default()
    }

    // optional string destinationJid = 1;

    pub fn destinationJid(&self) -> &str {
        match self.destinationJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_destinationJid(&mut self) {
        self.destinationJid = ::std::option::Option::None;
    }

    pub fn has_destinationJid(&self) -> bool {
        self.destinationJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationJid(&mut self, v: ::std::string::String) {
        self.destinationJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationJid(&mut self) -> &mut ::std::string::String {
        if self.destinationJid.is_none() {
            self.destinationJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.destinationJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationJid(&mut self) -> ::std::string::String {
        self.destinationJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string phash = 3;

    pub fn phash(&self) -> &str {
        match self.phash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phash(&mut self) {
        self.phash = ::std::option::Option::None;
    }

    pub fn has_phash(&self) -> bool {
        self.phash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phash(&mut self, v: ::std::string::String) {
        self.phash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phash(&mut self) -> &mut ::std::string::String {
        if self.phash.is_none() {
            self.phash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phash.as_mut().unwrap()
    }

    // Take field
    pub fn take_phash(&mut self) -> ::std::string::String {
        self.phash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "destinationJid",
            |m: &DeviceSentMessage| { &m.destinationJid },
            |m: &mut DeviceSentMessage| { &mut m.destinationJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &DeviceSentMessage| { &m.message },
            |m: &mut DeviceSentMessage| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phash",
            |m: &DeviceSentMessage| { &m.phash },
            |m: &mut DeviceSentMessage| { &mut m.phash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceSentMessage>(
            "DeviceSentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceSentMessage {
    const NAME: &'static str = "DeviceSentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.destinationJid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                26 => {
                    self.phash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.destinationJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.phash.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.destinationJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.phash.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceSentMessage {
        DeviceSentMessage::new()
    }

    fn clear(&mut self) {
        self.destinationJid = ::std::option::Option::None;
        self.message.clear();
        self.phash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceSentMessage {
        static instance: DeviceSentMessage = DeviceSentMessage {
            destinationJid: ::std::option::Option::None,
            message: ::protobuf::MessageField::none(),
            phash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceSentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceSentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceSentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceSentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:FutureProofMessage)
pub struct FutureProofMessage {
    // message fields
    // @@protoc_insertion_point(field:FutureProofMessage.message)
    pub message: ::protobuf::MessageField<Message>,
    // special fields
    // @@protoc_insertion_point(special_field:FutureProofMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FutureProofMessage {
    fn default() -> &'a FutureProofMessage {
        <FutureProofMessage as ::protobuf::Message>::default_instance()
    }
}

impl FutureProofMessage {
    pub fn new() -> FutureProofMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &FutureProofMessage| { &m.message },
            |m: &mut FutureProofMessage| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FutureProofMessage>(
            "FutureProofMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FutureProofMessage {
    const NAME: &'static str = "FutureProofMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FutureProofMessage {
        FutureProofMessage::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FutureProofMessage {
        static instance: FutureProofMessage = FutureProofMessage {
            message: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FutureProofMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FutureProofMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FutureProofMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FutureProofMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ButtonText)
pub struct ButtonText {
    // message fields
    // @@protoc_insertion_point(field:ButtonText.displayText)
    pub displayText: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ButtonText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonText {
    fn default() -> &'a ButtonText {
        <ButtonText as ::protobuf::Message>::default_instance()
    }
}

impl ButtonText {
    pub fn new() -> ButtonText {
        ::std::default::Default::default()
    }

    // optional string displayText = 1;

    pub fn displayText(&self) -> &str {
        match self.displayText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayText(&mut self) {
        self.displayText = ::std::option::Option::None;
    }

    pub fn has_displayText(&self) -> bool {
        self.displayText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayText(&mut self, v: ::std::string::String) {
        self.displayText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
        if self.displayText.is_none() {
            self.displayText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayText.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayText(&mut self) -> ::std::string::String {
        self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayText",
            |m: &ButtonText| { &m.displayText },
            |m: &mut ButtonText| { &mut m.displayText },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonText>(
            "ButtonText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonText {
    const NAME: &'static str = "ButtonText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayText = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayText.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonText {
        ButtonText::new()
    }

    fn clear(&mut self) {
        self.displayText = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonText {
        static instance: ButtonText = ButtonText {
            displayText: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NativeFlowInfo)
pub struct NativeFlowInfo {
    // message fields
    // @@protoc_insertion_point(field:NativeFlowInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:NativeFlowInfo.paramsJson)
    pub paramsJson: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:NativeFlowInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NativeFlowInfo {
    fn default() -> &'a NativeFlowInfo {
        <NativeFlowInfo as ::protobuf::Message>::default_instance()
    }
}

impl NativeFlowInfo {
    pub fn new() -> NativeFlowInfo {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string paramsJson = 2;

    pub fn paramsJson(&self) -> &str {
        match self.paramsJson.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_paramsJson(&mut self) {
        self.paramsJson = ::std::option::Option::None;
    }

    pub fn has_paramsJson(&self) -> bool {
        self.paramsJson.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramsJson(&mut self, v: ::std::string::String) {
        self.paramsJson = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramsJson(&mut self) -> &mut ::std::string::String {
        if self.paramsJson.is_none() {
            self.paramsJson = ::std::option::Option::Some(::std::string::String::new());
        }
        self.paramsJson.as_mut().unwrap()
    }

    // Take field
    pub fn take_paramsJson(&mut self) -> ::std::string::String {
        self.paramsJson.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &NativeFlowInfo| { &m.name },
            |m: &mut NativeFlowInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paramsJson",
            |m: &NativeFlowInfo| { &m.paramsJson },
            |m: &mut NativeFlowInfo| { &mut m.paramsJson },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeFlowInfo>(
            "NativeFlowInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NativeFlowInfo {
    const NAME: &'static str = "NativeFlowInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.paramsJson = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.paramsJson.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.paramsJson.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NativeFlowInfo {
        NativeFlowInfo::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.paramsJson = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NativeFlowInfo {
        static instance: NativeFlowInfo = NativeFlowInfo {
            name: ::std::option::Option::None,
            paramsJson: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NativeFlowInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NativeFlowInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NativeFlowInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeFlowInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Button)
pub struct Button {
    // message fields
    // @@protoc_insertion_point(field:Button.buttonId)
    pub buttonId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Button.buttonText)
    pub buttonText: ::protobuf::MessageField<ButtonText>,
    // @@protoc_insertion_point(field:Button.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<button::ButtonType>>,
    // @@protoc_insertion_point(field:Button.nativeFlowInfo)
    pub nativeFlowInfo: ::protobuf::MessageField<NativeFlowInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:Button.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Button {
    fn default() -> &'a Button {
        <Button as ::protobuf::Message>::default_instance()
    }
}

impl Button {
    pub fn new() -> Button {
        ::std::default::Default::default()
    }

    // optional string buttonId = 1;

    pub fn buttonId(&self) -> &str {
        match self.buttonId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_buttonId(&mut self) {
        self.buttonId = ::std::option::Option::None;
    }

    pub fn has_buttonId(&self) -> bool {
        self.buttonId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buttonId(&mut self, v: ::std::string::String) {
        self.buttonId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buttonId(&mut self) -> &mut ::std::string::String {
        if self.buttonId.is_none() {
            self.buttonId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.buttonId.as_mut().unwrap()
    }

    // Take field
    pub fn take_buttonId(&mut self) -> ::std::string::String {
        self.buttonId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .Button.ButtonType type = 3;

    pub fn type_(&self) -> button::ButtonType {
        match self.type_ {
            Some(e) => e.enum_value_or(button::ButtonType::UNKNOWN),
            None => button::ButtonType::UNKNOWN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: button::ButtonType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buttonId",
            |m: &Button| { &m.buttonId },
            |m: &mut Button| { &mut m.buttonId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ButtonText>(
            "buttonText",
            |m: &Button| { &m.buttonText },
            |m: &mut Button| { &mut m.buttonText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Button| { &m.type_ },
            |m: &mut Button| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NativeFlowInfo>(
            "nativeFlowInfo",
            |m: &Button| { &m.nativeFlowInfo },
            |m: &mut Button| { &mut m.nativeFlowInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Button>(
            "Button",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Button {
    const NAME: &'static str = "Button";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.buttonId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buttonText)?;
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nativeFlowInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.buttonId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.buttonText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.nativeFlowInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.buttonId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.buttonText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.nativeFlowInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Button {
        Button::new()
    }

    fn clear(&mut self) {
        self.buttonId = ::std::option::Option::None;
        self.buttonText.clear();
        self.type_ = ::std::option::Option::None;
        self.nativeFlowInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Button {
        static instance: Button = Button {
            buttonId: ::std::option::Option::None,
            buttonText: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            nativeFlowInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Button {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Button").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Button {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Button {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Button`
pub mod button {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Button.ButtonType)
    pub enum ButtonType {
        // @@protoc_insertion_point(enum_value:Button.ButtonType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:Button.ButtonType.RESPONSE)
        RESPONSE = 1,
        // @@protoc_insertion_point(enum_value:Button.ButtonType.NATIVE_FLOW)
        NATIVE_FLOW = 2,
    }

    impl ::protobuf::Enum for ButtonType {
        const NAME: &'static str = "ButtonType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ButtonType> {
            match value {
                0 => ::std::option::Option::Some(ButtonType::UNKNOWN),
                1 => ::std::option::Option::Some(ButtonType::RESPONSE),
                2 => ::std::option::Option::Some(ButtonType::NATIVE_FLOW),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ButtonType] = &[
            ButtonType::UNKNOWN,
            ButtonType::RESPONSE,
            ButtonType::NATIVE_FLOW,
        ];
    }

    impl ::protobuf::EnumFull for ButtonType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Button.ButtonType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ButtonType {
        fn default() -> Self {
            ButtonType::UNKNOWN
        }
    }

    impl ButtonType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ButtonType>("Button.ButtonType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ButtonsMessage)
pub struct ButtonsMessage {
    // message fields
    // @@protoc_insertion_point(field:ButtonsMessage.contentText)
    pub contentText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ButtonsMessage.footerText)
    pub footerText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ButtonsMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:ButtonsMessage.buttons)
    pub buttons: ::std::vec::Vec<Button>,
    // @@protoc_insertion_point(field:ButtonsMessage.headerType)
    pub headerType: ::std::option::Option<::protobuf::EnumOrUnknown<buttons_message::ButtonsMessageHeaderType>>,
    // message oneof groups
    pub header: ::std::option::Option<buttons_message::Header>,
    // special fields
    // @@protoc_insertion_point(special_field:ButtonsMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonsMessage {
    fn default() -> &'a ButtonsMessage {
        <ButtonsMessage as ::protobuf::Message>::default_instance()
    }
}

impl ButtonsMessage {
    pub fn new() -> ButtonsMessage {
        ::std::default::Default::default()
    }

    // optional string contentText = 6;

    pub fn contentText(&self) -> &str {
        match self.contentText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_contentText(&mut self) {
        self.contentText = ::std::option::Option::None;
    }

    pub fn has_contentText(&self) -> bool {
        self.contentText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentText(&mut self, v: ::std::string::String) {
        self.contentText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentText(&mut self) -> &mut ::std::string::String {
        if self.contentText.is_none() {
            self.contentText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.contentText.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentText(&mut self) -> ::std::string::String {
        self.contentText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string footerText = 7;

    pub fn footerText(&self) -> &str {
        match self.footerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_footerText(&mut self) {
        self.footerText = ::std::option::Option::None;
    }

    pub fn has_footerText(&self) -> bool {
        self.footerText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerText(&mut self, v: ::std::string::String) {
        self.footerText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footerText(&mut self) -> &mut ::std::string::String {
        if self.footerText.is_none() {
            self.footerText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.footerText.as_mut().unwrap()
    }

    // Take field
    pub fn take_footerText(&mut self) -> ::std::string::String {
        self.footerText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ButtonsMessage.ButtonsMessageHeaderType headerType = 10;

    pub fn headerType(&self) -> buttons_message::ButtonsMessageHeaderType {
        match self.headerType {
            Some(e) => e.enum_value_or(buttons_message::ButtonsMessageHeaderType::UNKNOWN),
            None => buttons_message::ButtonsMessageHeaderType::UNKNOWN,
        }
    }

    pub fn clear_headerType(&mut self) {
        self.headerType = ::std::option::Option::None;
    }

    pub fn has_headerType(&self) -> bool {
        self.headerType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headerType(&mut self, v: buttons_message::ButtonsMessageHeaderType) {
        self.headerType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::Text(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::Text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.header = ::std::option::Option::Some(buttons_message::Header::Text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(buttons_message::Header::Text(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::Text(::std::string::String::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::Text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        if self.has_text() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::Text(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .DocumentMessage documentMessage = 2;

    pub fn documentMessage(&self) -> &DocumentMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::DocumentMessage(ref v)) => v,
            _ => <DocumentMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_documentMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_documentMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::DocumentMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_documentMessage(&mut self, v: DocumentMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::DocumentMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_documentMessage(&mut self) -> &mut DocumentMessage {
        if let ::std::option::Option::Some(buttons_message::Header::DocumentMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::DocumentMessage(DocumentMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::DocumentMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_documentMessage(&mut self) -> DocumentMessage {
        if self.has_documentMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::DocumentMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            DocumentMessage::new()
        }
    }

    // optional .ImageMessage imageMessage = 3;

    pub fn imageMessage(&self) -> &ImageMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::ImageMessage(ref v)) => v,
            _ => <ImageMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_imageMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_imageMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::ImageMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_imageMessage(&mut self, v: ImageMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::ImageMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_imageMessage(&mut self) -> &mut ImageMessage {
        if let ::std::option::Option::Some(buttons_message::Header::ImageMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::ImageMessage(ImageMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::ImageMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_imageMessage(&mut self) -> ImageMessage {
        if self.has_imageMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::ImageMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ImageMessage::new()
        }
    }

    // optional .VideoMessage videoMessage = 4;

    pub fn videoMessage(&self) -> &VideoMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::VideoMessage(ref v)) => v,
            _ => <VideoMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_videoMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::VideoMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoMessage(&mut self, v: VideoMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::VideoMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoMessage(&mut self) -> &mut VideoMessage {
        if let ::std::option::Option::Some(buttons_message::Header::VideoMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::VideoMessage(VideoMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::VideoMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoMessage(&mut self) -> VideoMessage {
        if self.has_videoMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::VideoMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoMessage::new()
        }
    }

    // optional .LocationMessage locationMessage = 5;

    pub fn locationMessage(&self) -> &LocationMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::LocationMessage(ref v)) => v,
            _ => <LocationMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_locationMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_locationMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::LocationMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_locationMessage(&mut self, v: LocationMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::LocationMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_locationMessage(&mut self) -> &mut LocationMessage {
        if let ::std::option::Option::Some(buttons_message::Header::LocationMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::LocationMessage(LocationMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::LocationMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_locationMessage(&mut self) -> LocationMessage {
        if self.has_locationMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::LocationMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            LocationMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contentText",
            |m: &ButtonsMessage| { &m.contentText },
            |m: &mut ButtonsMessage| { &mut m.contentText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footerText",
            |m: &ButtonsMessage| { &m.footerText },
            |m: &mut ButtonsMessage| { &mut m.footerText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ButtonsMessage| { &m.contextInfo },
            |m: &mut ButtonsMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buttons",
            |m: &ButtonsMessage| { &m.buttons },
            |m: &mut ButtonsMessage| { &mut m.buttons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "headerType",
            |m: &ButtonsMessage| { &m.headerType },
            |m: &mut ButtonsMessage| { &mut m.headerType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "text",
            ButtonsMessage::has_text,
            ButtonsMessage::text,
            ButtonsMessage::set_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DocumentMessage>(
            "documentMessage",
            ButtonsMessage::has_documentMessage,
            ButtonsMessage::documentMessage,
            ButtonsMessage::mut_documentMessage,
            ButtonsMessage::set_documentMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ImageMessage>(
            "imageMessage",
            ButtonsMessage::has_imageMessage,
            ButtonsMessage::imageMessage,
            ButtonsMessage::mut_imageMessage,
            ButtonsMessage::set_imageMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoMessage>(
            "videoMessage",
            ButtonsMessage::has_videoMessage,
            ButtonsMessage::videoMessage,
            ButtonsMessage::mut_videoMessage,
            ButtonsMessage::set_videoMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LocationMessage>(
            "locationMessage",
            ButtonsMessage::has_locationMessage,
            ButtonsMessage::locationMessage,
            ButtonsMessage::mut_locationMessage,
            ButtonsMessage::set_locationMessage,
        ));
        oneofs.push(buttons_message::Header::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonsMessage>(
            "ButtonsMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonsMessage {
    const NAME: &'static str = "ButtonsMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.contentText = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.footerText = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                74 => {
                    self.buttons.push(is.read_message()?);
                },
                80 => {
                    self.headerType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                10 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::Text(is.read_string()?));
                },
                18 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::DocumentMessage(is.read_message()?));
                },
                26 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::ImageMessage(is.read_message()?));
                },
                34 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::VideoMessage(is.read_message()?));
                },
                42 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::LocationMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contentText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.footerText.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.buttons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.headerType {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.header {
            match v {
                &buttons_message::Header::Text(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &buttons_message::Header::DocumentMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &buttons_message::Header::ImageMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &buttons_message::Header::VideoMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &buttons_message::Header::LocationMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contentText.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.footerText.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.buttons {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.headerType {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.header {
            match v {
                &buttons_message::Header::Text(ref v) => {
                    os.write_string(1, v)?;
                },
                &buttons_message::Header::DocumentMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &buttons_message::Header::ImageMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &buttons_message::Header::VideoMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &buttons_message::Header::LocationMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonsMessage {
        ButtonsMessage::new()
    }

    fn clear(&mut self) {
        self.contentText = ::std::option::Option::None;
        self.footerText = ::std::option::Option::None;
        self.contextInfo.clear();
        self.buttons.clear();
        self.headerType = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonsMessage {
        static instance: ButtonsMessage = ButtonsMessage {
            contentText: ::std::option::Option::None,
            footerText: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            buttons: ::std::vec::Vec::new(),
            headerType: ::std::option::Option::None,
            header: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonsMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonsMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonsMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonsMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ButtonsMessage`
pub mod buttons_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ButtonsMessage.header)
    pub enum Header {
        // @@protoc_insertion_point(oneof_field:ButtonsMessage.text)
        Text(::std::string::String),
        // @@protoc_insertion_point(oneof_field:ButtonsMessage.documentMessage)
        DocumentMessage(super::DocumentMessage),
        // @@protoc_insertion_point(oneof_field:ButtonsMessage.imageMessage)
        ImageMessage(super::ImageMessage),
        // @@protoc_insertion_point(oneof_field:ButtonsMessage.videoMessage)
        VideoMessage(super::VideoMessage),
        // @@protoc_insertion_point(oneof_field:ButtonsMessage.locationMessage)
        LocationMessage(super::LocationMessage),
    }

    impl ::protobuf::Oneof for Header {
    }

    impl ::protobuf::OneofFull for Header {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ButtonsMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("header").unwrap()).clone()
        }
    }

    impl Header {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Header>("header")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ButtonsMessage.ButtonsMessageHeaderType)
    pub enum ButtonsMessageHeaderType {
        // @@protoc_insertion_point(enum_value:ButtonsMessage.ButtonsMessageHeaderType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:ButtonsMessage.ButtonsMessageHeaderType.EMPTY)
        EMPTY = 1,
        // @@protoc_insertion_point(enum_value:ButtonsMessage.ButtonsMessageHeaderType.TEXT)
        TEXT = 2,
        // @@protoc_insertion_point(enum_value:ButtonsMessage.ButtonsMessageHeaderType.DOCUMENT)
        DOCUMENT = 3,
        // @@protoc_insertion_point(enum_value:ButtonsMessage.ButtonsMessageHeaderType.IMAGE)
        IMAGE = 4,
        // @@protoc_insertion_point(enum_value:ButtonsMessage.ButtonsMessageHeaderType.VIDEO)
        VIDEO = 5,
        // @@protoc_insertion_point(enum_value:ButtonsMessage.ButtonsMessageHeaderType.LOCATION)
        LOCATION = 6,
    }

    impl ::protobuf::Enum for ButtonsMessageHeaderType {
        const NAME: &'static str = "ButtonsMessageHeaderType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ButtonsMessageHeaderType> {
            match value {
                0 => ::std::option::Option::Some(ButtonsMessageHeaderType::UNKNOWN),
                1 => ::std::option::Option::Some(ButtonsMessageHeaderType::EMPTY),
                2 => ::std::option::Option::Some(ButtonsMessageHeaderType::TEXT),
                3 => ::std::option::Option::Some(ButtonsMessageHeaderType::DOCUMENT),
                4 => ::std::option::Option::Some(ButtonsMessageHeaderType::IMAGE),
                5 => ::std::option::Option::Some(ButtonsMessageHeaderType::VIDEO),
                6 => ::std::option::Option::Some(ButtonsMessageHeaderType::LOCATION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ButtonsMessageHeaderType] = &[
            ButtonsMessageHeaderType::UNKNOWN,
            ButtonsMessageHeaderType::EMPTY,
            ButtonsMessageHeaderType::TEXT,
            ButtonsMessageHeaderType::DOCUMENT,
            ButtonsMessageHeaderType::IMAGE,
            ButtonsMessageHeaderType::VIDEO,
            ButtonsMessageHeaderType::LOCATION,
        ];
    }

    impl ::protobuf::EnumFull for ButtonsMessageHeaderType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ButtonsMessage.ButtonsMessageHeaderType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ButtonsMessageHeaderType {
        fn default() -> Self {
            ButtonsMessageHeaderType::UNKNOWN
        }
    }

    impl ButtonsMessageHeaderType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ButtonsMessageHeaderType>("ButtonsMessage.ButtonsMessageHeaderType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ButtonsResponseMessage)
pub struct ButtonsResponseMessage {
    // message fields
    // @@protoc_insertion_point(field:ButtonsResponseMessage.selectedButtonId)
    pub selectedButtonId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ButtonsResponseMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:ButtonsResponseMessage.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<buttons_response_message::ButtonsResponseMessageType>>,
    // message oneof groups
    pub response: ::std::option::Option<buttons_response_message::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:ButtonsResponseMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonsResponseMessage {
    fn default() -> &'a ButtonsResponseMessage {
        <ButtonsResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl ButtonsResponseMessage {
    pub fn new() -> ButtonsResponseMessage {
        ::std::default::Default::default()
    }

    // optional string selectedButtonId = 1;

    pub fn selectedButtonId(&self) -> &str {
        match self.selectedButtonId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedButtonId(&mut self) {
        self.selectedButtonId = ::std::option::Option::None;
    }

    pub fn has_selectedButtonId(&self) -> bool {
        self.selectedButtonId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedButtonId(&mut self, v: ::std::string::String) {
        self.selectedButtonId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedButtonId(&mut self) -> &mut ::std::string::String {
        if self.selectedButtonId.is_none() {
            self.selectedButtonId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedButtonId.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedButtonId(&mut self) -> ::std::string::String {
        self.selectedButtonId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ButtonsResponseMessage.ButtonsResponseMessageType type = 4;

    pub fn type_(&self) -> buttons_response_message::ButtonsResponseMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(buttons_response_message::ButtonsResponseMessageType::UNKNOWN),
            None => buttons_response_message::ButtonsResponseMessageType::UNKNOWN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: buttons_response_message::ButtonsResponseMessageType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string selectedDisplayText = 2;

    pub fn selectedDisplayText(&self) -> &str {
        match self.response {
            ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_selectedDisplayText(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_selectedDisplayText(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selectedDisplayText(&mut self, v: ::std::string::String) {
        self.response = ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(v))
    }

    // Mutable pointer to the field.
    pub fn mut_selectedDisplayText(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(::std::string::String::new()));
        }
        match self.response {
            ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_selectedDisplayText(&mut self) -> ::std::string::String {
        if self.has_selectedDisplayText() {
            match self.response.take() {
                ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedButtonId",
            |m: &ButtonsResponseMessage| { &m.selectedButtonId },
            |m: &mut ButtonsResponseMessage| { &mut m.selectedButtonId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ButtonsResponseMessage| { &m.contextInfo },
            |m: &mut ButtonsResponseMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ButtonsResponseMessage| { &m.type_ },
            |m: &mut ButtonsResponseMessage| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "selectedDisplayText",
            ButtonsResponseMessage::has_selectedDisplayText,
            ButtonsResponseMessage::selectedDisplayText,
            ButtonsResponseMessage::set_selectedDisplayText,
        ));
        oneofs.push(buttons_response_message::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonsResponseMessage>(
            "ButtonsResponseMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonsResponseMessage {
    const NAME: &'static str = "ButtonsResponseMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectedButtonId = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.response = ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selectedButtonId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &buttons_response_message::Response::SelectedDisplayText(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selectedButtonId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &buttons_response_message::Response::SelectedDisplayText(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonsResponseMessage {
        ButtonsResponseMessage::new()
    }

    fn clear(&mut self) {
        self.selectedButtonId = ::std::option::Option::None;
        self.contextInfo.clear();
        self.type_ = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonsResponseMessage {
        static instance: ButtonsResponseMessage = ButtonsResponseMessage {
            selectedButtonId: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonsResponseMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonsResponseMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonsResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonsResponseMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ButtonsResponseMessage`
pub mod buttons_response_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ButtonsResponseMessage.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:ButtonsResponseMessage.selectedDisplayText)
        SelectedDisplayText(::std::string::String),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ButtonsResponseMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:ButtonsResponseMessage.ButtonsResponseMessageType)
    pub enum ButtonsResponseMessageType {
        // @@protoc_insertion_point(enum_value:ButtonsResponseMessage.ButtonsResponseMessageType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:ButtonsResponseMessage.ButtonsResponseMessageType.DISPLAY_TEXT)
        DISPLAY_TEXT = 1,
    }

    impl ::protobuf::Enum for ButtonsResponseMessageType {
        const NAME: &'static str = "ButtonsResponseMessageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ButtonsResponseMessageType> {
            match value {
                0 => ::std::option::Option::Some(ButtonsResponseMessageType::UNKNOWN),
                1 => ::std::option::Option::Some(ButtonsResponseMessageType::DISPLAY_TEXT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ButtonsResponseMessageType] = &[
            ButtonsResponseMessageType::UNKNOWN,
            ButtonsResponseMessageType::DISPLAY_TEXT,
        ];
    }

    impl ::protobuf::EnumFull for ButtonsResponseMessageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ButtonsResponseMessage.ButtonsResponseMessageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ButtonsResponseMessageType {
        fn default() -> Self {
            ButtonsResponseMessageType::UNKNOWN
        }
    }

    impl ButtonsResponseMessageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ButtonsResponseMessageType>("ButtonsResponseMessage.ButtonsResponseMessageType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ReactionMessage)
pub struct ReactionMessage {
    // message fields
    // @@protoc_insertion_point(field:ReactionMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:ReactionMessage.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ReactionMessage.groupingKey)
    pub groupingKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ReactionMessage.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ReactionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReactionMessage {
    fn default() -> &'a ReactionMessage {
        <ReactionMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReactionMessage {
    pub fn new() -> ReactionMessage {
        ::std::default::Default::default()
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupingKey = 3;

    pub fn groupingKey(&self) -> &str {
        match self.groupingKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupingKey(&mut self) {
        self.groupingKey = ::std::option::Option::None;
    }

    pub fn has_groupingKey(&self) -> bool {
        self.groupingKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupingKey(&mut self, v: ::std::string::String) {
        self.groupingKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupingKey(&mut self) -> &mut ::std::string::String {
        if self.groupingKey.is_none() {
            self.groupingKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupingKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupingKey(&mut self) -> ::std::string::String {
        self.groupingKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 senderTimestampMs = 4;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &ReactionMessage| { &m.key },
            |m: &mut ReactionMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &ReactionMessage| { &m.text },
            |m: &mut ReactionMessage| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupingKey",
            |m: &ReactionMessage| { &m.groupingKey },
            |m: &mut ReactionMessage| { &mut m.groupingKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &ReactionMessage| { &m.senderTimestampMs },
            |m: &mut ReactionMessage| { &mut m.senderTimestampMs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReactionMessage>(
            "ReactionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReactionMessage {
    const NAME: &'static str = "ReactionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.groupingKey = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.groupingKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.groupingKey.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReactionMessage {
        ReactionMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.text = ::std::option::Option::None;
        self.groupingKey = ::std::option::Option::None;
        self.senderTimestampMs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReactionMessage {
        static instance: ReactionMessage = ReactionMessage {
            key: ::protobuf::MessageField::none(),
            text: ::std::option::Option::None,
            groupingKey: ::std::option::Option::None,
            senderTimestampMs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReactionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReactionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReactionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:StickerSyncRMRMessage)
pub struct StickerSyncRMRMessage {
    // message fields
    // @@protoc_insertion_point(field:StickerSyncRMRMessage.filehash)
    pub filehash: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:StickerSyncRMRMessage.rmrSource)
    pub rmrSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StickerSyncRMRMessage.requestTimestamp)
    pub requestTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:StickerSyncRMRMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StickerSyncRMRMessage {
    fn default() -> &'a StickerSyncRMRMessage {
        <StickerSyncRMRMessage as ::protobuf::Message>::default_instance()
    }
}

impl StickerSyncRMRMessage {
    pub fn new() -> StickerSyncRMRMessage {
        ::std::default::Default::default()
    }

    // optional string rmrSource = 2;

    pub fn rmrSource(&self) -> &str {
        match self.rmrSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rmrSource(&mut self) {
        self.rmrSource = ::std::option::Option::None;
    }

    pub fn has_rmrSource(&self) -> bool {
        self.rmrSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rmrSource(&mut self, v: ::std::string::String) {
        self.rmrSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rmrSource(&mut self) -> &mut ::std::string::String {
        if self.rmrSource.is_none() {
            self.rmrSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rmrSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_rmrSource(&mut self) -> ::std::string::String {
        self.rmrSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 requestTimestamp = 3;

    pub fn requestTimestamp(&self) -> i64 {
        self.requestTimestamp.unwrap_or(0)
    }

    pub fn clear_requestTimestamp(&mut self) {
        self.requestTimestamp = ::std::option::Option::None;
    }

    pub fn has_requestTimestamp(&self) -> bool {
        self.requestTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestTimestamp(&mut self, v: i64) {
        self.requestTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filehash",
            |m: &StickerSyncRMRMessage| { &m.filehash },
            |m: &mut StickerSyncRMRMessage| { &mut m.filehash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rmrSource",
            |m: &StickerSyncRMRMessage| { &m.rmrSource },
            |m: &mut StickerSyncRMRMessage| { &mut m.rmrSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requestTimestamp",
            |m: &StickerSyncRMRMessage| { &m.requestTimestamp },
            |m: &mut StickerSyncRMRMessage| { &mut m.requestTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StickerSyncRMRMessage>(
            "StickerSyncRMRMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StickerSyncRMRMessage {
    const NAME: &'static str = "StickerSyncRMRMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filehash.push(is.read_string()?);
                },
                18 => {
                    self.rmrSource = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.requestTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.filehash {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.rmrSource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.requestTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.filehash {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.rmrSource.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.requestTimestamp {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StickerSyncRMRMessage {
        StickerSyncRMRMessage::new()
    }

    fn clear(&mut self) {
        self.filehash.clear();
        self.rmrSource = ::std::option::Option::None;
        self.requestTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StickerSyncRMRMessage {
        static instance: StickerSyncRMRMessage = StickerSyncRMRMessage {
            filehash: ::std::vec::Vec::new(),
            rmrSource: ::std::option::Option::None,
            requestTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StickerSyncRMRMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StickerSyncRMRMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StickerSyncRMRMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StickerSyncRMRMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Message)
pub struct Message {
    // message fields
    // @@protoc_insertion_point(field:Message.conversation)
    pub conversation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Message.senderKeyDistributionMessage)
    pub senderKeyDistributionMessage: ::protobuf::MessageField<SenderKeyDistributionMessage>,
    // @@protoc_insertion_point(field:Message.imageMessage)
    pub imageMessage: ::protobuf::MessageField<ImageMessage>,
    // @@protoc_insertion_point(field:Message.contactMessage)
    pub contactMessage: ::protobuf::MessageField<ContactMessage>,
    // @@protoc_insertion_point(field:Message.locationMessage)
    pub locationMessage: ::protobuf::MessageField<LocationMessage>,
    // @@protoc_insertion_point(field:Message.extendedTextMessage)
    pub extendedTextMessage: ::protobuf::MessageField<ExtendedTextMessage>,
    // @@protoc_insertion_point(field:Message.documentMessage)
    pub documentMessage: ::protobuf::MessageField<DocumentMessage>,
    // @@protoc_insertion_point(field:Message.audioMessage)
    pub audioMessage: ::protobuf::MessageField<AudioMessage>,
    // @@protoc_insertion_point(field:Message.videoMessage)
    pub videoMessage: ::protobuf::MessageField<VideoMessage>,
    // @@protoc_insertion_point(field:Message.call)
    pub call: ::protobuf::MessageField<Call>,
    // @@protoc_insertion_point(field:Message.chat)
    pub chat: ::protobuf::MessageField<Chat>,
    // @@protoc_insertion_point(field:Message.protocolMessage)
    pub protocolMessage: ::protobuf::MessageField<ProtocolMessage>,
    // @@protoc_insertion_point(field:Message.contactsArrayMessage)
    pub contactsArrayMessage: ::protobuf::MessageField<ContactsArrayMessage>,
    // @@protoc_insertion_point(field:Message.highlyStructuredMessage)
    pub highlyStructuredMessage: ::protobuf::MessageField<HighlyStructuredMessage>,
    // @@protoc_insertion_point(field:Message.fastRatchetKeySenderKeyDistributionMessage)
    pub fastRatchetKeySenderKeyDistributionMessage: ::protobuf::MessageField<SenderKeyDistributionMessage>,
    // @@protoc_insertion_point(field:Message.sendPaymentMessage)
    pub sendPaymentMessage: ::protobuf::MessageField<SendPaymentMessage>,
    // @@protoc_insertion_point(field:Message.liveLocationMessage)
    pub liveLocationMessage: ::protobuf::MessageField<LiveLocationMessage>,
    // @@protoc_insertion_point(field:Message.requestPaymentMessage)
    pub requestPaymentMessage: ::protobuf::MessageField<RequestPaymentMessage>,
    // @@protoc_insertion_point(field:Message.declinePaymentRequestMessage)
    pub declinePaymentRequestMessage: ::protobuf::MessageField<DeclinePaymentRequestMessage>,
    // @@protoc_insertion_point(field:Message.cancelPaymentRequestMessage)
    pub cancelPaymentRequestMessage: ::protobuf::MessageField<CancelPaymentRequestMessage>,
    // @@protoc_insertion_point(field:Message.templateMessage)
    pub templateMessage: ::protobuf::MessageField<TemplateMessage>,
    // @@protoc_insertion_point(field:Message.stickerMessage)
    pub stickerMessage: ::protobuf::MessageField<StickerMessage>,
    // @@protoc_insertion_point(field:Message.groupInviteMessage)
    pub groupInviteMessage: ::protobuf::MessageField<GroupInviteMessage>,
    // @@protoc_insertion_point(field:Message.templateButtonReplyMessage)
    pub templateButtonReplyMessage: ::protobuf::MessageField<TemplateButtonReplyMessage>,
    // @@protoc_insertion_point(field:Message.productMessage)
    pub productMessage: ::protobuf::MessageField<ProductMessage>,
    // @@protoc_insertion_point(field:Message.deviceSentMessage)
    pub deviceSentMessage: ::protobuf::MessageField<DeviceSentMessage>,
    // @@protoc_insertion_point(field:Message.messageContextInfo)
    pub messageContextInfo: ::protobuf::MessageField<MessageContextInfo>,
    // @@protoc_insertion_point(field:Message.listMessage)
    pub listMessage: ::protobuf::MessageField<ListMessage>,
    // @@protoc_insertion_point(field:Message.viewOnceMessage)
    pub viewOnceMessage: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:Message.orderMessage)
    pub orderMessage: ::protobuf::MessageField<OrderMessage>,
    // @@protoc_insertion_point(field:Message.listResponseMessage)
    pub listResponseMessage: ::protobuf::MessageField<ListResponseMessage>,
    // @@protoc_insertion_point(field:Message.ephemeralMessage)
    pub ephemeralMessage: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:Message.invoiceMessage)
    pub invoiceMessage: ::protobuf::MessageField<InvoiceMessage>,
    // @@protoc_insertion_point(field:Message.buttonsMessage)
    pub buttonsMessage: ::protobuf::MessageField<ButtonsMessage>,
    // @@protoc_insertion_point(field:Message.buttonsResponseMessage)
    pub buttonsResponseMessage: ::protobuf::MessageField<ButtonsResponseMessage>,
    // @@protoc_insertion_point(field:Message.paymentInviteMessage)
    pub paymentInviteMessage: ::protobuf::MessageField<PaymentInviteMessage>,
    // @@protoc_insertion_point(field:Message.interactiveMessage)
    pub interactiveMessage: ::protobuf::MessageField<InteractiveMessage>,
    // @@protoc_insertion_point(field:Message.reactionMessage)
    pub reactionMessage: ::protobuf::MessageField<ReactionMessage>,
    // @@protoc_insertion_point(field:Message.stickerSyncRmrMessage)
    pub stickerSyncRmrMessage: ::protobuf::MessageField<StickerSyncRMRMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // optional string conversation = 1;

    pub fn conversation(&self) -> &str {
        match self.conversation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conversation(&mut self) {
        self.conversation = ::std::option::Option::None;
    }

    pub fn has_conversation(&self) -> bool {
        self.conversation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversation(&mut self, v: ::std::string::String) {
        self.conversation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversation(&mut self) -> &mut ::std::string::String {
        if self.conversation.is_none() {
            self.conversation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conversation.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversation(&mut self) -> ::std::string::String {
        self.conversation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(39);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversation",
            |m: &Message| { &m.conversation },
            |m: &mut Message| { &mut m.conversation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SenderKeyDistributionMessage>(
            "senderKeyDistributionMessage",
            |m: &Message| { &m.senderKeyDistributionMessage },
            |m: &mut Message| { &mut m.senderKeyDistributionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageMessage>(
            "imageMessage",
            |m: &Message| { &m.imageMessage },
            |m: &mut Message| { &mut m.imageMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContactMessage>(
            "contactMessage",
            |m: &Message| { &m.contactMessage },
            |m: &mut Message| { &mut m.contactMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocationMessage>(
            "locationMessage",
            |m: &Message| { &m.locationMessage },
            |m: &mut Message| { &mut m.locationMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExtendedTextMessage>(
            "extendedTextMessage",
            |m: &Message| { &m.extendedTextMessage },
            |m: &mut Message| { &mut m.extendedTextMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DocumentMessage>(
            "documentMessage",
            |m: &Message| { &m.documentMessage },
            |m: &mut Message| { &mut m.documentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AudioMessage>(
            "audioMessage",
            |m: &Message| { &m.audioMessage },
            |m: &mut Message| { &mut m.audioMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VideoMessage>(
            "videoMessage",
            |m: &Message| { &m.videoMessage },
            |m: &mut Message| { &mut m.videoMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Call>(
            "call",
            |m: &Message| { &m.call },
            |m: &mut Message| { &mut m.call },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Chat>(
            "chat",
            |m: &Message| { &m.chat },
            |m: &mut Message| { &mut m.chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtocolMessage>(
            "protocolMessage",
            |m: &Message| { &m.protocolMessage },
            |m: &mut Message| { &mut m.protocolMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContactsArrayMessage>(
            "contactsArrayMessage",
            |m: &Message| { &m.contactsArrayMessage },
            |m: &mut Message| { &mut m.contactsArrayMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "highlyStructuredMessage",
            |m: &Message| { &m.highlyStructuredMessage },
            |m: &mut Message| { &mut m.highlyStructuredMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SenderKeyDistributionMessage>(
            "fastRatchetKeySenderKeyDistributionMessage",
            |m: &Message| { &m.fastRatchetKeySenderKeyDistributionMessage },
            |m: &mut Message| { &mut m.fastRatchetKeySenderKeyDistributionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SendPaymentMessage>(
            "sendPaymentMessage",
            |m: &Message| { &m.sendPaymentMessage },
            |m: &mut Message| { &mut m.sendPaymentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LiveLocationMessage>(
            "liveLocationMessage",
            |m: &Message| { &m.liveLocationMessage },
            |m: &mut Message| { &mut m.liveLocationMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RequestPaymentMessage>(
            "requestPaymentMessage",
            |m: &Message| { &m.requestPaymentMessage },
            |m: &mut Message| { &mut m.requestPaymentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeclinePaymentRequestMessage>(
            "declinePaymentRequestMessage",
            |m: &Message| { &m.declinePaymentRequestMessage },
            |m: &mut Message| { &mut m.declinePaymentRequestMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CancelPaymentRequestMessage>(
            "cancelPaymentRequestMessage",
            |m: &Message| { &m.cancelPaymentRequestMessage },
            |m: &mut Message| { &mut m.cancelPaymentRequestMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TemplateMessage>(
            "templateMessage",
            |m: &Message| { &m.templateMessage },
            |m: &mut Message| { &mut m.templateMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StickerMessage>(
            "stickerMessage",
            |m: &Message| { &m.stickerMessage },
            |m: &mut Message| { &mut m.stickerMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupInviteMessage>(
            "groupInviteMessage",
            |m: &Message| { &m.groupInviteMessage },
            |m: &mut Message| { &mut m.groupInviteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TemplateButtonReplyMessage>(
            "templateButtonReplyMessage",
            |m: &Message| { &m.templateButtonReplyMessage },
            |m: &mut Message| { &mut m.templateButtonReplyMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductMessage>(
            "productMessage",
            |m: &Message| { &m.productMessage },
            |m: &mut Message| { &mut m.productMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceSentMessage>(
            "deviceSentMessage",
            |m: &Message| { &m.deviceSentMessage },
            |m: &mut Message| { &mut m.deviceSentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageContextInfo>(
            "messageContextInfo",
            |m: &Message| { &m.messageContextInfo },
            |m: &mut Message| { &mut m.messageContextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListMessage>(
            "listMessage",
            |m: &Message| { &m.listMessage },
            |m: &mut Message| { &mut m.listMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "viewOnceMessage",
            |m: &Message| { &m.viewOnceMessage },
            |m: &mut Message| { &mut m.viewOnceMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OrderMessage>(
            "orderMessage",
            |m: &Message| { &m.orderMessage },
            |m: &mut Message| { &mut m.orderMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListResponseMessage>(
            "listResponseMessage",
            |m: &Message| { &m.listResponseMessage },
            |m: &mut Message| { &mut m.listResponseMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "ephemeralMessage",
            |m: &Message| { &m.ephemeralMessage },
            |m: &mut Message| { &mut m.ephemeralMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InvoiceMessage>(
            "invoiceMessage",
            |m: &Message| { &m.invoiceMessage },
            |m: &mut Message| { &mut m.invoiceMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ButtonsMessage>(
            "buttonsMessage",
            |m: &Message| { &m.buttonsMessage },
            |m: &mut Message| { &mut m.buttonsMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ButtonsResponseMessage>(
            "buttonsResponseMessage",
            |m: &Message| { &m.buttonsResponseMessage },
            |m: &mut Message| { &mut m.buttonsResponseMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentInviteMessage>(
            "paymentInviteMessage",
            |m: &Message| { &m.paymentInviteMessage },
            |m: &mut Message| { &mut m.paymentInviteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InteractiveMessage>(
            "interactiveMessage",
            |m: &Message| { &m.interactiveMessage },
            |m: &mut Message| { &mut m.interactiveMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReactionMessage>(
            "reactionMessage",
            |m: &Message| { &m.reactionMessage },
            |m: &mut Message| { &mut m.reactionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StickerSyncRMRMessage>(
            "stickerSyncRmrMessage",
            |m: &Message| { &m.stickerSyncRmrMessage },
            |m: &mut Message| { &mut m.stickerSyncRmrMessage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conversation = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.senderKeyDistributionMessage)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.imageMessage)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contactMessage)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.locationMessage)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extendedTextMessage)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.documentMessage)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audioMessage)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.videoMessage)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.call)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.protocolMessage)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contactsArrayMessage)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.highlyStructuredMessage)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fastRatchetKeySenderKeyDistributionMessage)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sendPaymentMessage)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.liveLocationMessage)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requestPaymentMessage)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.declinePaymentRequestMessage)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cancelPaymentRequestMessage)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.templateMessage)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerMessage)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.groupInviteMessage)?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.templateButtonReplyMessage)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.productMessage)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceSentMessage)?;
                },
                282 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageContextInfo)?;
                },
                290 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.listMessage)?;
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.viewOnceMessage)?;
                },
                306 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.orderMessage)?;
                },
                314 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.listResponseMessage)?;
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ephemeralMessage)?;
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.invoiceMessage)?;
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buttonsMessage)?;
                },
                346 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buttonsResponseMessage)?;
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paymentInviteMessage)?;
                },
                362 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.interactiveMessage)?;
                },
                370 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reactionMessage)?;
                },
                378 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerSyncRmrMessage)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.conversation.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.senderKeyDistributionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.imageMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contactMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.locationMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extendedTextMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.documentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.audioMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.videoMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.call.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.protocolMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contactsArrayMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.highlyStructuredMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fastRatchetKeySenderKeyDistributionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sendPaymentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.liveLocationMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.requestPaymentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.declinePaymentRequestMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cancelPaymentRequestMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.templateMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickerMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.groupInviteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.templateButtonReplyMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.productMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deviceSentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.messageContextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.listMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.viewOnceMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.orderMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.listResponseMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ephemeralMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.invoiceMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buttonsMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buttonsResponseMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.paymentInviteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.interactiveMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reactionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickerSyncRmrMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.conversation.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.senderKeyDistributionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.imageMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.contactMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.locationMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.extendedTextMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.documentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.audioMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.videoMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.call.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.chat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.protocolMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.contactsArrayMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.highlyStructuredMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.fastRatchetKeySenderKeyDistributionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.sendPaymentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.liveLocationMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.requestPaymentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.declinePaymentRequestMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.cancelPaymentRequestMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.templateMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.stickerMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.groupInviteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.templateButtonReplyMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.productMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.deviceSentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.messageContextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.listMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.viewOnceMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.orderMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        if let Some(v) = self.listResponseMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        if let Some(v) = self.ephemeralMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.invoiceMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.buttonsMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.buttonsResponseMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.paymentInviteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        if let Some(v) = self.interactiveMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        }
        if let Some(v) = self.reactionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
        }
        if let Some(v) = self.stickerSyncRmrMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.conversation = ::std::option::Option::None;
        self.senderKeyDistributionMessage.clear();
        self.imageMessage.clear();
        self.contactMessage.clear();
        self.locationMessage.clear();
        self.extendedTextMessage.clear();
        self.documentMessage.clear();
        self.audioMessage.clear();
        self.videoMessage.clear();
        self.call.clear();
        self.chat.clear();
        self.protocolMessage.clear();
        self.contactsArrayMessage.clear();
        self.highlyStructuredMessage.clear();
        self.fastRatchetKeySenderKeyDistributionMessage.clear();
        self.sendPaymentMessage.clear();
        self.liveLocationMessage.clear();
        self.requestPaymentMessage.clear();
        self.declinePaymentRequestMessage.clear();
        self.cancelPaymentRequestMessage.clear();
        self.templateMessage.clear();
        self.stickerMessage.clear();
        self.groupInviteMessage.clear();
        self.templateButtonReplyMessage.clear();
        self.productMessage.clear();
        self.deviceSentMessage.clear();
        self.messageContextInfo.clear();
        self.listMessage.clear();
        self.viewOnceMessage.clear();
        self.orderMessage.clear();
        self.listResponseMessage.clear();
        self.ephemeralMessage.clear();
        self.invoiceMessage.clear();
        self.buttonsMessage.clear();
        self.buttonsResponseMessage.clear();
        self.paymentInviteMessage.clear();
        self.interactiveMessage.clear();
        self.reactionMessage.clear();
        self.stickerSyncRmrMessage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            conversation: ::std::option::Option::None,
            senderKeyDistributionMessage: ::protobuf::MessageField::none(),
            imageMessage: ::protobuf::MessageField::none(),
            contactMessage: ::protobuf::MessageField::none(),
            locationMessage: ::protobuf::MessageField::none(),
            extendedTextMessage: ::protobuf::MessageField::none(),
            documentMessage: ::protobuf::MessageField::none(),
            audioMessage: ::protobuf::MessageField::none(),
            videoMessage: ::protobuf::MessageField::none(),
            call: ::protobuf::MessageField::none(),
            chat: ::protobuf::MessageField::none(),
            protocolMessage: ::protobuf::MessageField::none(),
            contactsArrayMessage: ::protobuf::MessageField::none(),
            highlyStructuredMessage: ::protobuf::MessageField::none(),
            fastRatchetKeySenderKeyDistributionMessage: ::protobuf::MessageField::none(),
            sendPaymentMessage: ::protobuf::MessageField::none(),
            liveLocationMessage: ::protobuf::MessageField::none(),
            requestPaymentMessage: ::protobuf::MessageField::none(),
            declinePaymentRequestMessage: ::protobuf::MessageField::none(),
            cancelPaymentRequestMessage: ::protobuf::MessageField::none(),
            templateMessage: ::protobuf::MessageField::none(),
            stickerMessage: ::protobuf::MessageField::none(),
            groupInviteMessage: ::protobuf::MessageField::none(),
            templateButtonReplyMessage: ::protobuf::MessageField::none(),
            productMessage: ::protobuf::MessageField::none(),
            deviceSentMessage: ::protobuf::MessageField::none(),
            messageContextInfo: ::protobuf::MessageField::none(),
            listMessage: ::protobuf::MessageField::none(),
            viewOnceMessage: ::protobuf::MessageField::none(),
            orderMessage: ::protobuf::MessageField::none(),
            listResponseMessage: ::protobuf::MessageField::none(),
            ephemeralMessage: ::protobuf::MessageField::none(),
            invoiceMessage: ::protobuf::MessageField::none(),
            buttonsMessage: ::protobuf::MessageField::none(),
            buttonsResponseMessage: ::protobuf::MessageField::none(),
            paymentInviteMessage: ::protobuf::MessageField::none(),
            interactiveMessage: ::protobuf::MessageField::none(),
            reactionMessage: ::protobuf::MessageField::none(),
            stickerSyncRmrMessage: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ActionLink)
pub struct ActionLink {
    // message fields
    // @@protoc_insertion_point(field:ActionLink.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ActionLink.buttonTitle)
    pub buttonTitle: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ActionLink.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionLink {
    fn default() -> &'a ActionLink {
        <ActionLink as ::protobuf::Message>::default_instance()
    }
}

impl ActionLink {
    pub fn new() -> ActionLink {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string buttonTitle = 2;

    pub fn buttonTitle(&self) -> &str {
        match self.buttonTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_buttonTitle(&mut self) {
        self.buttonTitle = ::std::option::Option::None;
    }

    pub fn has_buttonTitle(&self) -> bool {
        self.buttonTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buttonTitle(&mut self, v: ::std::string::String) {
        self.buttonTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buttonTitle(&mut self) -> &mut ::std::string::String {
        if self.buttonTitle.is_none() {
            self.buttonTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.buttonTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_buttonTitle(&mut self) -> ::std::string::String {
        self.buttonTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &ActionLink| { &m.url },
            |m: &mut ActionLink| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buttonTitle",
            |m: &ActionLink| { &m.buttonTitle },
            |m: &mut ActionLink| { &mut m.buttonTitle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionLink>(
            "ActionLink",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionLink {
    const NAME: &'static str = "ActionLink";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.buttonTitle = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.buttonTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.buttonTitle.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionLink {
        ActionLink::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.buttonTitle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionLink {
        static instance: ActionLink = ActionLink {
            url: ::std::option::Option::None,
            buttonTitle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionLink {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionLink").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionLink {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DisappearingMode)
pub struct DisappearingMode {
    // message fields
    // @@protoc_insertion_point(field:DisappearingMode.initiator)
    pub initiator: ::std::option::Option<::protobuf::EnumOrUnknown<disappearing_mode::DisappearingModeInitiator>>,
    // special fields
    // @@protoc_insertion_point(special_field:DisappearingMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisappearingMode {
    fn default() -> &'a DisappearingMode {
        <DisappearingMode as ::protobuf::Message>::default_instance()
    }
}

impl DisappearingMode {
    pub fn new() -> DisappearingMode {
        ::std::default::Default::default()
    }

    // optional .DisappearingMode.DisappearingModeInitiator initiator = 1;

    pub fn initiator(&self) -> disappearing_mode::DisappearingModeInitiator {
        match self.initiator {
            Some(e) => e.enum_value_or(disappearing_mode::DisappearingModeInitiator::CHANGED_IN_CHAT),
            None => disappearing_mode::DisappearingModeInitiator::CHANGED_IN_CHAT,
        }
    }

    pub fn clear_initiator(&mut self) {
        self.initiator = ::std::option::Option::None;
    }

    pub fn has_initiator(&self) -> bool {
        self.initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: disappearing_mode::DisappearingModeInitiator) {
        self.initiator = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator",
            |m: &DisappearingMode| { &m.initiator },
            |m: &mut DisappearingMode| { &mut m.initiator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisappearingMode>(
            "DisappearingMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisappearingMode {
    const NAME: &'static str = "DisappearingMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.initiator = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.initiator {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisappearingMode {
        DisappearingMode::new()
    }

    fn clear(&mut self) {
        self.initiator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisappearingMode {
        static instance: DisappearingMode = DisappearingMode {
            initiator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisappearingMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisappearingMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisappearingMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisappearingMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DisappearingMode`
pub mod disappearing_mode {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:DisappearingMode.DisappearingModeInitiator)
    pub enum DisappearingModeInitiator {
        // @@protoc_insertion_point(enum_value:DisappearingMode.DisappearingModeInitiator.CHANGED_IN_CHAT)
        CHANGED_IN_CHAT = 0,
        // @@protoc_insertion_point(enum_value:DisappearingMode.DisappearingModeInitiator.INITIATED_BY_ME)
        INITIATED_BY_ME = 1,
        // @@protoc_insertion_point(enum_value:DisappearingMode.DisappearingModeInitiator.INITIATED_BY_OTHER)
        INITIATED_BY_OTHER = 2,
    }

    impl ::protobuf::Enum for DisappearingModeInitiator {
        const NAME: &'static str = "DisappearingModeInitiator";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DisappearingModeInitiator> {
            match value {
                0 => ::std::option::Option::Some(DisappearingModeInitiator::CHANGED_IN_CHAT),
                1 => ::std::option::Option::Some(DisappearingModeInitiator::INITIATED_BY_ME),
                2 => ::std::option::Option::Some(DisappearingModeInitiator::INITIATED_BY_OTHER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DisappearingModeInitiator] = &[
            DisappearingModeInitiator::CHANGED_IN_CHAT,
            DisappearingModeInitiator::INITIATED_BY_ME,
            DisappearingModeInitiator::INITIATED_BY_OTHER,
        ];
    }

    impl ::protobuf::EnumFull for DisappearingModeInitiator {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DisappearingMode.DisappearingModeInitiator").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DisappearingModeInitiator {
        fn default() -> Self {
            DisappearingModeInitiator::CHANGED_IN_CHAT
        }
    }

    impl DisappearingModeInitiator {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DisappearingModeInitiator>("DisappearingMode.DisappearingModeInitiator")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PBMediaData)
pub struct PBMediaData {
    // message fields
    // @@protoc_insertion_point(field:PBMediaData.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PBMediaData.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:PBMediaData.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PBMediaData.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PBMediaData.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:PBMediaData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PBMediaData {
    fn default() -> &'a PBMediaData {
        <PBMediaData as ::protobuf::Message>::default_instance()
    }
}

impl PBMediaData {
    pub fn new() -> PBMediaData {
        ::std::default::Default::default()
    }

    // optional bytes mediaKey = 1;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 mediaKeyTimestamp = 2;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes fileSha256 = 3;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 4;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 5;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &PBMediaData| { &m.mediaKey },
            |m: &mut PBMediaData| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &PBMediaData| { &m.mediaKeyTimestamp },
            |m: &mut PBMediaData| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &PBMediaData| { &m.fileSha256 },
            |m: &mut PBMediaData| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &PBMediaData| { &m.fileEncSha256 },
            |m: &mut PBMediaData| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &PBMediaData| { &m.directPath },
            |m: &mut PBMediaData| { &mut m.directPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PBMediaData>(
            "PBMediaData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PBMediaData {
    const NAME: &'static str = "PBMediaData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PBMediaData {
        PBMediaData::new()
    }

    fn clear(&mut self) {
        self.mediaKey = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PBMediaData {
        static instance: PBMediaData = PBMediaData {
            mediaKey: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PBMediaData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PBMediaData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PBMediaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PBMediaData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PaymentBackground)
pub struct PaymentBackground {
    // message fields
    // @@protoc_insertion_point(field:PaymentBackground.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:PaymentBackground.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PaymentBackground.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PaymentBackground.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PaymentBackground.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:PaymentBackground.placeholderArgb)
    pub placeholderArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PaymentBackground.textArgb)
    pub textArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PaymentBackground.subtextArgb)
    pub subtextArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PaymentBackground.mediaData)
    pub mediaData: ::protobuf::MessageField<PBMediaData>,
    // @@protoc_insertion_point(field:PaymentBackground.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<payment_background::PaymentBackgroundType>>,
    // special fields
    // @@protoc_insertion_point(special_field:PaymentBackground.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentBackground {
    fn default() -> &'a PaymentBackground {
        <PaymentBackground as ::protobuf::Message>::default_instance()
    }
}

impl PaymentBackground {
    pub fn new() -> PaymentBackground {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileLength = 2;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional string mimetype = 5;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 placeholderArgb = 6;

    pub fn placeholderArgb(&self) -> u32 {
        self.placeholderArgb.unwrap_or(0)
    }

    pub fn clear_placeholderArgb(&mut self) {
        self.placeholderArgb = ::std::option::Option::None;
    }

    pub fn has_placeholderArgb(&self) -> bool {
        self.placeholderArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placeholderArgb(&mut self, v: u32) {
        self.placeholderArgb = ::std::option::Option::Some(v);
    }

    // optional fixed32 textArgb = 7;

    pub fn textArgb(&self) -> u32 {
        self.textArgb.unwrap_or(0)
    }

    pub fn clear_textArgb(&mut self) {
        self.textArgb = ::std::option::Option::None;
    }

    pub fn has_textArgb(&self) -> bool {
        self.textArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textArgb(&mut self, v: u32) {
        self.textArgb = ::std::option::Option::Some(v);
    }

    // optional fixed32 subtextArgb = 8;

    pub fn subtextArgb(&self) -> u32 {
        self.subtextArgb.unwrap_or(0)
    }

    pub fn clear_subtextArgb(&mut self) {
        self.subtextArgb = ::std::option::Option::None;
    }

    pub fn has_subtextArgb(&self) -> bool {
        self.subtextArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subtextArgb(&mut self, v: u32) {
        self.subtextArgb = ::std::option::Option::Some(v);
    }

    // optional .PaymentBackground.PaymentBackgroundType type = 10;

    pub fn type_(&self) -> payment_background::PaymentBackgroundType {
        match self.type_ {
            Some(e) => e.enum_value_or(payment_background::PaymentBackgroundType::UNKNOWN),
            None => payment_background::PaymentBackgroundType::UNKNOWN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: payment_background::PaymentBackgroundType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &PaymentBackground| { &m.id },
            |m: &mut PaymentBackground| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &PaymentBackground| { &m.fileLength },
            |m: &mut PaymentBackground| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &PaymentBackground| { &m.width },
            |m: &mut PaymentBackground| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &PaymentBackground| { &m.height },
            |m: &mut PaymentBackground| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &PaymentBackground| { &m.mimetype },
            |m: &mut PaymentBackground| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "placeholderArgb",
            |m: &PaymentBackground| { &m.placeholderArgb },
            |m: &mut PaymentBackground| { &mut m.placeholderArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "textArgb",
            |m: &PaymentBackground| { &m.textArgb },
            |m: &mut PaymentBackground| { &mut m.textArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subtextArgb",
            |m: &PaymentBackground| { &m.subtextArgb },
            |m: &mut PaymentBackground| { &mut m.subtextArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PBMediaData>(
            "mediaData",
            |m: &PaymentBackground| { &m.mediaData },
            |m: &mut PaymentBackground| { &mut m.mediaData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PaymentBackground| { &m.type_ },
            |m: &mut PaymentBackground| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentBackground>(
            "PaymentBackground",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentBackground {
    const NAME: &'static str = "PaymentBackground";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                53 => {
                    self.placeholderArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.textArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.subtextArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mediaData)?;
                },
                80 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.placeholderArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.textArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.subtextArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mediaData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.placeholderArgb {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.textArgb {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.subtextArgb {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.mediaData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentBackground {
        PaymentBackground::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.placeholderArgb = ::std::option::Option::None;
        self.textArgb = ::std::option::Option::None;
        self.subtextArgb = ::std::option::Option::None;
        self.mediaData.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentBackground {
        static instance: PaymentBackground = PaymentBackground {
            id: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            placeholderArgb: ::std::option::Option::None,
            textArgb: ::std::option::Option::None,
            subtextArgb: ::std::option::Option::None,
            mediaData: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentBackground {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentBackground").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentBackground {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentBackground {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PaymentBackground`
pub mod payment_background {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:PaymentBackground.PaymentBackgroundType)
    pub enum PaymentBackgroundType {
        // @@protoc_insertion_point(enum_value:PaymentBackground.PaymentBackgroundType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:PaymentBackground.PaymentBackgroundType.DEFAULT)
        DEFAULT = 1,
    }

    impl ::protobuf::Enum for PaymentBackgroundType {
        const NAME: &'static str = "PaymentBackgroundType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PaymentBackgroundType> {
            match value {
                0 => ::std::option::Option::Some(PaymentBackgroundType::UNKNOWN),
                1 => ::std::option::Option::Some(PaymentBackgroundType::DEFAULT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PaymentBackgroundType] = &[
            PaymentBackgroundType::UNKNOWN,
            PaymentBackgroundType::DEFAULT,
        ];
    }

    impl ::protobuf::EnumFull for PaymentBackgroundType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentBackground.PaymentBackgroundType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PaymentBackgroundType {
        fn default() -> Self {
            PaymentBackgroundType::UNKNOWN
        }
    }

    impl PaymentBackgroundType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentBackgroundType>("PaymentBackground.PaymentBackgroundType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Money)
pub struct Money {
    // message fields
    // @@protoc_insertion_point(field:Money.value)
    pub value: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:Money.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Money.currencyCode)
    pub currencyCode: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Money.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Money {
    fn default() -> &'a Money {
        <Money as ::protobuf::Message>::default_instance()
    }
}

impl Money {
    pub fn new() -> Money {
        ::std::default::Default::default()
    }

    // optional int64 value = 1;

    pub fn value(&self) -> i64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional string currencyCode = 3;

    pub fn currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currencyCode(&mut self) {
        self.currencyCode = ::std::option::Option::None;
    }

    pub fn has_currencyCode(&self) -> bool {
        self.currencyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyCode(&mut self, v: ::std::string::String) {
        self.currencyCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currencyCode(&mut self) -> &mut ::std::string::String {
        if self.currencyCode.is_none() {
            self.currencyCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currencyCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_currencyCode(&mut self) -> ::std::string::String {
        self.currencyCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &Money| { &m.value },
            |m: &mut Money| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Money| { &m.offset },
            |m: &mut Money| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyCode",
            |m: &Money| { &m.currencyCode },
            |m: &mut Money| { &mut m.currencyCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Money>(
            "Money",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Money {
    const NAME: &'static str = "Money";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.currencyCode = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Money {
        Money::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.currencyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Money {
        static instance: Money = Money {
            value: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            currencyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Money {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Money").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Money {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Money {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HydratedQuickReplyButton)
pub struct HydratedQuickReplyButton {
    // message fields
    // @@protoc_insertion_point(field:HydratedQuickReplyButton.displayText)
    pub displayText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HydratedQuickReplyButton.id)
    pub id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:HydratedQuickReplyButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HydratedQuickReplyButton {
    fn default() -> &'a HydratedQuickReplyButton {
        <HydratedQuickReplyButton as ::protobuf::Message>::default_instance()
    }
}

impl HydratedQuickReplyButton {
    pub fn new() -> HydratedQuickReplyButton {
        ::std::default::Default::default()
    }

    // optional string displayText = 1;

    pub fn displayText(&self) -> &str {
        match self.displayText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayText(&mut self) {
        self.displayText = ::std::option::Option::None;
    }

    pub fn has_displayText(&self) -> bool {
        self.displayText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayText(&mut self, v: ::std::string::String) {
        self.displayText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
        if self.displayText.is_none() {
            self.displayText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayText.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayText(&mut self) -> ::std::string::String {
        self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayText",
            |m: &HydratedQuickReplyButton| { &m.displayText },
            |m: &mut HydratedQuickReplyButton| { &mut m.displayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &HydratedQuickReplyButton| { &m.id },
            |m: &mut HydratedQuickReplyButton| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedQuickReplyButton>(
            "HydratedQuickReplyButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HydratedQuickReplyButton {
    const NAME: &'static str = "HydratedQuickReplyButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayText = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HydratedQuickReplyButton {
        HydratedQuickReplyButton::new()
    }

    fn clear(&mut self) {
        self.displayText = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HydratedQuickReplyButton {
        static instance: HydratedQuickReplyButton = HydratedQuickReplyButton {
            displayText: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HydratedQuickReplyButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HydratedQuickReplyButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HydratedQuickReplyButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HydratedQuickReplyButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HydratedURLButton)
pub struct HydratedURLButton {
    // message fields
    // @@protoc_insertion_point(field:HydratedURLButton.displayText)
    pub displayText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HydratedURLButton.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:HydratedURLButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HydratedURLButton {
    fn default() -> &'a HydratedURLButton {
        <HydratedURLButton as ::protobuf::Message>::default_instance()
    }
}

impl HydratedURLButton {
    pub fn new() -> HydratedURLButton {
        ::std::default::Default::default()
    }

    // optional string displayText = 1;

    pub fn displayText(&self) -> &str {
        match self.displayText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayText(&mut self) {
        self.displayText = ::std::option::Option::None;
    }

    pub fn has_displayText(&self) -> bool {
        self.displayText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayText(&mut self, v: ::std::string::String) {
        self.displayText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
        if self.displayText.is_none() {
            self.displayText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayText.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayText(&mut self) -> ::std::string::String {
        self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayText",
            |m: &HydratedURLButton| { &m.displayText },
            |m: &mut HydratedURLButton| { &mut m.displayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &HydratedURLButton| { &m.url },
            |m: &mut HydratedURLButton| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedURLButton>(
            "HydratedURLButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HydratedURLButton {
    const NAME: &'static str = "HydratedURLButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayText = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HydratedURLButton {
        HydratedURLButton::new()
    }

    fn clear(&mut self) {
        self.displayText = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HydratedURLButton {
        static instance: HydratedURLButton = HydratedURLButton {
            displayText: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HydratedURLButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HydratedURLButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HydratedURLButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HydratedURLButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HydratedCallButton)
pub struct HydratedCallButton {
    // message fields
    // @@protoc_insertion_point(field:HydratedCallButton.displayText)
    pub displayText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:HydratedCallButton.phoneNumber)
    pub phoneNumber: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:HydratedCallButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HydratedCallButton {
    fn default() -> &'a HydratedCallButton {
        <HydratedCallButton as ::protobuf::Message>::default_instance()
    }
}

impl HydratedCallButton {
    pub fn new() -> HydratedCallButton {
        ::std::default::Default::default()
    }

    // optional string displayText = 1;

    pub fn displayText(&self) -> &str {
        match self.displayText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayText(&mut self) {
        self.displayText = ::std::option::Option::None;
    }

    pub fn has_displayText(&self) -> bool {
        self.displayText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayText(&mut self, v: ::std::string::String) {
        self.displayText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
        if self.displayText.is_none() {
            self.displayText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayText.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayText(&mut self) -> ::std::string::String {
        self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string phoneNumber = 2;

    pub fn phoneNumber(&self) -> &str {
        match self.phoneNumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phoneNumber(&mut self) {
        self.phoneNumber = ::std::option::Option::None;
    }

    pub fn has_phoneNumber(&self) -> bool {
        self.phoneNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phoneNumber(&mut self, v: ::std::string::String) {
        self.phoneNumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phoneNumber(&mut self) -> &mut ::std::string::String {
        if self.phoneNumber.is_none() {
            self.phoneNumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phoneNumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_phoneNumber(&mut self) -> ::std::string::String {
        self.phoneNumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayText",
            |m: &HydratedCallButton| { &m.displayText },
            |m: &mut HydratedCallButton| { &mut m.displayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phoneNumber",
            |m: &HydratedCallButton| { &m.phoneNumber },
            |m: &mut HydratedCallButton| { &mut m.phoneNumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedCallButton>(
            "HydratedCallButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HydratedCallButton {
    const NAME: &'static str = "HydratedCallButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayText = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.phoneNumber = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.phoneNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.phoneNumber.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HydratedCallButton {
        HydratedCallButton::new()
    }

    fn clear(&mut self) {
        self.displayText = ::std::option::Option::None;
        self.phoneNumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HydratedCallButton {
        static instance: HydratedCallButton = HydratedCallButton {
            displayText: ::std::option::Option::None,
            phoneNumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HydratedCallButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HydratedCallButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HydratedCallButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HydratedCallButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HydratedTemplateButton)
pub struct HydratedTemplateButton {
    // message fields
    // @@protoc_insertion_point(field:HydratedTemplateButton.index)
    pub index: ::std::option::Option<u32>,
    // message oneof groups
    pub hydratedButton: ::std::option::Option<hydrated_template_button::HydratedButton>,
    // special fields
    // @@protoc_insertion_point(special_field:HydratedTemplateButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HydratedTemplateButton {
    fn default() -> &'a HydratedTemplateButton {
        <HydratedTemplateButton as ::protobuf::Message>::default_instance()
    }
}

impl HydratedTemplateButton {
    pub fn new() -> HydratedTemplateButton {
        ::std::default::Default::default()
    }

    // optional uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional .HydratedQuickReplyButton quickReplyButton = 1;

    pub fn quickReplyButton(&self) -> &HydratedQuickReplyButton {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(ref v)) => v,
            _ => <HydratedQuickReplyButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quickReplyButton(&mut self) {
        self.hydratedButton = ::std::option::Option::None;
    }

    pub fn has_quickReplyButton(&self) -> bool {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quickReplyButton(&mut self, v: HydratedQuickReplyButton) {
        self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quickReplyButton(&mut self) -> &mut HydratedQuickReplyButton {
        if let ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(_)) = self.hydratedButton {
        } else {
            self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(HydratedQuickReplyButton::new()));
        }
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quickReplyButton(&mut self) -> HydratedQuickReplyButton {
        if self.has_quickReplyButton() {
            match self.hydratedButton.take() {
                ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(v)) => v,
                _ => panic!(),
            }
        } else {
            HydratedQuickReplyButton::new()
        }
    }

    // optional .HydratedURLButton urlButton = 2;

    pub fn urlButton(&self) -> &HydratedURLButton {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(ref v)) => v,
            _ => <HydratedURLButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_urlButton(&mut self) {
        self.hydratedButton = ::std::option::Option::None;
    }

    pub fn has_urlButton(&self) -> bool {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_urlButton(&mut self, v: HydratedURLButton) {
        self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_urlButton(&mut self) -> &mut HydratedURLButton {
        if let ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(_)) = self.hydratedButton {
        } else {
            self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(HydratedURLButton::new()));
        }
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_urlButton(&mut self) -> HydratedURLButton {
        if self.has_urlButton() {
            match self.hydratedButton.take() {
                ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(v)) => v,
                _ => panic!(),
            }
        } else {
            HydratedURLButton::new()
        }
    }

    // optional .HydratedCallButton callButton = 3;

    pub fn callButton(&self) -> &HydratedCallButton {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(ref v)) => v,
            _ => <HydratedCallButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_callButton(&mut self) {
        self.hydratedButton = ::std::option::Option::None;
    }

    pub fn has_callButton(&self) -> bool {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_callButton(&mut self, v: HydratedCallButton) {
        self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_callButton(&mut self) -> &mut HydratedCallButton {
        if let ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(_)) = self.hydratedButton {
        } else {
            self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(HydratedCallButton::new()));
        }
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_callButton(&mut self) -> HydratedCallButton {
        if self.has_callButton() {
            match self.hydratedButton.take() {
                ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(v)) => v,
                _ => panic!(),
            }
        } else {
            HydratedCallButton::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &HydratedTemplateButton| { &m.index },
            |m: &mut HydratedTemplateButton| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HydratedQuickReplyButton>(
            "quickReplyButton",
            HydratedTemplateButton::has_quickReplyButton,
            HydratedTemplateButton::quickReplyButton,
            HydratedTemplateButton::mut_quickReplyButton,
            HydratedTemplateButton::set_quickReplyButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HydratedURLButton>(
            "urlButton",
            HydratedTemplateButton::has_urlButton,
            HydratedTemplateButton::urlButton,
            HydratedTemplateButton::mut_urlButton,
            HydratedTemplateButton::set_urlButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HydratedCallButton>(
            "callButton",
            HydratedTemplateButton::has_callButton,
            HydratedTemplateButton::callButton,
            HydratedTemplateButton::mut_callButton,
            HydratedTemplateButton::set_callButton,
        ));
        oneofs.push(hydrated_template_button::HydratedButton::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedTemplateButton>(
            "HydratedTemplateButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HydratedTemplateButton {
    const NAME: &'static str = "HydratedTemplateButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(is.read_message()?));
                },
                18 => {
                    self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(is.read_message()?));
                },
                26 => {
                    self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let ::std::option::Option::Some(ref v) = self.hydratedButton {
            match v {
                &hydrated_template_button::HydratedButton::QuickReplyButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hydrated_template_button::HydratedButton::UrlButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hydrated_template_button::HydratedButton::CallButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.hydratedButton {
            match v {
                &hydrated_template_button::HydratedButton::QuickReplyButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &hydrated_template_button::HydratedButton::UrlButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &hydrated_template_button::HydratedButton::CallButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HydratedTemplateButton {
        HydratedTemplateButton::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.hydratedButton = ::std::option::Option::None;
        self.hydratedButton = ::std::option::Option::None;
        self.hydratedButton = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HydratedTemplateButton {
        static instance: HydratedTemplateButton = HydratedTemplateButton {
            index: ::std::option::Option::None,
            hydratedButton: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HydratedTemplateButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HydratedTemplateButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HydratedTemplateButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HydratedTemplateButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HydratedTemplateButton`
pub mod hydrated_template_button {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:HydratedTemplateButton.hydratedButton)
    pub enum HydratedButton {
        // @@protoc_insertion_point(oneof_field:HydratedTemplateButton.quickReplyButton)
        QuickReplyButton(super::HydratedQuickReplyButton),
        // @@protoc_insertion_point(oneof_field:HydratedTemplateButton.urlButton)
        UrlButton(super::HydratedURLButton),
        // @@protoc_insertion_point(oneof_field:HydratedTemplateButton.callButton)
        CallButton(super::HydratedCallButton),
    }

    impl ::protobuf::Oneof for HydratedButton {
    }

    impl ::protobuf::OneofFull for HydratedButton {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::HydratedTemplateButton as ::protobuf::MessageFull>::descriptor().oneof_by_name("hydratedButton").unwrap()).clone()
        }
    }

    impl HydratedButton {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<HydratedButton>("hydratedButton")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:QuickReplyButton)
pub struct QuickReplyButton {
    // message fields
    // @@protoc_insertion_point(field:QuickReplyButton.displayText)
    pub displayText: ::protobuf::MessageField<HighlyStructuredMessage>,
    // @@protoc_insertion_point(field:QuickReplyButton.id)
    pub id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:QuickReplyButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuickReplyButton {
    fn default() -> &'a QuickReplyButton {
        <QuickReplyButton as ::protobuf::Message>::default_instance()
    }
}

impl QuickReplyButton {
    pub fn new() -> QuickReplyButton {
        ::std::default::Default::default()
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "displayText",
            |m: &QuickReplyButton| { &m.displayText },
            |m: &mut QuickReplyButton| { &mut m.displayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &QuickReplyButton| { &m.id },
            |m: &mut QuickReplyButton| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuickReplyButton>(
            "QuickReplyButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuickReplyButton {
    const NAME: &'static str = "QuickReplyButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuickReplyButton {
        QuickReplyButton::new()
    }

    fn clear(&mut self) {
        self.displayText.clear();
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuickReplyButton {
        static instance: QuickReplyButton = QuickReplyButton {
            displayText: ::protobuf::MessageField::none(),
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuickReplyButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuickReplyButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuickReplyButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuickReplyButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:URLButton)
pub struct URLButton {
    // message fields
    // @@protoc_insertion_point(field:URLButton.displayText)
    pub displayText: ::protobuf::MessageField<HighlyStructuredMessage>,
    // @@protoc_insertion_point(field:URLButton.url)
    pub url: ::protobuf::MessageField<HighlyStructuredMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:URLButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a URLButton {
    fn default() -> &'a URLButton {
        <URLButton as ::protobuf::Message>::default_instance()
    }
}

impl URLButton {
    pub fn new() -> URLButton {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "displayText",
            |m: &URLButton| { &m.displayText },
            |m: &mut URLButton| { &mut m.displayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "url",
            |m: &URLButton| { &m.url },
            |m: &mut URLButton| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<URLButton>(
            "URLButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for URLButton {
    const NAME: &'static str = "URLButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.url)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.url.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> URLButton {
        URLButton::new()
    }

    fn clear(&mut self) {
        self.displayText.clear();
        self.url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static URLButton {
        static instance: URLButton = URLButton {
            displayText: ::protobuf::MessageField::none(),
            url: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for URLButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("URLButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for URLButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for URLButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CallButton)
pub struct CallButton {
    // message fields
    // @@protoc_insertion_point(field:CallButton.displayText)
    pub displayText: ::protobuf::MessageField<HighlyStructuredMessage>,
    // @@protoc_insertion_point(field:CallButton.phoneNumber)
    pub phoneNumber: ::protobuf::MessageField<HighlyStructuredMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CallButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CallButton {
    fn default() -> &'a CallButton {
        <CallButton as ::protobuf::Message>::default_instance()
    }
}

impl CallButton {
    pub fn new() -> CallButton {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "displayText",
            |m: &CallButton| { &m.displayText },
            |m: &mut CallButton| { &mut m.displayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "phoneNumber",
            |m: &CallButton| { &m.phoneNumber },
            |m: &mut CallButton| { &mut m.phoneNumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallButton>(
            "CallButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CallButton {
    const NAME: &'static str = "CallButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.phoneNumber)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayText.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.phoneNumber.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayText.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.phoneNumber.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CallButton {
        CallButton::new()
    }

    fn clear(&mut self) {
        self.displayText.clear();
        self.phoneNumber.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CallButton {
        static instance: CallButton = CallButton {
            displayText: ::protobuf::MessageField::none(),
            phoneNumber: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CallButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CallButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CallButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CallButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TemplateButton)
pub struct TemplateButton {
    // message fields
    // @@protoc_insertion_point(field:TemplateButton.index)
    pub index: ::std::option::Option<u32>,
    // message oneof groups
    pub button: ::std::option::Option<template_button::Button>,
    // special fields
    // @@protoc_insertion_point(special_field:TemplateButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TemplateButton {
    fn default() -> &'a TemplateButton {
        <TemplateButton as ::protobuf::Message>::default_instance()
    }
}

impl TemplateButton {
    pub fn new() -> TemplateButton {
        ::std::default::Default::default()
    }

    // optional uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional .QuickReplyButton quickReplyButton = 1;

    pub fn quickReplyButton(&self) -> &QuickReplyButton {
        match self.button {
            ::std::option::Option::Some(template_button::Button::QuickReplyButton(ref v)) => v,
            _ => <QuickReplyButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quickReplyButton(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_quickReplyButton(&self) -> bool {
        match self.button {
            ::std::option::Option::Some(template_button::Button::QuickReplyButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quickReplyButton(&mut self, v: QuickReplyButton) {
        self.button = ::std::option::Option::Some(template_button::Button::QuickReplyButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quickReplyButton(&mut self) -> &mut QuickReplyButton {
        if let ::std::option::Option::Some(template_button::Button::QuickReplyButton(_)) = self.button {
        } else {
            self.button = ::std::option::Option::Some(template_button::Button::QuickReplyButton(QuickReplyButton::new()));
        }
        match self.button {
            ::std::option::Option::Some(template_button::Button::QuickReplyButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quickReplyButton(&mut self) -> QuickReplyButton {
        if self.has_quickReplyButton() {
            match self.button.take() {
                ::std::option::Option::Some(template_button::Button::QuickReplyButton(v)) => v,
                _ => panic!(),
            }
        } else {
            QuickReplyButton::new()
        }
    }

    // optional .URLButton urlButton = 2;

    pub fn urlButton(&self) -> &URLButton {
        match self.button {
            ::std::option::Option::Some(template_button::Button::UrlButton(ref v)) => v,
            _ => <URLButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_urlButton(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_urlButton(&self) -> bool {
        match self.button {
            ::std::option::Option::Some(template_button::Button::UrlButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_urlButton(&mut self, v: URLButton) {
        self.button = ::std::option::Option::Some(template_button::Button::UrlButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_urlButton(&mut self) -> &mut URLButton {
        if let ::std::option::Option::Some(template_button::Button::UrlButton(_)) = self.button {
        } else {
            self.button = ::std::option::Option::Some(template_button::Button::UrlButton(URLButton::new()));
        }
        match self.button {
            ::std::option::Option::Some(template_button::Button::UrlButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_urlButton(&mut self) -> URLButton {
        if self.has_urlButton() {
            match self.button.take() {
                ::std::option::Option::Some(template_button::Button::UrlButton(v)) => v,
                _ => panic!(),
            }
        } else {
            URLButton::new()
        }
    }

    // optional .CallButton callButton = 3;

    pub fn callButton(&self) -> &CallButton {
        match self.button {
            ::std::option::Option::Some(template_button::Button::CallButton(ref v)) => v,
            _ => <CallButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_callButton(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_callButton(&self) -> bool {
        match self.button {
            ::std::option::Option::Some(template_button::Button::CallButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_callButton(&mut self, v: CallButton) {
        self.button = ::std::option::Option::Some(template_button::Button::CallButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_callButton(&mut self) -> &mut CallButton {
        if let ::std::option::Option::Some(template_button::Button::CallButton(_)) = self.button {
        } else {
            self.button = ::std::option::Option::Some(template_button::Button::CallButton(CallButton::new()));
        }
        match self.button {
            ::std::option::Option::Some(template_button::Button::CallButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_callButton(&mut self) -> CallButton {
        if self.has_callButton() {
            match self.button.take() {
                ::std::option::Option::Some(template_button::Button::CallButton(v)) => v,
                _ => panic!(),
            }
        } else {
            CallButton::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &TemplateButton| { &m.index },
            |m: &mut TemplateButton| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, QuickReplyButton>(
            "quickReplyButton",
            TemplateButton::has_quickReplyButton,
            TemplateButton::quickReplyButton,
            TemplateButton::mut_quickReplyButton,
            TemplateButton::set_quickReplyButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, URLButton>(
            "urlButton",
            TemplateButton::has_urlButton,
            TemplateButton::urlButton,
            TemplateButton::mut_urlButton,
            TemplateButton::set_urlButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CallButton>(
            "callButton",
            TemplateButton::has_callButton,
            TemplateButton::callButton,
            TemplateButton::mut_callButton,
            TemplateButton::set_callButton,
        ));
        oneofs.push(template_button::Button::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TemplateButton>(
            "TemplateButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TemplateButton {
    const NAME: &'static str = "TemplateButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    self.button = ::std::option::Option::Some(template_button::Button::QuickReplyButton(is.read_message()?));
                },
                18 => {
                    self.button = ::std::option::Option::Some(template_button::Button::UrlButton(is.read_message()?));
                },
                26 => {
                    self.button = ::std::option::Option::Some(template_button::Button::CallButton(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let ::std::option::Option::Some(ref v) = self.button {
            match v {
                &template_button::Button::QuickReplyButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &template_button::Button::UrlButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &template_button::Button::CallButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.button {
            match v {
                &template_button::Button::QuickReplyButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &template_button::Button::UrlButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &template_button::Button::CallButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TemplateButton {
        TemplateButton::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TemplateButton {
        static instance: TemplateButton = TemplateButton {
            index: ::std::option::Option::None,
            button: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TemplateButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TemplateButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TemplateButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TemplateButton`
pub mod template_button {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TemplateButton.button)
    pub enum Button {
        // @@protoc_insertion_point(oneof_field:TemplateButton.quickReplyButton)
        QuickReplyButton(super::QuickReplyButton),
        // @@protoc_insertion_point(oneof_field:TemplateButton.urlButton)
        UrlButton(super::URLButton),
        // @@protoc_insertion_point(oneof_field:TemplateButton.callButton)
        CallButton(super::CallButton),
    }

    impl ::protobuf::Oneof for Button {
    }

    impl ::protobuf::OneofFull for Button {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TemplateButton as ::protobuf::MessageFull>::descriptor().oneof_by_name("button").unwrap()).clone()
        }
    }

    impl Button {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Button>("button")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Location)
pub struct Location {
    // message fields
    // @@protoc_insertion_point(field:Location.degreesLatitude)
    pub degreesLatitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:Location.degreesLongitude)
    pub degreesLongitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:Location.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Location.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // optional double degreesLatitude = 1;

    pub fn degreesLatitude(&self) -> f64 {
        self.degreesLatitude.unwrap_or(0.)
    }

    pub fn clear_degreesLatitude(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
    }

    pub fn has_degreesLatitude(&self) -> bool {
        self.degreesLatitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLatitude(&mut self, v: f64) {
        self.degreesLatitude = ::std::option::Option::Some(v);
    }

    // optional double degreesLongitude = 2;

    pub fn degreesLongitude(&self) -> f64 {
        self.degreesLongitude.unwrap_or(0.)
    }

    pub fn clear_degreesLongitude(&mut self) {
        self.degreesLongitude = ::std::option::Option::None;
    }

    pub fn has_degreesLongitude(&self) -> bool {
        self.degreesLongitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLongitude(&mut self, v: f64) {
        self.degreesLongitude = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLatitude",
            |m: &Location| { &m.degreesLatitude },
            |m: &mut Location| { &mut m.degreesLatitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLongitude",
            |m: &Location| { &m.degreesLongitude },
            |m: &mut Location| { &mut m.degreesLongitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Location| { &m.name },
            |m: &mut Location| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
            "Location",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Location {
    const NAME: &'static str = "Location";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.degreesLatitude = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.degreesLongitude = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.degreesLatitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.degreesLongitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.degreesLatitude {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.degreesLongitude {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Location {
        Location::new()
    }

    fn clear(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
        self.degreesLongitude = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Location {
        static instance: Location = Location {
            degreesLatitude: ::std::option::Option::None,
            degreesLongitude: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Location {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Location").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Point)
pub struct Point {
    // message fields
    // @@protoc_insertion_point(field:Point.xDeprecated)
    pub xDeprecated: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Point.yDeprecated)
    pub yDeprecated: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Point.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:Point.y)
    pub y: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:Point.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // optional int32 xDeprecated = 1;

    pub fn xDeprecated(&self) -> i32 {
        self.xDeprecated.unwrap_or(0)
    }

    pub fn clear_xDeprecated(&mut self) {
        self.xDeprecated = ::std::option::Option::None;
    }

    pub fn has_xDeprecated(&self) -> bool {
        self.xDeprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xDeprecated(&mut self, v: i32) {
        self.xDeprecated = ::std::option::Option::Some(v);
    }

    // optional int32 yDeprecated = 2;

    pub fn yDeprecated(&self) -> i32 {
        self.yDeprecated.unwrap_or(0)
    }

    pub fn clear_yDeprecated(&mut self) {
        self.yDeprecated = ::std::option::Option::None;
    }

    pub fn has_yDeprecated(&self) -> bool {
        self.yDeprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yDeprecated(&mut self, v: i32) {
        self.yDeprecated = ::std::option::Option::Some(v);
    }

    // optional double x = 3;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 4;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xDeprecated",
            |m: &Point| { &m.xDeprecated },
            |m: &mut Point| { &mut m.xDeprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "yDeprecated",
            |m: &Point| { &m.yDeprecated },
            |m: &mut Point| { &mut m.yDeprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &Point| { &m.x },
            |m: &mut Point| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &Point| { &m.y },
            |m: &mut Point| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Point>(
            "Point",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Point {
    const NAME: &'static str = "Point";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.xDeprecated = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.yDeprecated = ::std::option::Option::Some(is.read_int32()?);
                },
                25 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.xDeprecated {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.yDeprecated {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.xDeprecated {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.yDeprecated {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point {
        Point::new()
    }

    fn clear(&mut self) {
        self.xDeprecated = ::std::option::Option::None;
        self.yDeprecated = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point {
        static instance: Point = Point {
            xDeprecated: ::std::option::Option::None,
            yDeprecated: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Point {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Point").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CompanionProps)
pub struct CompanionProps {
    // message fields
    // @@protoc_insertion_point(field:CompanionProps.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CompanionProps.version)
    pub version: ::protobuf::MessageField<AppVersion>,
    // @@protoc_insertion_point(field:CompanionProps.platformType)
    pub platformType: ::std::option::Option<::protobuf::EnumOrUnknown<companion_props::CompanionPropsPlatformType>>,
    // @@protoc_insertion_point(field:CompanionProps.requireFullSync)
    pub requireFullSync: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CompanionProps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CompanionProps {
    fn default() -> &'a CompanionProps {
        <CompanionProps as ::protobuf::Message>::default_instance()
    }
}

impl CompanionProps {
    pub fn new() -> CompanionProps {
        ::std::default::Default::default()
    }

    // optional string os = 1;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CompanionProps.CompanionPropsPlatformType platformType = 3;

    pub fn platformType(&self) -> companion_props::CompanionPropsPlatformType {
        match self.platformType {
            Some(e) => e.enum_value_or(companion_props::CompanionPropsPlatformType::UNKNOWN),
            None => companion_props::CompanionPropsPlatformType::UNKNOWN,
        }
    }

    pub fn clear_platformType(&mut self) {
        self.platformType = ::std::option::Option::None;
    }

    pub fn has_platformType(&self) -> bool {
        self.platformType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platformType(&mut self, v: companion_props::CompanionPropsPlatformType) {
        self.platformType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool requireFullSync = 4;

    pub fn requireFullSync(&self) -> bool {
        self.requireFullSync.unwrap_or(false)
    }

    pub fn clear_requireFullSync(&mut self) {
        self.requireFullSync = ::std::option::Option::None;
    }

    pub fn has_requireFullSync(&self) -> bool {
        self.requireFullSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requireFullSync(&mut self, v: bool) {
        self.requireFullSync = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &CompanionProps| { &m.os },
            |m: &mut CompanionProps| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppVersion>(
            "version",
            |m: &CompanionProps| { &m.version },
            |m: &mut CompanionProps| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platformType",
            |m: &CompanionProps| { &m.platformType },
            |m: &mut CompanionProps| { &mut m.platformType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requireFullSync",
            |m: &CompanionProps| { &m.requireFullSync },
            |m: &mut CompanionProps| { &mut m.requireFullSync },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompanionProps>(
            "CompanionProps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CompanionProps {
    const NAME: &'static str = "CompanionProps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                24 => {
                    self.platformType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.requireFullSync = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.platformType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.requireFullSync {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.os.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.platformType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.requireFullSync {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CompanionProps {
        CompanionProps::new()
    }

    fn clear(&mut self) {
        self.os = ::std::option::Option::None;
        self.version.clear();
        self.platformType = ::std::option::Option::None;
        self.requireFullSync = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CompanionProps {
        static instance: CompanionProps = CompanionProps {
            os: ::std::option::Option::None,
            version: ::protobuf::MessageField::none(),
            platformType: ::std::option::Option::None,
            requireFullSync: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CompanionProps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CompanionProps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CompanionProps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompanionProps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CompanionProps`
pub mod companion_props {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CompanionProps.CompanionPropsPlatformType)
    pub enum CompanionPropsPlatformType {
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.CHROME)
        CHROME = 1,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.FIREFOX)
        FIREFOX = 2,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.IE)
        IE = 3,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.OPERA)
        OPERA = 4,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.SAFARI)
        SAFARI = 5,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.EDGE)
        EDGE = 6,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.DESKTOP)
        DESKTOP = 7,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.IPAD)
        IPAD = 8,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.ANDROID_TABLET)
        ANDROID_TABLET = 9,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.OHANA)
        OHANA = 10,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.ALOHA)
        ALOHA = 11,
        // @@protoc_insertion_point(enum_value:CompanionProps.CompanionPropsPlatformType.CATALINA)
        CATALINA = 12,
    }

    impl ::protobuf::Enum for CompanionPropsPlatformType {
        const NAME: &'static str = "CompanionPropsPlatformType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CompanionPropsPlatformType> {
            match value {
                0 => ::std::option::Option::Some(CompanionPropsPlatformType::UNKNOWN),
                1 => ::std::option::Option::Some(CompanionPropsPlatformType::CHROME),
                2 => ::std::option::Option::Some(CompanionPropsPlatformType::FIREFOX),
                3 => ::std::option::Option::Some(CompanionPropsPlatformType::IE),
                4 => ::std::option::Option::Some(CompanionPropsPlatformType::OPERA),
                5 => ::std::option::Option::Some(CompanionPropsPlatformType::SAFARI),
                6 => ::std::option::Option::Some(CompanionPropsPlatformType::EDGE),
                7 => ::std::option::Option::Some(CompanionPropsPlatformType::DESKTOP),
                8 => ::std::option::Option::Some(CompanionPropsPlatformType::IPAD),
                9 => ::std::option::Option::Some(CompanionPropsPlatformType::ANDROID_TABLET),
                10 => ::std::option::Option::Some(CompanionPropsPlatformType::OHANA),
                11 => ::std::option::Option::Some(CompanionPropsPlatformType::ALOHA),
                12 => ::std::option::Option::Some(CompanionPropsPlatformType::CATALINA),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CompanionPropsPlatformType] = &[
            CompanionPropsPlatformType::UNKNOWN,
            CompanionPropsPlatformType::CHROME,
            CompanionPropsPlatformType::FIREFOX,
            CompanionPropsPlatformType::IE,
            CompanionPropsPlatformType::OPERA,
            CompanionPropsPlatformType::SAFARI,
            CompanionPropsPlatformType::EDGE,
            CompanionPropsPlatformType::DESKTOP,
            CompanionPropsPlatformType::IPAD,
            CompanionPropsPlatformType::ANDROID_TABLET,
            CompanionPropsPlatformType::OHANA,
            CompanionPropsPlatformType::ALOHA,
            CompanionPropsPlatformType::CATALINA,
        ];
    }

    impl ::protobuf::EnumFull for CompanionPropsPlatformType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CompanionProps.CompanionPropsPlatformType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CompanionPropsPlatformType {
        fn default() -> Self {
            CompanionPropsPlatformType::UNKNOWN
        }
    }

    impl CompanionPropsPlatformType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CompanionPropsPlatformType>("CompanionProps.CompanionPropsPlatformType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ADVSignedDeviceIdentityHMAC)
pub struct ADVSignedDeviceIdentityHMAC {
    // message fields
    // @@protoc_insertion_point(field:ADVSignedDeviceIdentityHMAC.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ADVSignedDeviceIdentityHMAC.hmac)
    pub hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ADVSignedDeviceIdentityHMAC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVSignedDeviceIdentityHMAC {
    fn default() -> &'a ADVSignedDeviceIdentityHMAC {
        <ADVSignedDeviceIdentityHMAC as ::protobuf::Message>::default_instance()
    }
}

impl ADVSignedDeviceIdentityHMAC {
    pub fn new() -> ADVSignedDeviceIdentityHMAC {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes hmac = 2;

    pub fn hmac(&self) -> &[u8] {
        match self.hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hmac(&mut self) {
        self.hmac = ::std::option::Option::None;
    }

    pub fn has_hmac(&self) -> bool {
        self.hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hmac.is_none() {
            self.hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &ADVSignedDeviceIdentityHMAC| { &m.details },
            |m: &mut ADVSignedDeviceIdentityHMAC| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hmac",
            |m: &ADVSignedDeviceIdentityHMAC| { &m.hmac },
            |m: &mut ADVSignedDeviceIdentityHMAC| { &mut m.hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVSignedDeviceIdentityHMAC>(
            "ADVSignedDeviceIdentityHMAC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVSignedDeviceIdentityHMAC {
    const NAME: &'static str = "ADVSignedDeviceIdentityHMAC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVSignedDeviceIdentityHMAC {
        ADVSignedDeviceIdentityHMAC::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.hmac = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVSignedDeviceIdentityHMAC {
        static instance: ADVSignedDeviceIdentityHMAC = ADVSignedDeviceIdentityHMAC {
            details: ::std::option::Option::None,
            hmac: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVSignedDeviceIdentityHMAC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVSignedDeviceIdentityHMAC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVSignedDeviceIdentityHMAC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVSignedDeviceIdentityHMAC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ADVSignedDeviceIdentity)
pub struct ADVSignedDeviceIdentity {
    // message fields
    // @@protoc_insertion_point(field:ADVSignedDeviceIdentity.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ADVSignedDeviceIdentity.accountSignatureKey)
    pub accountSignatureKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ADVSignedDeviceIdentity.accountSignature)
    pub accountSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ADVSignedDeviceIdentity.deviceSignature)
    pub deviceSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ADVSignedDeviceIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVSignedDeviceIdentity {
    fn default() -> &'a ADVSignedDeviceIdentity {
        <ADVSignedDeviceIdentity as ::protobuf::Message>::default_instance()
    }
}

impl ADVSignedDeviceIdentity {
    pub fn new() -> ADVSignedDeviceIdentity {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes accountSignatureKey = 2;

    pub fn accountSignatureKey(&self) -> &[u8] {
        match self.accountSignatureKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_accountSignatureKey(&mut self) {
        self.accountSignatureKey = ::std::option::Option::None;
    }

    pub fn has_accountSignatureKey(&self) -> bool {
        self.accountSignatureKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountSignatureKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountSignatureKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountSignatureKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.accountSignatureKey.is_none() {
            self.accountSignatureKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.accountSignatureKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountSignatureKey(&mut self) -> ::std::vec::Vec<u8> {
        self.accountSignatureKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes accountSignature = 3;

    pub fn accountSignature(&self) -> &[u8] {
        match self.accountSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_accountSignature(&mut self) {
        self.accountSignature = ::std::option::Option::None;
    }

    pub fn has_accountSignature(&self) -> bool {
        self.accountSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.accountSignature.is_none() {
            self.accountSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.accountSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.accountSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes deviceSignature = 4;

    pub fn deviceSignature(&self) -> &[u8] {
        match self.deviceSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_deviceSignature(&mut self) {
        self.deviceSignature = ::std::option::Option::None;
    }

    pub fn has_deviceSignature(&self) -> bool {
        self.deviceSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.deviceSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.deviceSignature.is_none() {
            self.deviceSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.deviceSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.deviceSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &ADVSignedDeviceIdentity| { &m.details },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountSignatureKey",
            |m: &ADVSignedDeviceIdentity| { &m.accountSignatureKey },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.accountSignatureKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountSignature",
            |m: &ADVSignedDeviceIdentity| { &m.accountSignature },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.accountSignature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceSignature",
            |m: &ADVSignedDeviceIdentity| { &m.deviceSignature },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.deviceSignature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVSignedDeviceIdentity>(
            "ADVSignedDeviceIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVSignedDeviceIdentity {
    const NAME: &'static str = "ADVSignedDeviceIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.accountSignatureKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.accountSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.deviceSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.accountSignatureKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.accountSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.deviceSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.accountSignatureKey.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.accountSignature.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.deviceSignature.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVSignedDeviceIdentity {
        ADVSignedDeviceIdentity::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.accountSignatureKey = ::std::option::Option::None;
        self.accountSignature = ::std::option::Option::None;
        self.deviceSignature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVSignedDeviceIdentity {
        static instance: ADVSignedDeviceIdentity = ADVSignedDeviceIdentity {
            details: ::std::option::Option::None,
            accountSignatureKey: ::std::option::Option::None,
            accountSignature: ::std::option::Option::None,
            deviceSignature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVSignedDeviceIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVSignedDeviceIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVSignedDeviceIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVSignedDeviceIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ADVDeviceIdentity)
pub struct ADVDeviceIdentity {
    // message fields
    // @@protoc_insertion_point(field:ADVDeviceIdentity.rawId)
    pub rawId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ADVDeviceIdentity.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ADVDeviceIdentity.keyIndex)
    pub keyIndex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ADVDeviceIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVDeviceIdentity {
    fn default() -> &'a ADVDeviceIdentity {
        <ADVDeviceIdentity as ::protobuf::Message>::default_instance()
    }
}

impl ADVDeviceIdentity {
    pub fn new() -> ADVDeviceIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 rawId = 1;

    pub fn rawId(&self) -> u32 {
        self.rawId.unwrap_or(0)
    }

    pub fn clear_rawId(&mut self) {
        self.rawId = ::std::option::Option::None;
    }

    pub fn has_rawId(&self) -> bool {
        self.rawId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawId(&mut self, v: u32) {
        self.rawId = ::std::option::Option::Some(v);
    }

    // optional uint64 timestamp = 2;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 keyIndex = 3;

    pub fn keyIndex(&self) -> u32 {
        self.keyIndex.unwrap_or(0)
    }

    pub fn clear_keyIndex(&mut self) {
        self.keyIndex = ::std::option::Option::None;
    }

    pub fn has_keyIndex(&self) -> bool {
        self.keyIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyIndex(&mut self, v: u32) {
        self.keyIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rawId",
            |m: &ADVDeviceIdentity| { &m.rawId },
            |m: &mut ADVDeviceIdentity| { &mut m.rawId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ADVDeviceIdentity| { &m.timestamp },
            |m: &mut ADVDeviceIdentity| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyIndex",
            |m: &ADVDeviceIdentity| { &m.keyIndex },
            |m: &mut ADVDeviceIdentity| { &mut m.keyIndex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVDeviceIdentity>(
            "ADVDeviceIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVDeviceIdentity {
    const NAME: &'static str = "ADVDeviceIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rawId = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.keyIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rawId {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.keyIndex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rawId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.keyIndex {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVDeviceIdentity {
        ADVDeviceIdentity::new()
    }

    fn clear(&mut self) {
        self.rawId = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.keyIndex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVDeviceIdentity {
        static instance: ADVDeviceIdentity = ADVDeviceIdentity {
            rawId: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            keyIndex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVDeviceIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVDeviceIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVDeviceIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVDeviceIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ADVSignedKeyIndexList)
pub struct ADVSignedKeyIndexList {
    // message fields
    // @@protoc_insertion_point(field:ADVSignedKeyIndexList.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:ADVSignedKeyIndexList.accountSignature)
    pub accountSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:ADVSignedKeyIndexList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVSignedKeyIndexList {
    fn default() -> &'a ADVSignedKeyIndexList {
        <ADVSignedKeyIndexList as ::protobuf::Message>::default_instance()
    }
}

impl ADVSignedKeyIndexList {
    pub fn new() -> ADVSignedKeyIndexList {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes accountSignature = 2;

    pub fn accountSignature(&self) -> &[u8] {
        match self.accountSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_accountSignature(&mut self) {
        self.accountSignature = ::std::option::Option::None;
    }

    pub fn has_accountSignature(&self) -> bool {
        self.accountSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.accountSignature.is_none() {
            self.accountSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.accountSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.accountSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &ADVSignedKeyIndexList| { &m.details },
            |m: &mut ADVSignedKeyIndexList| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountSignature",
            |m: &ADVSignedKeyIndexList| { &m.accountSignature },
            |m: &mut ADVSignedKeyIndexList| { &mut m.accountSignature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVSignedKeyIndexList>(
            "ADVSignedKeyIndexList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVSignedKeyIndexList {
    const NAME: &'static str = "ADVSignedKeyIndexList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.accountSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.accountSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.accountSignature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVSignedKeyIndexList {
        ADVSignedKeyIndexList::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.accountSignature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVSignedKeyIndexList {
        static instance: ADVSignedKeyIndexList = ADVSignedKeyIndexList {
            details: ::std::option::Option::None,
            accountSignature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVSignedKeyIndexList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVSignedKeyIndexList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVSignedKeyIndexList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVSignedKeyIndexList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ADVKeyIndexList)
pub struct ADVKeyIndexList {
    // message fields
    // @@protoc_insertion_point(field:ADVKeyIndexList.rawId)
    pub rawId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ADVKeyIndexList.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ADVKeyIndexList.currentIndex)
    pub currentIndex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ADVKeyIndexList.validIndexes)
    pub validIndexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ADVKeyIndexList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVKeyIndexList {
    fn default() -> &'a ADVKeyIndexList {
        <ADVKeyIndexList as ::protobuf::Message>::default_instance()
    }
}

impl ADVKeyIndexList {
    pub fn new() -> ADVKeyIndexList {
        ::std::default::Default::default()
    }

    // optional uint32 rawId = 1;

    pub fn rawId(&self) -> u32 {
        self.rawId.unwrap_or(0)
    }

    pub fn clear_rawId(&mut self) {
        self.rawId = ::std::option::Option::None;
    }

    pub fn has_rawId(&self) -> bool {
        self.rawId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawId(&mut self, v: u32) {
        self.rawId = ::std::option::Option::Some(v);
    }

    // optional uint64 timestamp = 2;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 currentIndex = 3;

    pub fn currentIndex(&self) -> u32 {
        self.currentIndex.unwrap_or(0)
    }

    pub fn clear_currentIndex(&mut self) {
        self.currentIndex = ::std::option::Option::None;
    }

    pub fn has_currentIndex(&self) -> bool {
        self.currentIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentIndex(&mut self, v: u32) {
        self.currentIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rawId",
            |m: &ADVKeyIndexList| { &m.rawId },
            |m: &mut ADVKeyIndexList| { &mut m.rawId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ADVKeyIndexList| { &m.timestamp },
            |m: &mut ADVKeyIndexList| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentIndex",
            |m: &ADVKeyIndexList| { &m.currentIndex },
            |m: &mut ADVKeyIndexList| { &mut m.currentIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validIndexes",
            |m: &ADVKeyIndexList| { &m.validIndexes },
            |m: &mut ADVKeyIndexList| { &mut m.validIndexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVKeyIndexList>(
            "ADVKeyIndexList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVKeyIndexList {
    const NAME: &'static str = "ADVKeyIndexList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rawId = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.currentIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.validIndexes)?;
                },
                32 => {
                    self.validIndexes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rawId {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.currentIndex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(4, &self.validIndexes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rawId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.currentIndex {
            os.write_uint32(3, v)?;
        }
        os.write_repeated_packed_uint32(4, &self.validIndexes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVKeyIndexList {
        ADVKeyIndexList::new()
    }

    fn clear(&mut self) {
        self.rawId = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.currentIndex = ::std::option::Option::None;
        self.validIndexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVKeyIndexList {
        static instance: ADVKeyIndexList = ADVKeyIndexList {
            rawId: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            currentIndex: ::std::option::Option::None,
            validIndexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVKeyIndexList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVKeyIndexList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVKeyIndexList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVKeyIndexList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MessageKey)
pub struct MessageKey {
    // message fields
    // @@protoc_insertion_point(field:MessageKey.remoteJid)
    pub remoteJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MessageKey.fromMe)
    pub fromMe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MessageKey.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MessageKey.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MessageKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageKey {
    fn default() -> &'a MessageKey {
        <MessageKey as ::protobuf::Message>::default_instance()
    }
}

impl MessageKey {
    pub fn new() -> MessageKey {
        ::std::default::Default::default()
    }

    // optional string remoteJid = 1;

    pub fn remoteJid(&self) -> &str {
        match self.remoteJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remoteJid(&mut self) {
        self.remoteJid = ::std::option::Option::None;
    }

    pub fn has_remoteJid(&self) -> bool {
        self.remoteJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteJid(&mut self, v: ::std::string::String) {
        self.remoteJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteJid(&mut self) -> &mut ::std::string::String {
        if self.remoteJid.is_none() {
            self.remoteJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remoteJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_remoteJid(&mut self) -> ::std::string::String {
        self.remoteJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool fromMe = 2;

    pub fn fromMe(&self) -> bool {
        self.fromMe.unwrap_or(false)
    }

    pub fn clear_fromMe(&mut self) {
        self.fromMe = ::std::option::Option::None;
    }

    pub fn has_fromMe(&self) -> bool {
        self.fromMe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromMe(&mut self, v: bool) {
        self.fromMe = ::std::option::Option::Some(v);
    }

    // optional string id = 3;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string participant = 4;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remoteJid",
            |m: &MessageKey| { &m.remoteJid },
            |m: &mut MessageKey| { &mut m.remoteJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromMe",
            |m: &MessageKey| { &m.fromMe },
            |m: &mut MessageKey| { &mut m.fromMe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &MessageKey| { &m.id },
            |m: &mut MessageKey| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &MessageKey| { &m.participant },
            |m: &mut MessageKey| { &mut m.participant },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageKey>(
            "MessageKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageKey {
    const NAME: &'static str = "MessageKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.remoteJid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.fromMe = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.remoteJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fromMe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.remoteJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fromMe {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageKey {
        MessageKey::new()
    }

    fn clear(&mut self) {
        self.remoteJid = ::std::option::Option::None;
        self.fromMe = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageKey {
        static instance: MessageKey = MessageKey {
            remoteJid: ::std::option::Option::None,
            fromMe: ::std::option::Option::None,
            id: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Reaction)
pub struct Reaction {
    // message fields
    // @@protoc_insertion_point(field:Reaction.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:Reaction.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Reaction.groupingKey)
    pub groupingKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Reaction.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:Reaction.unread)
    pub unread: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:Reaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Reaction {
    fn default() -> &'a Reaction {
        <Reaction as ::protobuf::Message>::default_instance()
    }
}

impl Reaction {
    pub fn new() -> Reaction {
        ::std::default::Default::default()
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupingKey = 3;

    pub fn groupingKey(&self) -> &str {
        match self.groupingKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupingKey(&mut self) {
        self.groupingKey = ::std::option::Option::None;
    }

    pub fn has_groupingKey(&self) -> bool {
        self.groupingKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupingKey(&mut self, v: ::std::string::String) {
        self.groupingKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupingKey(&mut self) -> &mut ::std::string::String {
        if self.groupingKey.is_none() {
            self.groupingKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupingKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupingKey(&mut self) -> ::std::string::String {
        self.groupingKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 senderTimestampMs = 4;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    // optional bool unread = 5;

    pub fn unread(&self) -> bool {
        self.unread.unwrap_or(false)
    }

    pub fn clear_unread(&mut self) {
        self.unread = ::std::option::Option::None;
    }

    pub fn has_unread(&self) -> bool {
        self.unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread(&mut self, v: bool) {
        self.unread = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &Reaction| { &m.key },
            |m: &mut Reaction| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &Reaction| { &m.text },
            |m: &mut Reaction| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupingKey",
            |m: &Reaction| { &m.groupingKey },
            |m: &mut Reaction| { &mut m.groupingKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &Reaction| { &m.senderTimestampMs },
            |m: &mut Reaction| { &mut m.senderTimestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unread",
            |m: &Reaction| { &m.unread },
            |m: &mut Reaction| { &mut m.unread },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Reaction>(
            "Reaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Reaction {
    const NAME: &'static str = "Reaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.groupingKey = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.unread = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.groupingKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.unread {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.groupingKey.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.unread {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Reaction {
        Reaction::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.text = ::std::option::Option::None;
        self.groupingKey = ::std::option::Option::None;
        self.senderTimestampMs = ::std::option::Option::None;
        self.unread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Reaction {
        static instance: Reaction = Reaction {
            key: ::protobuf::MessageField::none(),
            text: ::std::option::Option::None,
            groupingKey: ::std::option::Option::None,
            senderTimestampMs: ::std::option::Option::None,
            unread: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Reaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Reaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Reaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UserReceipt)
pub struct UserReceipt {
    // message fields
    // @@protoc_insertion_point(field:UserReceipt.userJid)
    pub userJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:UserReceipt.receiptTimestamp)
    pub receiptTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:UserReceipt.readTimestamp)
    pub readTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:UserReceipt.playedTimestamp)
    pub playedTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:UserReceipt.pendingDeviceJid)
    pub pendingDeviceJid: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:UserReceipt.deliveredDeviceJid)
    pub deliveredDeviceJid: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:UserReceipt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserReceipt {
    fn default() -> &'a UserReceipt {
        <UserReceipt as ::protobuf::Message>::default_instance()
    }
}

impl UserReceipt {
    pub fn new() -> UserReceipt {
        ::std::default::Default::default()
    }

    // required string userJid = 1;

    pub fn userJid(&self) -> &str {
        match self.userJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_userJid(&mut self) {
        self.userJid = ::std::option::Option::None;
    }

    pub fn has_userJid(&self) -> bool {
        self.userJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userJid(&mut self, v: ::std::string::String) {
        self.userJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userJid(&mut self) -> &mut ::std::string::String {
        if self.userJid.is_none() {
            self.userJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.userJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_userJid(&mut self) -> ::std::string::String {
        self.userJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 receiptTimestamp = 2;

    pub fn receiptTimestamp(&self) -> i64 {
        self.receiptTimestamp.unwrap_or(0)
    }

    pub fn clear_receiptTimestamp(&mut self) {
        self.receiptTimestamp = ::std::option::Option::None;
    }

    pub fn has_receiptTimestamp(&self) -> bool {
        self.receiptTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiptTimestamp(&mut self, v: i64) {
        self.receiptTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 readTimestamp = 3;

    pub fn readTimestamp(&self) -> i64 {
        self.readTimestamp.unwrap_or(0)
    }

    pub fn clear_readTimestamp(&mut self) {
        self.readTimestamp = ::std::option::Option::None;
    }

    pub fn has_readTimestamp(&self) -> bool {
        self.readTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readTimestamp(&mut self, v: i64) {
        self.readTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 playedTimestamp = 4;

    pub fn playedTimestamp(&self) -> i64 {
        self.playedTimestamp.unwrap_or(0)
    }

    pub fn clear_playedTimestamp(&mut self) {
        self.playedTimestamp = ::std::option::Option::None;
    }

    pub fn has_playedTimestamp(&self) -> bool {
        self.playedTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playedTimestamp(&mut self, v: i64) {
        self.playedTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userJid",
            |m: &UserReceipt| { &m.userJid },
            |m: &mut UserReceipt| { &mut m.userJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiptTimestamp",
            |m: &UserReceipt| { &m.receiptTimestamp },
            |m: &mut UserReceipt| { &mut m.receiptTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readTimestamp",
            |m: &UserReceipt| { &m.readTimestamp },
            |m: &mut UserReceipt| { &mut m.readTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playedTimestamp",
            |m: &UserReceipt| { &m.playedTimestamp },
            |m: &mut UserReceipt| { &mut m.playedTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pendingDeviceJid",
            |m: &UserReceipt| { &m.pendingDeviceJid },
            |m: &mut UserReceipt| { &mut m.pendingDeviceJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deliveredDeviceJid",
            |m: &UserReceipt| { &m.deliveredDeviceJid },
            |m: &mut UserReceipt| { &mut m.deliveredDeviceJid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserReceipt>(
            "UserReceipt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserReceipt {
    const NAME: &'static str = "UserReceipt";

    fn is_initialized(&self) -> bool {
        if self.userJid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.userJid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.receiptTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.readTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.playedTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.pendingDeviceJid.push(is.read_string()?);
                },
                50 => {
                    self.deliveredDeviceJid.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.userJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.receiptTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.readTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.playedTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        for value in &self.pendingDeviceJid {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.deliveredDeviceJid {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.userJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.receiptTimestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.readTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.playedTimestamp {
            os.write_int64(4, v)?;
        }
        for v in &self.pendingDeviceJid {
            os.write_string(5, &v)?;
        };
        for v in &self.deliveredDeviceJid {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserReceipt {
        UserReceipt::new()
    }

    fn clear(&mut self) {
        self.userJid = ::std::option::Option::None;
        self.receiptTimestamp = ::std::option::Option::None;
        self.readTimestamp = ::std::option::Option::None;
        self.playedTimestamp = ::std::option::Option::None;
        self.pendingDeviceJid.clear();
        self.deliveredDeviceJid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserReceipt {
        static instance: UserReceipt = UserReceipt {
            userJid: ::std::option::Option::None,
            receiptTimestamp: ::std::option::Option::None,
            readTimestamp: ::std::option::Option::None,
            playedTimestamp: ::std::option::Option::None,
            pendingDeviceJid: ::std::vec::Vec::new(),
            deliveredDeviceJid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserReceipt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserReceipt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserReceipt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:StatusPSA)
pub struct StatusPSA {
    // message fields
    // @@protoc_insertion_point(field:StatusPSA.campaignId)
    pub campaignId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StatusPSA.campaignExpirationTimestamp)
    pub campaignExpirationTimestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:StatusPSA.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusPSA {
    fn default() -> &'a StatusPSA {
        <StatusPSA as ::protobuf::Message>::default_instance()
    }
}

impl StatusPSA {
    pub fn new() -> StatusPSA {
        ::std::default::Default::default()
    }

    // required string campaignId = 44;

    pub fn campaignId(&self) -> &str {
        match self.campaignId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_campaignId(&mut self) {
        self.campaignId = ::std::option::Option::None;
    }

    pub fn has_campaignId(&self) -> bool {
        self.campaignId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaignId(&mut self, v: ::std::string::String) {
        self.campaignId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_campaignId(&mut self) -> &mut ::std::string::String {
        if self.campaignId.is_none() {
            self.campaignId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.campaignId.as_mut().unwrap()
    }

    // Take field
    pub fn take_campaignId(&mut self) -> ::std::string::String {
        self.campaignId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 campaignExpirationTimestamp = 45;

    pub fn campaignExpirationTimestamp(&self) -> u64 {
        self.campaignExpirationTimestamp.unwrap_or(0)
    }

    pub fn clear_campaignExpirationTimestamp(&mut self) {
        self.campaignExpirationTimestamp = ::std::option::Option::None;
    }

    pub fn has_campaignExpirationTimestamp(&self) -> bool {
        self.campaignExpirationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaignExpirationTimestamp(&mut self, v: u64) {
        self.campaignExpirationTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "campaignId",
            |m: &StatusPSA| { &m.campaignId },
            |m: &mut StatusPSA| { &mut m.campaignId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "campaignExpirationTimestamp",
            |m: &StatusPSA| { &m.campaignExpirationTimestamp },
            |m: &mut StatusPSA| { &mut m.campaignExpirationTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusPSA>(
            "StatusPSA",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusPSA {
    const NAME: &'static str = "StatusPSA";

    fn is_initialized(&self) -> bool {
        if self.campaignId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                354 => {
                    self.campaignId = ::std::option::Option::Some(is.read_string()?);
                },
                360 => {
                    self.campaignExpirationTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.campaignId.as_ref() {
            my_size += ::protobuf::rt::string_size(44, &v);
        }
        if let Some(v) = self.campaignExpirationTimestamp {
            my_size += ::protobuf::rt::uint64_size(45, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.campaignId.as_ref() {
            os.write_string(44, v)?;
        }
        if let Some(v) = self.campaignExpirationTimestamp {
            os.write_uint64(45, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusPSA {
        StatusPSA::new()
    }

    fn clear(&mut self) {
        self.campaignId = ::std::option::Option::None;
        self.campaignExpirationTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusPSA {
        static instance: StatusPSA = StatusPSA {
            campaignId: ::std::option::Option::None,
            campaignExpirationTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusPSA {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusPSA").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusPSA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusPSA {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PhotoChange)
pub struct PhotoChange {
    // message fields
    // @@protoc_insertion_point(field:PhotoChange.oldPhoto)
    pub oldPhoto: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PhotoChange.newPhoto)
    pub newPhoto: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PhotoChange.newPhotoId)
    pub newPhotoId: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PhotoChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhotoChange {
    fn default() -> &'a PhotoChange {
        <PhotoChange as ::protobuf::Message>::default_instance()
    }
}

impl PhotoChange {
    pub fn new() -> PhotoChange {
        ::std::default::Default::default()
    }

    // optional bytes oldPhoto = 1;

    pub fn oldPhoto(&self) -> &[u8] {
        match self.oldPhoto.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_oldPhoto(&mut self) {
        self.oldPhoto = ::std::option::Option::None;
    }

    pub fn has_oldPhoto(&self) -> bool {
        self.oldPhoto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldPhoto(&mut self, v: ::std::vec::Vec<u8>) {
        self.oldPhoto = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldPhoto(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.oldPhoto.is_none() {
            self.oldPhoto = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.oldPhoto.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldPhoto(&mut self) -> ::std::vec::Vec<u8> {
        self.oldPhoto.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes newPhoto = 2;

    pub fn newPhoto(&self) -> &[u8] {
        match self.newPhoto.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_newPhoto(&mut self) {
        self.newPhoto = ::std::option::Option::None;
    }

    pub fn has_newPhoto(&self) -> bool {
        self.newPhoto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newPhoto(&mut self, v: ::std::vec::Vec<u8>) {
        self.newPhoto = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newPhoto(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.newPhoto.is_none() {
            self.newPhoto = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.newPhoto.as_mut().unwrap()
    }

    // Take field
    pub fn take_newPhoto(&mut self) -> ::std::vec::Vec<u8> {
        self.newPhoto.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 newPhotoId = 3;

    pub fn newPhotoId(&self) -> u32 {
        self.newPhotoId.unwrap_or(0)
    }

    pub fn clear_newPhotoId(&mut self) {
        self.newPhotoId = ::std::option::Option::None;
    }

    pub fn has_newPhotoId(&self) -> bool {
        self.newPhotoId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newPhotoId(&mut self, v: u32) {
        self.newPhotoId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oldPhoto",
            |m: &PhotoChange| { &m.oldPhoto },
            |m: &mut PhotoChange| { &mut m.oldPhoto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "newPhoto",
            |m: &PhotoChange| { &m.newPhoto },
            |m: &mut PhotoChange| { &mut m.newPhoto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "newPhotoId",
            |m: &PhotoChange| { &m.newPhotoId },
            |m: &mut PhotoChange| { &mut m.newPhotoId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhotoChange>(
            "PhotoChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhotoChange {
    const NAME: &'static str = "PhotoChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.oldPhoto = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.newPhoto = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.newPhotoId = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.oldPhoto.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.newPhoto.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.newPhotoId {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.oldPhoto.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.newPhoto.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.newPhotoId {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhotoChange {
        PhotoChange::new()
    }

    fn clear(&mut self) {
        self.oldPhoto = ::std::option::Option::None;
        self.newPhoto = ::std::option::Option::None;
        self.newPhotoId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhotoChange {
        static instance: PhotoChange = PhotoChange {
            oldPhoto: ::std::option::Option::None,
            newPhoto: ::std::option::Option::None,
            newPhotoId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhotoChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhotoChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhotoChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhotoChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MediaData)
pub struct MediaData {
    // message fields
    // @@protoc_insertion_point(field:MediaData.localPath)
    pub localPath: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MediaData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaData {
    fn default() -> &'a MediaData {
        <MediaData as ::protobuf::Message>::default_instance()
    }
}

impl MediaData {
    pub fn new() -> MediaData {
        ::std::default::Default::default()
    }

    // optional string localPath = 1;

    pub fn localPath(&self) -> &str {
        match self.localPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localPath(&mut self) {
        self.localPath = ::std::option::Option::None;
    }

    pub fn has_localPath(&self) -> bool {
        self.localPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localPath(&mut self, v: ::std::string::String) {
        self.localPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localPath(&mut self) -> &mut ::std::string::String {
        if self.localPath.is_none() {
            self.localPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_localPath(&mut self) -> ::std::string::String {
        self.localPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localPath",
            |m: &MediaData| { &m.localPath },
            |m: &mut MediaData| { &mut m.localPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaData>(
            "MediaData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaData {
    const NAME: &'static str = "MediaData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.localPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localPath.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaData {
        MediaData::new()
    }

    fn clear(&mut self) {
        self.localPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaData {
        static instance: MediaData = MediaData {
            localPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WebFeatures)
pub struct WebFeatures {
    // message fields
    // @@protoc_insertion_point(field:WebFeatures.labelsDisplay)
    pub labelsDisplay: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.voipIndividualOutgoing)
    pub voipIndividualOutgoing: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.groupsV3)
    pub groupsV3: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.groupsV3Create)
    pub groupsV3Create: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.changeNumberV2)
    pub changeNumberV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.queryStatusV3Thumbnail)
    pub queryStatusV3Thumbnail: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.liveLocations)
    pub liveLocations: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.queryVname)
    pub queryVname: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.voipIndividualIncoming)
    pub voipIndividualIncoming: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.quickRepliesQuery)
    pub quickRepliesQuery: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.payments)
    pub payments: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.stickerPackQuery)
    pub stickerPackQuery: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.liveLocationsFinal)
    pub liveLocationsFinal: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.labelsEdit)
    pub labelsEdit: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.mediaUpload)
    pub mediaUpload: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.mediaUploadRichQuickReplies)
    pub mediaUploadRichQuickReplies: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.vnameV2)
    pub vnameV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.videoPlaybackUrl)
    pub videoPlaybackUrl: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.statusRanking)
    pub statusRanking: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.voipIndividualVideo)
    pub voipIndividualVideo: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.thirdPartyStickers)
    pub thirdPartyStickers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.frequentlyForwardedSetting)
    pub frequentlyForwardedSetting: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.groupsV4JoinPermission)
    pub groupsV4JoinPermission: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.recentStickers)
    pub recentStickers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.catalog)
    pub catalog: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.starredStickers)
    pub starredStickers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.voipGroupCall)
    pub voipGroupCall: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.templateMessage)
    pub templateMessage: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.templateMessageInteractivity)
    pub templateMessageInteractivity: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.ephemeralMessages)
    pub ephemeralMessages: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.e2ENotificationSync)
    pub e2ENotificationSync: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.recentStickersV2)
    pub recentStickersV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.recentStickersV3)
    pub recentStickersV3: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.userNotice)
    pub userNotice: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.support)
    pub support: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.groupUiiCleanup)
    pub groupUiiCleanup: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.groupDogfoodingInternalOnly)
    pub groupDogfoodingInternalOnly: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.settingsSync)
    pub settingsSync: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.archiveV2)
    pub archiveV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.ephemeralAllowGroupMembers)
    pub ephemeralAllowGroupMembers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.ephemeral24HDuration)
    pub ephemeral24HDuration: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.mdForceUpgrade)
    pub mdForceUpgrade: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.disappearingMode)
    pub disappearingMode: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.externalMdOptInAvailable)
    pub externalMdOptInAvailable: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // @@protoc_insertion_point(field:WebFeatures.noDeleteMessageTimeLimit)
    pub noDeleteMessageTimeLimit: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::WebFeaturesFlag>>,
    // special fields
    // @@protoc_insertion_point(special_field:WebFeatures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebFeatures {
    fn default() -> &'a WebFeatures {
        <WebFeatures as ::protobuf::Message>::default_instance()
    }
}

impl WebFeatures {
    pub fn new() -> WebFeatures {
        ::std::default::Default::default()
    }

    // optional .WebFeatures.WebFeaturesFlag labelsDisplay = 1;

    pub fn labelsDisplay(&self) -> web_features::WebFeaturesFlag {
        match self.labelsDisplay {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_labelsDisplay(&mut self) {
        self.labelsDisplay = ::std::option::Option::None;
    }

    pub fn has_labelsDisplay(&self) -> bool {
        self.labelsDisplay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelsDisplay(&mut self, v: web_features::WebFeaturesFlag) {
        self.labelsDisplay = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag voipIndividualOutgoing = 2;

    pub fn voipIndividualOutgoing(&self) -> web_features::WebFeaturesFlag {
        match self.voipIndividualOutgoing {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_voipIndividualOutgoing(&mut self) {
        self.voipIndividualOutgoing = ::std::option::Option::None;
    }

    pub fn has_voipIndividualOutgoing(&self) -> bool {
        self.voipIndividualOutgoing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipIndividualOutgoing(&mut self, v: web_features::WebFeaturesFlag) {
        self.voipIndividualOutgoing = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag groupsV3 = 3;

    pub fn groupsV3(&self) -> web_features::WebFeaturesFlag {
        match self.groupsV3 {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_groupsV3(&mut self) {
        self.groupsV3 = ::std::option::Option::None;
    }

    pub fn has_groupsV3(&self) -> bool {
        self.groupsV3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupsV3(&mut self, v: web_features::WebFeaturesFlag) {
        self.groupsV3 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag groupsV3Create = 4;

    pub fn groupsV3Create(&self) -> web_features::WebFeaturesFlag {
        match self.groupsV3Create {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_groupsV3Create(&mut self) {
        self.groupsV3Create = ::std::option::Option::None;
    }

    pub fn has_groupsV3Create(&self) -> bool {
        self.groupsV3Create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupsV3Create(&mut self, v: web_features::WebFeaturesFlag) {
        self.groupsV3Create = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag changeNumberV2 = 5;

    pub fn changeNumberV2(&self) -> web_features::WebFeaturesFlag {
        match self.changeNumberV2 {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_changeNumberV2(&mut self) {
        self.changeNumberV2 = ::std::option::Option::None;
    }

    pub fn has_changeNumberV2(&self) -> bool {
        self.changeNumberV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeNumberV2(&mut self, v: web_features::WebFeaturesFlag) {
        self.changeNumberV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag queryStatusV3Thumbnail = 6;

    pub fn queryStatusV3Thumbnail(&self) -> web_features::WebFeaturesFlag {
        match self.queryStatusV3Thumbnail {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_queryStatusV3Thumbnail(&mut self) {
        self.queryStatusV3Thumbnail = ::std::option::Option::None;
    }

    pub fn has_queryStatusV3Thumbnail(&self) -> bool {
        self.queryStatusV3Thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queryStatusV3Thumbnail(&mut self, v: web_features::WebFeaturesFlag) {
        self.queryStatusV3Thumbnail = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag liveLocations = 7;

    pub fn liveLocations(&self) -> web_features::WebFeaturesFlag {
        match self.liveLocations {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_liveLocations(&mut self) {
        self.liveLocations = ::std::option::Option::None;
    }

    pub fn has_liveLocations(&self) -> bool {
        self.liveLocations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_liveLocations(&mut self, v: web_features::WebFeaturesFlag) {
        self.liveLocations = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag queryVname = 8;

    pub fn queryVname(&self) -> web_features::WebFeaturesFlag {
        match self.queryVname {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_queryVname(&mut self) {
        self.queryVname = ::std::option::Option::None;
    }

    pub fn has_queryVname(&self) -> bool {
        self.queryVname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queryVname(&mut self, v: web_features::WebFeaturesFlag) {
        self.queryVname = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag voipIndividualIncoming = 9;

    pub fn voipIndividualIncoming(&self) -> web_features::WebFeaturesFlag {
        match self.voipIndividualIncoming {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_voipIndividualIncoming(&mut self) {
        self.voipIndividualIncoming = ::std::option::Option::None;
    }

    pub fn has_voipIndividualIncoming(&self) -> bool {
        self.voipIndividualIncoming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipIndividualIncoming(&mut self, v: web_features::WebFeaturesFlag) {
        self.voipIndividualIncoming = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag quickRepliesQuery = 10;

    pub fn quickRepliesQuery(&self) -> web_features::WebFeaturesFlag {
        match self.quickRepliesQuery {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_quickRepliesQuery(&mut self) {
        self.quickRepliesQuery = ::std::option::Option::None;
    }

    pub fn has_quickRepliesQuery(&self) -> bool {
        self.quickRepliesQuery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quickRepliesQuery(&mut self, v: web_features::WebFeaturesFlag) {
        self.quickRepliesQuery = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag payments = 11;

    pub fn payments(&self) -> web_features::WebFeaturesFlag {
        match self.payments {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_payments(&mut self) {
        self.payments = ::std::option::Option::None;
    }

    pub fn has_payments(&self) -> bool {
        self.payments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payments(&mut self, v: web_features::WebFeaturesFlag) {
        self.payments = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag stickerPackQuery = 12;

    pub fn stickerPackQuery(&self) -> web_features::WebFeaturesFlag {
        match self.stickerPackQuery {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_stickerPackQuery(&mut self) {
        self.stickerPackQuery = ::std::option::Option::None;
    }

    pub fn has_stickerPackQuery(&self) -> bool {
        self.stickerPackQuery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stickerPackQuery(&mut self, v: web_features::WebFeaturesFlag) {
        self.stickerPackQuery = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag liveLocationsFinal = 13;

    pub fn liveLocationsFinal(&self) -> web_features::WebFeaturesFlag {
        match self.liveLocationsFinal {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_liveLocationsFinal(&mut self) {
        self.liveLocationsFinal = ::std::option::Option::None;
    }

    pub fn has_liveLocationsFinal(&self) -> bool {
        self.liveLocationsFinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_liveLocationsFinal(&mut self, v: web_features::WebFeaturesFlag) {
        self.liveLocationsFinal = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag labelsEdit = 14;

    pub fn labelsEdit(&self) -> web_features::WebFeaturesFlag {
        match self.labelsEdit {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_labelsEdit(&mut self) {
        self.labelsEdit = ::std::option::Option::None;
    }

    pub fn has_labelsEdit(&self) -> bool {
        self.labelsEdit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelsEdit(&mut self, v: web_features::WebFeaturesFlag) {
        self.labelsEdit = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag mediaUpload = 15;

    pub fn mediaUpload(&self) -> web_features::WebFeaturesFlag {
        match self.mediaUpload {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_mediaUpload(&mut self) {
        self.mediaUpload = ::std::option::Option::None;
    }

    pub fn has_mediaUpload(&self) -> bool {
        self.mediaUpload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaUpload(&mut self, v: web_features::WebFeaturesFlag) {
        self.mediaUpload = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag mediaUploadRichQuickReplies = 18;

    pub fn mediaUploadRichQuickReplies(&self) -> web_features::WebFeaturesFlag {
        match self.mediaUploadRichQuickReplies {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_mediaUploadRichQuickReplies(&mut self) {
        self.mediaUploadRichQuickReplies = ::std::option::Option::None;
    }

    pub fn has_mediaUploadRichQuickReplies(&self) -> bool {
        self.mediaUploadRichQuickReplies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaUploadRichQuickReplies(&mut self, v: web_features::WebFeaturesFlag) {
        self.mediaUploadRichQuickReplies = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag vnameV2 = 19;

    pub fn vnameV2(&self) -> web_features::WebFeaturesFlag {
        match self.vnameV2 {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_vnameV2(&mut self) {
        self.vnameV2 = ::std::option::Option::None;
    }

    pub fn has_vnameV2(&self) -> bool {
        self.vnameV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vnameV2(&mut self, v: web_features::WebFeaturesFlag) {
        self.vnameV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag videoPlaybackUrl = 20;

    pub fn videoPlaybackUrl(&self) -> web_features::WebFeaturesFlag {
        match self.videoPlaybackUrl {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_videoPlaybackUrl(&mut self) {
        self.videoPlaybackUrl = ::std::option::Option::None;
    }

    pub fn has_videoPlaybackUrl(&self) -> bool {
        self.videoPlaybackUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_videoPlaybackUrl(&mut self, v: web_features::WebFeaturesFlag) {
        self.videoPlaybackUrl = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag statusRanking = 21;

    pub fn statusRanking(&self) -> web_features::WebFeaturesFlag {
        match self.statusRanking {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_statusRanking(&mut self) {
        self.statusRanking = ::std::option::Option::None;
    }

    pub fn has_statusRanking(&self) -> bool {
        self.statusRanking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusRanking(&mut self, v: web_features::WebFeaturesFlag) {
        self.statusRanking = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag voipIndividualVideo = 22;

    pub fn voipIndividualVideo(&self) -> web_features::WebFeaturesFlag {
        match self.voipIndividualVideo {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_voipIndividualVideo(&mut self) {
        self.voipIndividualVideo = ::std::option::Option::None;
    }

    pub fn has_voipIndividualVideo(&self) -> bool {
        self.voipIndividualVideo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipIndividualVideo(&mut self, v: web_features::WebFeaturesFlag) {
        self.voipIndividualVideo = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag thirdPartyStickers = 23;

    pub fn thirdPartyStickers(&self) -> web_features::WebFeaturesFlag {
        match self.thirdPartyStickers {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_thirdPartyStickers(&mut self) {
        self.thirdPartyStickers = ::std::option::Option::None;
    }

    pub fn has_thirdPartyStickers(&self) -> bool {
        self.thirdPartyStickers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thirdPartyStickers(&mut self, v: web_features::WebFeaturesFlag) {
        self.thirdPartyStickers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag frequentlyForwardedSetting = 24;

    pub fn frequentlyForwardedSetting(&self) -> web_features::WebFeaturesFlag {
        match self.frequentlyForwardedSetting {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_frequentlyForwardedSetting(&mut self) {
        self.frequentlyForwardedSetting = ::std::option::Option::None;
    }

    pub fn has_frequentlyForwardedSetting(&self) -> bool {
        self.frequentlyForwardedSetting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequentlyForwardedSetting(&mut self, v: web_features::WebFeaturesFlag) {
        self.frequentlyForwardedSetting = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag groupsV4JoinPermission = 25;

    pub fn groupsV4JoinPermission(&self) -> web_features::WebFeaturesFlag {
        match self.groupsV4JoinPermission {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_groupsV4JoinPermission(&mut self) {
        self.groupsV4JoinPermission = ::std::option::Option::None;
    }

    pub fn has_groupsV4JoinPermission(&self) -> bool {
        self.groupsV4JoinPermission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupsV4JoinPermission(&mut self, v: web_features::WebFeaturesFlag) {
        self.groupsV4JoinPermission = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag recentStickers = 26;

    pub fn recentStickers(&self) -> web_features::WebFeaturesFlag {
        match self.recentStickers {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_recentStickers(&mut self) {
        self.recentStickers = ::std::option::Option::None;
    }

    pub fn has_recentStickers(&self) -> bool {
        self.recentStickers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recentStickers(&mut self, v: web_features::WebFeaturesFlag) {
        self.recentStickers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag catalog = 27;

    pub fn catalog(&self) -> web_features::WebFeaturesFlag {
        match self.catalog {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_catalog(&mut self) {
        self.catalog = ::std::option::Option::None;
    }

    pub fn has_catalog(&self) -> bool {
        self.catalog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_catalog(&mut self, v: web_features::WebFeaturesFlag) {
        self.catalog = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag starredStickers = 28;

    pub fn starredStickers(&self) -> web_features::WebFeaturesFlag {
        match self.starredStickers {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_starredStickers(&mut self) {
        self.starredStickers = ::std::option::Option::None;
    }

    pub fn has_starredStickers(&self) -> bool {
        self.starredStickers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starredStickers(&mut self, v: web_features::WebFeaturesFlag) {
        self.starredStickers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag voipGroupCall = 29;

    pub fn voipGroupCall(&self) -> web_features::WebFeaturesFlag {
        match self.voipGroupCall {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_voipGroupCall(&mut self) {
        self.voipGroupCall = ::std::option::Option::None;
    }

    pub fn has_voipGroupCall(&self) -> bool {
        self.voipGroupCall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipGroupCall(&mut self, v: web_features::WebFeaturesFlag) {
        self.voipGroupCall = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag templateMessage = 30;

    pub fn templateMessage(&self) -> web_features::WebFeaturesFlag {
        match self.templateMessage {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_templateMessage(&mut self) {
        self.templateMessage = ::std::option::Option::None;
    }

    pub fn has_templateMessage(&self) -> bool {
        self.templateMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_templateMessage(&mut self, v: web_features::WebFeaturesFlag) {
        self.templateMessage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag templateMessageInteractivity = 31;

    pub fn templateMessageInteractivity(&self) -> web_features::WebFeaturesFlag {
        match self.templateMessageInteractivity {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_templateMessageInteractivity(&mut self) {
        self.templateMessageInteractivity = ::std::option::Option::None;
    }

    pub fn has_templateMessageInteractivity(&self) -> bool {
        self.templateMessageInteractivity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_templateMessageInteractivity(&mut self, v: web_features::WebFeaturesFlag) {
        self.templateMessageInteractivity = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag ephemeralMessages = 32;

    pub fn ephemeralMessages(&self) -> web_features::WebFeaturesFlag {
        match self.ephemeralMessages {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_ephemeralMessages(&mut self) {
        self.ephemeralMessages = ::std::option::Option::None;
    }

    pub fn has_ephemeralMessages(&self) -> bool {
        self.ephemeralMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralMessages(&mut self, v: web_features::WebFeaturesFlag) {
        self.ephemeralMessages = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag e2ENotificationSync = 33;

    pub fn e2ENotificationSync(&self) -> web_features::WebFeaturesFlag {
        match self.e2ENotificationSync {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_e2ENotificationSync(&mut self) {
        self.e2ENotificationSync = ::std::option::Option::None;
    }

    pub fn has_e2ENotificationSync(&self) -> bool {
        self.e2ENotificationSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2ENotificationSync(&mut self, v: web_features::WebFeaturesFlag) {
        self.e2ENotificationSync = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag recentStickersV2 = 34;

    pub fn recentStickersV2(&self) -> web_features::WebFeaturesFlag {
        match self.recentStickersV2 {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_recentStickersV2(&mut self) {
        self.recentStickersV2 = ::std::option::Option::None;
    }

    pub fn has_recentStickersV2(&self) -> bool {
        self.recentStickersV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recentStickersV2(&mut self, v: web_features::WebFeaturesFlag) {
        self.recentStickersV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag recentStickersV3 = 36;

    pub fn recentStickersV3(&self) -> web_features::WebFeaturesFlag {
        match self.recentStickersV3 {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_recentStickersV3(&mut self) {
        self.recentStickersV3 = ::std::option::Option::None;
    }

    pub fn has_recentStickersV3(&self) -> bool {
        self.recentStickersV3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recentStickersV3(&mut self, v: web_features::WebFeaturesFlag) {
        self.recentStickersV3 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag userNotice = 37;

    pub fn userNotice(&self) -> web_features::WebFeaturesFlag {
        match self.userNotice {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_userNotice(&mut self) {
        self.userNotice = ::std::option::Option::None;
    }

    pub fn has_userNotice(&self) -> bool {
        self.userNotice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userNotice(&mut self, v: web_features::WebFeaturesFlag) {
        self.userNotice = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag support = 39;

    pub fn support(&self) -> web_features::WebFeaturesFlag {
        match self.support {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: web_features::WebFeaturesFlag) {
        self.support = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag groupUiiCleanup = 40;

    pub fn groupUiiCleanup(&self) -> web_features::WebFeaturesFlag {
        match self.groupUiiCleanup {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_groupUiiCleanup(&mut self) {
        self.groupUiiCleanup = ::std::option::Option::None;
    }

    pub fn has_groupUiiCleanup(&self) -> bool {
        self.groupUiiCleanup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupUiiCleanup(&mut self, v: web_features::WebFeaturesFlag) {
        self.groupUiiCleanup = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag groupDogfoodingInternalOnly = 41;

    pub fn groupDogfoodingInternalOnly(&self) -> web_features::WebFeaturesFlag {
        match self.groupDogfoodingInternalOnly {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_groupDogfoodingInternalOnly(&mut self) {
        self.groupDogfoodingInternalOnly = ::std::option::Option::None;
    }

    pub fn has_groupDogfoodingInternalOnly(&self) -> bool {
        self.groupDogfoodingInternalOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupDogfoodingInternalOnly(&mut self, v: web_features::WebFeaturesFlag) {
        self.groupDogfoodingInternalOnly = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag settingsSync = 42;

    pub fn settingsSync(&self) -> web_features::WebFeaturesFlag {
        match self.settingsSync {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_settingsSync(&mut self) {
        self.settingsSync = ::std::option::Option::None;
    }

    pub fn has_settingsSync(&self) -> bool {
        self.settingsSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settingsSync(&mut self, v: web_features::WebFeaturesFlag) {
        self.settingsSync = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag archiveV2 = 43;

    pub fn archiveV2(&self) -> web_features::WebFeaturesFlag {
        match self.archiveV2 {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_archiveV2(&mut self) {
        self.archiveV2 = ::std::option::Option::None;
    }

    pub fn has_archiveV2(&self) -> bool {
        self.archiveV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archiveV2(&mut self, v: web_features::WebFeaturesFlag) {
        self.archiveV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag ephemeralAllowGroupMembers = 44;

    pub fn ephemeralAllowGroupMembers(&self) -> web_features::WebFeaturesFlag {
        match self.ephemeralAllowGroupMembers {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_ephemeralAllowGroupMembers(&mut self) {
        self.ephemeralAllowGroupMembers = ::std::option::Option::None;
    }

    pub fn has_ephemeralAllowGroupMembers(&self) -> bool {
        self.ephemeralAllowGroupMembers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralAllowGroupMembers(&mut self, v: web_features::WebFeaturesFlag) {
        self.ephemeralAllowGroupMembers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag ephemeral24HDuration = 45;

    pub fn ephemeral24HDuration(&self) -> web_features::WebFeaturesFlag {
        match self.ephemeral24HDuration {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_ephemeral24HDuration(&mut self) {
        self.ephemeral24HDuration = ::std::option::Option::None;
    }

    pub fn has_ephemeral24HDuration(&self) -> bool {
        self.ephemeral24HDuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral24HDuration(&mut self, v: web_features::WebFeaturesFlag) {
        self.ephemeral24HDuration = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag mdForceUpgrade = 46;

    pub fn mdForceUpgrade(&self) -> web_features::WebFeaturesFlag {
        match self.mdForceUpgrade {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_mdForceUpgrade(&mut self) {
        self.mdForceUpgrade = ::std::option::Option::None;
    }

    pub fn has_mdForceUpgrade(&self) -> bool {
        self.mdForceUpgrade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mdForceUpgrade(&mut self, v: web_features::WebFeaturesFlag) {
        self.mdForceUpgrade = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag disappearingMode = 47;

    pub fn disappearingMode(&self) -> web_features::WebFeaturesFlag {
        match self.disappearingMode {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_disappearingMode(&mut self) {
        self.disappearingMode = ::std::option::Option::None;
    }

    pub fn has_disappearingMode(&self) -> bool {
        self.disappearingMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disappearingMode(&mut self, v: web_features::WebFeaturesFlag) {
        self.disappearingMode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag externalMdOptInAvailable = 48;

    pub fn externalMdOptInAvailable(&self) -> web_features::WebFeaturesFlag {
        match self.externalMdOptInAvailable {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_externalMdOptInAvailable(&mut self) {
        self.externalMdOptInAvailable = ::std::option::Option::None;
    }

    pub fn has_externalMdOptInAvailable(&self) -> bool {
        self.externalMdOptInAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalMdOptInAvailable(&mut self, v: web_features::WebFeaturesFlag) {
        self.externalMdOptInAvailable = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .WebFeatures.WebFeaturesFlag noDeleteMessageTimeLimit = 49;

    pub fn noDeleteMessageTimeLimit(&self) -> web_features::WebFeaturesFlag {
        match self.noDeleteMessageTimeLimit {
            Some(e) => e.enum_value_or(web_features::WebFeaturesFlag::NOT_STARTED),
            None => web_features::WebFeaturesFlag::NOT_STARTED,
        }
    }

    pub fn clear_noDeleteMessageTimeLimit(&mut self) {
        self.noDeleteMessageTimeLimit = ::std::option::Option::None;
    }

    pub fn has_noDeleteMessageTimeLimit(&self) -> bool {
        self.noDeleteMessageTimeLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_noDeleteMessageTimeLimit(&mut self, v: web_features::WebFeaturesFlag) {
        self.noDeleteMessageTimeLimit = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(45);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labelsDisplay",
            |m: &WebFeatures| { &m.labelsDisplay },
            |m: &mut WebFeatures| { &mut m.labelsDisplay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipIndividualOutgoing",
            |m: &WebFeatures| { &m.voipIndividualOutgoing },
            |m: &mut WebFeatures| { &mut m.voipIndividualOutgoing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupsV3",
            |m: &WebFeatures| { &m.groupsV3 },
            |m: &mut WebFeatures| { &mut m.groupsV3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupsV3Create",
            |m: &WebFeatures| { &m.groupsV3Create },
            |m: &mut WebFeatures| { &mut m.groupsV3Create },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "changeNumberV2",
            |m: &WebFeatures| { &m.changeNumberV2 },
            |m: &mut WebFeatures| { &mut m.changeNumberV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queryStatusV3Thumbnail",
            |m: &WebFeatures| { &m.queryStatusV3Thumbnail },
            |m: &mut WebFeatures| { &mut m.queryStatusV3Thumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "liveLocations",
            |m: &WebFeatures| { &m.liveLocations },
            |m: &mut WebFeatures| { &mut m.liveLocations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queryVname",
            |m: &WebFeatures| { &m.queryVname },
            |m: &mut WebFeatures| { &mut m.queryVname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipIndividualIncoming",
            |m: &WebFeatures| { &m.voipIndividualIncoming },
            |m: &mut WebFeatures| { &mut m.voipIndividualIncoming },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quickRepliesQuery",
            |m: &WebFeatures| { &m.quickRepliesQuery },
            |m: &mut WebFeatures| { &mut m.quickRepliesQuery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payments",
            |m: &WebFeatures| { &m.payments },
            |m: &mut WebFeatures| { &mut m.payments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stickerPackQuery",
            |m: &WebFeatures| { &m.stickerPackQuery },
            |m: &mut WebFeatures| { &mut m.stickerPackQuery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "liveLocationsFinal",
            |m: &WebFeatures| { &m.liveLocationsFinal },
            |m: &mut WebFeatures| { &mut m.liveLocationsFinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labelsEdit",
            |m: &WebFeatures| { &m.labelsEdit },
            |m: &mut WebFeatures| { &mut m.labelsEdit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaUpload",
            |m: &WebFeatures| { &m.mediaUpload },
            |m: &mut WebFeatures| { &mut m.mediaUpload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaUploadRichQuickReplies",
            |m: &WebFeatures| { &m.mediaUploadRichQuickReplies },
            |m: &mut WebFeatures| { &mut m.mediaUploadRichQuickReplies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vnameV2",
            |m: &WebFeatures| { &m.vnameV2 },
            |m: &mut WebFeatures| { &mut m.vnameV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "videoPlaybackUrl",
            |m: &WebFeatures| { &m.videoPlaybackUrl },
            |m: &mut WebFeatures| { &mut m.videoPlaybackUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "statusRanking",
            |m: &WebFeatures| { &m.statusRanking },
            |m: &mut WebFeatures| { &mut m.statusRanking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipIndividualVideo",
            |m: &WebFeatures| { &m.voipIndividualVideo },
            |m: &mut WebFeatures| { &mut m.voipIndividualVideo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thirdPartyStickers",
            |m: &WebFeatures| { &m.thirdPartyStickers },
            |m: &mut WebFeatures| { &mut m.thirdPartyStickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequentlyForwardedSetting",
            |m: &WebFeatures| { &m.frequentlyForwardedSetting },
            |m: &mut WebFeatures| { &mut m.frequentlyForwardedSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupsV4JoinPermission",
            |m: &WebFeatures| { &m.groupsV4JoinPermission },
            |m: &mut WebFeatures| { &mut m.groupsV4JoinPermission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recentStickers",
            |m: &WebFeatures| { &m.recentStickers },
            |m: &mut WebFeatures| { &mut m.recentStickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "catalog",
            |m: &WebFeatures| { &m.catalog },
            |m: &mut WebFeatures| { &mut m.catalog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "starredStickers",
            |m: &WebFeatures| { &m.starredStickers },
            |m: &mut WebFeatures| { &mut m.starredStickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipGroupCall",
            |m: &WebFeatures| { &m.voipGroupCall },
            |m: &mut WebFeatures| { &mut m.voipGroupCall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "templateMessage",
            |m: &WebFeatures| { &m.templateMessage },
            |m: &mut WebFeatures| { &mut m.templateMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "templateMessageInteractivity",
            |m: &WebFeatures| { &m.templateMessageInteractivity },
            |m: &mut WebFeatures| { &mut m.templateMessageInteractivity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralMessages",
            |m: &WebFeatures| { &m.ephemeralMessages },
            |m: &mut WebFeatures| { &mut m.ephemeralMessages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "e2ENotificationSync",
            |m: &WebFeatures| { &m.e2ENotificationSync },
            |m: &mut WebFeatures| { &mut m.e2ENotificationSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recentStickersV2",
            |m: &WebFeatures| { &m.recentStickersV2 },
            |m: &mut WebFeatures| { &mut m.recentStickersV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recentStickersV3",
            |m: &WebFeatures| { &m.recentStickersV3 },
            |m: &mut WebFeatures| { &mut m.recentStickersV3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userNotice",
            |m: &WebFeatures| { &m.userNotice },
            |m: &mut WebFeatures| { &mut m.userNotice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support",
            |m: &WebFeatures| { &m.support },
            |m: &mut WebFeatures| { &mut m.support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupUiiCleanup",
            |m: &WebFeatures| { &m.groupUiiCleanup },
            |m: &mut WebFeatures| { &mut m.groupUiiCleanup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupDogfoodingInternalOnly",
            |m: &WebFeatures| { &m.groupDogfoodingInternalOnly },
            |m: &mut WebFeatures| { &mut m.groupDogfoodingInternalOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "settingsSync",
            |m: &WebFeatures| { &m.settingsSync },
            |m: &mut WebFeatures| { &mut m.settingsSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "archiveV2",
            |m: &WebFeatures| { &m.archiveV2 },
            |m: &mut WebFeatures| { &mut m.archiveV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralAllowGroupMembers",
            |m: &WebFeatures| { &m.ephemeralAllowGroupMembers },
            |m: &mut WebFeatures| { &mut m.ephemeralAllowGroupMembers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeral24HDuration",
            |m: &WebFeatures| { &m.ephemeral24HDuration },
            |m: &mut WebFeatures| { &mut m.ephemeral24HDuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mdForceUpgrade",
            |m: &WebFeatures| { &m.mdForceUpgrade },
            |m: &mut WebFeatures| { &mut m.mdForceUpgrade },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disappearingMode",
            |m: &WebFeatures| { &m.disappearingMode },
            |m: &mut WebFeatures| { &mut m.disappearingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "externalMdOptInAvailable",
            |m: &WebFeatures| { &m.externalMdOptInAvailable },
            |m: &mut WebFeatures| { &mut m.externalMdOptInAvailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "noDeleteMessageTimeLimit",
            |m: &WebFeatures| { &m.noDeleteMessageTimeLimit },
            |m: &mut WebFeatures| { &mut m.noDeleteMessageTimeLimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebFeatures>(
            "WebFeatures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebFeatures {
    const NAME: &'static str = "WebFeatures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.labelsDisplay = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.voipIndividualOutgoing = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.groupsV3 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.groupsV3Create = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.changeNumberV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.queryStatusV3Thumbnail = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.liveLocations = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.queryVname = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.voipIndividualIncoming = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.quickRepliesQuery = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.payments = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.stickerPackQuery = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.liveLocationsFinal = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                112 => {
                    self.labelsEdit = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                120 => {
                    self.mediaUpload = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                144 => {
                    self.mediaUploadRichQuickReplies = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                152 => {
                    self.vnameV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.videoPlaybackUrl = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                168 => {
                    self.statusRanking = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                176 => {
                    self.voipIndividualVideo = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                184 => {
                    self.thirdPartyStickers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                192 => {
                    self.frequentlyForwardedSetting = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.groupsV4JoinPermission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                208 => {
                    self.recentStickers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                216 => {
                    self.catalog = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                224 => {
                    self.starredStickers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                232 => {
                    self.voipGroupCall = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.templateMessage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                248 => {
                    self.templateMessageInteractivity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                256 => {
                    self.ephemeralMessages = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                264 => {
                    self.e2ENotificationSync = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                272 => {
                    self.recentStickersV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                288 => {
                    self.recentStickersV3 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                296 => {
                    self.userNotice = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                312 => {
                    self.support = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                320 => {
                    self.groupUiiCleanup = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                328 => {
                    self.groupDogfoodingInternalOnly = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                336 => {
                    self.settingsSync = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                344 => {
                    self.archiveV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                352 => {
                    self.ephemeralAllowGroupMembers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                360 => {
                    self.ephemeral24HDuration = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                368 => {
                    self.mdForceUpgrade = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                376 => {
                    self.disappearingMode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                384 => {
                    self.externalMdOptInAvailable = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                392 => {
                    self.noDeleteMessageTimeLimit = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.labelsDisplay {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.voipIndividualOutgoing {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.groupsV3 {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.groupsV3Create {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.changeNumberV2 {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.queryStatusV3Thumbnail {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.liveLocations {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.queryVname {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.voipIndividualIncoming {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.quickRepliesQuery {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.payments {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.stickerPackQuery {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.liveLocationsFinal {
            my_size += ::protobuf::rt::int32_size(13, v.value());
        }
        if let Some(v) = self.labelsEdit {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        if let Some(v) = self.mediaUpload {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.mediaUploadRichQuickReplies {
            my_size += ::protobuf::rt::int32_size(18, v.value());
        }
        if let Some(v) = self.vnameV2 {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.videoPlaybackUrl {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.statusRanking {
            my_size += ::protobuf::rt::int32_size(21, v.value());
        }
        if let Some(v) = self.voipIndividualVideo {
            my_size += ::protobuf::rt::int32_size(22, v.value());
        }
        if let Some(v) = self.thirdPartyStickers {
            my_size += ::protobuf::rt::int32_size(23, v.value());
        }
        if let Some(v) = self.frequentlyForwardedSetting {
            my_size += ::protobuf::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.groupsV4JoinPermission {
            my_size += ::protobuf::rt::int32_size(25, v.value());
        }
        if let Some(v) = self.recentStickers {
            my_size += ::protobuf::rt::int32_size(26, v.value());
        }
        if let Some(v) = self.catalog {
            my_size += ::protobuf::rt::int32_size(27, v.value());
        }
        if let Some(v) = self.starredStickers {
            my_size += ::protobuf::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.voipGroupCall {
            my_size += ::protobuf::rt::int32_size(29, v.value());
        }
        if let Some(v) = self.templateMessage {
            my_size += ::protobuf::rt::int32_size(30, v.value());
        }
        if let Some(v) = self.templateMessageInteractivity {
            my_size += ::protobuf::rt::int32_size(31, v.value());
        }
        if let Some(v) = self.ephemeralMessages {
            my_size += ::protobuf::rt::int32_size(32, v.value());
        }
        if let Some(v) = self.e2ENotificationSync {
            my_size += ::protobuf::rt::int32_size(33, v.value());
        }
        if let Some(v) = self.recentStickersV2 {
            my_size += ::protobuf::rt::int32_size(34, v.value());
        }
        if let Some(v) = self.recentStickersV3 {
            my_size += ::protobuf::rt::int32_size(36, v.value());
        }
        if let Some(v) = self.userNotice {
            my_size += ::protobuf::rt::int32_size(37, v.value());
        }
        if let Some(v) = self.support {
            my_size += ::protobuf::rt::int32_size(39, v.value());
        }
        if let Some(v) = self.groupUiiCleanup {
            my_size += ::protobuf::rt::int32_size(40, v.value());
        }
        if let Some(v) = self.groupDogfoodingInternalOnly {
            my_size += ::protobuf::rt::int32_size(41, v.value());
        }
        if let Some(v) = self.settingsSync {
            my_size += ::protobuf::rt::int32_size(42, v.value());
        }
        if let Some(v) = self.archiveV2 {
            my_size += ::protobuf::rt::int32_size(43, v.value());
        }
        if let Some(v) = self.ephemeralAllowGroupMembers {
            my_size += ::protobuf::rt::int32_size(44, v.value());
        }
        if let Some(v) = self.ephemeral24HDuration {
            my_size += ::protobuf::rt::int32_size(45, v.value());
        }
        if let Some(v) = self.mdForceUpgrade {
            my_size += ::protobuf::rt::int32_size(46, v.value());
        }
        if let Some(v) = self.disappearingMode {
            my_size += ::protobuf::rt::int32_size(47, v.value());
        }
        if let Some(v) = self.externalMdOptInAvailable {
            my_size += ::protobuf::rt::int32_size(48, v.value());
        }
        if let Some(v) = self.noDeleteMessageTimeLimit {
            my_size += ::protobuf::rt::int32_size(49, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.labelsDisplay {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipIndividualOutgoing {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupsV3 {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupsV3Create {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.changeNumberV2 {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.queryStatusV3Thumbnail {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.liveLocations {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.queryVname {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipIndividualIncoming {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.quickRepliesQuery {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.payments {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.stickerPackQuery {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.liveLocationsFinal {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.labelsEdit {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mediaUpload {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mediaUploadRichQuickReplies {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.vnameV2 {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.videoPlaybackUrl {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.statusRanking {
            os.write_enum(21, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipIndividualVideo {
            os.write_enum(22, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.thirdPartyStickers {
            os.write_enum(23, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frequentlyForwardedSetting {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupsV4JoinPermission {
            os.write_enum(25, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.recentStickers {
            os.write_enum(26, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.catalog {
            os.write_enum(27, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.starredStickers {
            os.write_enum(28, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipGroupCall {
            os.write_enum(29, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.templateMessage {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.templateMessageInteractivity {
            os.write_enum(31, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeralMessages {
            os.write_enum(32, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.e2ENotificationSync {
            os.write_enum(33, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.recentStickersV2 {
            os.write_enum(34, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.recentStickersV3 {
            os.write_enum(36, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.userNotice {
            os.write_enum(37, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.support {
            os.write_enum(39, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupUiiCleanup {
            os.write_enum(40, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupDogfoodingInternalOnly {
            os.write_enum(41, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.settingsSync {
            os.write_enum(42, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.archiveV2 {
            os.write_enum(43, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeralAllowGroupMembers {
            os.write_enum(44, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeral24HDuration {
            os.write_enum(45, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mdForceUpgrade {
            os.write_enum(46, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.disappearingMode {
            os.write_enum(47, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.externalMdOptInAvailable {
            os.write_enum(48, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.noDeleteMessageTimeLimit {
            os.write_enum(49, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebFeatures {
        WebFeatures::new()
    }

    fn clear(&mut self) {
        self.labelsDisplay = ::std::option::Option::None;
        self.voipIndividualOutgoing = ::std::option::Option::None;
        self.groupsV3 = ::std::option::Option::None;
        self.groupsV3Create = ::std::option::Option::None;
        self.changeNumberV2 = ::std::option::Option::None;
        self.queryStatusV3Thumbnail = ::std::option::Option::None;
        self.liveLocations = ::std::option::Option::None;
        self.queryVname = ::std::option::Option::None;
        self.voipIndividualIncoming = ::std::option::Option::None;
        self.quickRepliesQuery = ::std::option::Option::None;
        self.payments = ::std::option::Option::None;
        self.stickerPackQuery = ::std::option::Option::None;
        self.liveLocationsFinal = ::std::option::Option::None;
        self.labelsEdit = ::std::option::Option::None;
        self.mediaUpload = ::std::option::Option::None;
        self.mediaUploadRichQuickReplies = ::std::option::Option::None;
        self.vnameV2 = ::std::option::Option::None;
        self.videoPlaybackUrl = ::std::option::Option::None;
        self.statusRanking = ::std::option::Option::None;
        self.voipIndividualVideo = ::std::option::Option::None;
        self.thirdPartyStickers = ::std::option::Option::None;
        self.frequentlyForwardedSetting = ::std::option::Option::None;
        self.groupsV4JoinPermission = ::std::option::Option::None;
        self.recentStickers = ::std::option::Option::None;
        self.catalog = ::std::option::Option::None;
        self.starredStickers = ::std::option::Option::None;
        self.voipGroupCall = ::std::option::Option::None;
        self.templateMessage = ::std::option::Option::None;
        self.templateMessageInteractivity = ::std::option::Option::None;
        self.ephemeralMessages = ::std::option::Option::None;
        self.e2ENotificationSync = ::std::option::Option::None;
        self.recentStickersV2 = ::std::option::Option::None;
        self.recentStickersV3 = ::std::option::Option::None;
        self.userNotice = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.groupUiiCleanup = ::std::option::Option::None;
        self.groupDogfoodingInternalOnly = ::std::option::Option::None;
        self.settingsSync = ::std::option::Option::None;
        self.archiveV2 = ::std::option::Option::None;
        self.ephemeralAllowGroupMembers = ::std::option::Option::None;
        self.ephemeral24HDuration = ::std::option::Option::None;
        self.mdForceUpgrade = ::std::option::Option::None;
        self.disappearingMode = ::std::option::Option::None;
        self.externalMdOptInAvailable = ::std::option::Option::None;
        self.noDeleteMessageTimeLimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebFeatures {
        static instance: WebFeatures = WebFeatures {
            labelsDisplay: ::std::option::Option::None,
            voipIndividualOutgoing: ::std::option::Option::None,
            groupsV3: ::std::option::Option::None,
            groupsV3Create: ::std::option::Option::None,
            changeNumberV2: ::std::option::Option::None,
            queryStatusV3Thumbnail: ::std::option::Option::None,
            liveLocations: ::std::option::Option::None,
            queryVname: ::std::option::Option::None,
            voipIndividualIncoming: ::std::option::Option::None,
            quickRepliesQuery: ::std::option::Option::None,
            payments: ::std::option::Option::None,
            stickerPackQuery: ::std::option::Option::None,
            liveLocationsFinal: ::std::option::Option::None,
            labelsEdit: ::std::option::Option::None,
            mediaUpload: ::std::option::Option::None,
            mediaUploadRichQuickReplies: ::std::option::Option::None,
            vnameV2: ::std::option::Option::None,
            videoPlaybackUrl: ::std::option::Option::None,
            statusRanking: ::std::option::Option::None,
            voipIndividualVideo: ::std::option::Option::None,
            thirdPartyStickers: ::std::option::Option::None,
            frequentlyForwardedSetting: ::std::option::Option::None,
            groupsV4JoinPermission: ::std::option::Option::None,
            recentStickers: ::std::option::Option::None,
            catalog: ::std::option::Option::None,
            starredStickers: ::std::option::Option::None,
            voipGroupCall: ::std::option::Option::None,
            templateMessage: ::std::option::Option::None,
            templateMessageInteractivity: ::std::option::Option::None,
            ephemeralMessages: ::std::option::Option::None,
            e2ENotificationSync: ::std::option::Option::None,
            recentStickersV2: ::std::option::Option::None,
            recentStickersV3: ::std::option::Option::None,
            userNotice: ::std::option::Option::None,
            support: ::std::option::Option::None,
            groupUiiCleanup: ::std::option::Option::None,
            groupDogfoodingInternalOnly: ::std::option::Option::None,
            settingsSync: ::std::option::Option::None,
            archiveV2: ::std::option::Option::None,
            ephemeralAllowGroupMembers: ::std::option::Option::None,
            ephemeral24HDuration: ::std::option::Option::None,
            mdForceUpgrade: ::std::option::Option::None,
            disappearingMode: ::std::option::Option::None,
            externalMdOptInAvailable: ::std::option::Option::None,
            noDeleteMessageTimeLimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebFeatures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebFeatures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebFeatures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebFeatures`
pub mod web_features {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WebFeatures.WebFeaturesFlag)
    pub enum WebFeaturesFlag {
        // @@protoc_insertion_point(enum_value:WebFeatures.WebFeaturesFlag.NOT_STARTED)
        NOT_STARTED = 0,
        // @@protoc_insertion_point(enum_value:WebFeatures.WebFeaturesFlag.FORCE_UPGRADE)
        FORCE_UPGRADE = 1,
        // @@protoc_insertion_point(enum_value:WebFeatures.WebFeaturesFlag.DEVELOPMENT)
        DEVELOPMENT = 2,
        // @@protoc_insertion_point(enum_value:WebFeatures.WebFeaturesFlag.PRODUCTION)
        PRODUCTION = 3,
    }

    impl ::protobuf::Enum for WebFeaturesFlag {
        const NAME: &'static str = "WebFeaturesFlag";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WebFeaturesFlag> {
            match value {
                0 => ::std::option::Option::Some(WebFeaturesFlag::NOT_STARTED),
                1 => ::std::option::Option::Some(WebFeaturesFlag::FORCE_UPGRADE),
                2 => ::std::option::Option::Some(WebFeaturesFlag::DEVELOPMENT),
                3 => ::std::option::Option::Some(WebFeaturesFlag::PRODUCTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WebFeaturesFlag] = &[
            WebFeaturesFlag::NOT_STARTED,
            WebFeaturesFlag::FORCE_UPGRADE,
            WebFeaturesFlag::DEVELOPMENT,
            WebFeaturesFlag::PRODUCTION,
        ];
    }

    impl ::protobuf::EnumFull for WebFeaturesFlag {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebFeatures.WebFeaturesFlag").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WebFeaturesFlag {
        fn default() -> Self {
            WebFeaturesFlag::NOT_STARTED
        }
    }

    impl WebFeaturesFlag {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebFeaturesFlag>("WebFeatures.WebFeaturesFlag")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NotificationMessageInfo)
pub struct NotificationMessageInfo {
    // message fields
    // @@protoc_insertion_point(field:NotificationMessageInfo.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:NotificationMessageInfo.message)
    pub message: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:NotificationMessageInfo.messageTimestamp)
    pub messageTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:NotificationMessageInfo.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:NotificationMessageInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NotificationMessageInfo {
    fn default() -> &'a NotificationMessageInfo {
        <NotificationMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl NotificationMessageInfo {
    pub fn new() -> NotificationMessageInfo {
        ::std::default::Default::default()
    }

    // optional uint64 messageTimestamp = 3;

    pub fn messageTimestamp(&self) -> u64 {
        self.messageTimestamp.unwrap_or(0)
    }

    pub fn clear_messageTimestamp(&mut self) {
        self.messageTimestamp = ::std::option::Option::None;
    }

    pub fn has_messageTimestamp(&self) -> bool {
        self.messageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageTimestamp(&mut self, v: u64) {
        self.messageTimestamp = ::std::option::Option::Some(v);
    }

    // optional string participant = 4;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &NotificationMessageInfo| { &m.key },
            |m: &mut NotificationMessageInfo| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &NotificationMessageInfo| { &m.message },
            |m: &mut NotificationMessageInfo| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageTimestamp",
            |m: &NotificationMessageInfo| { &m.messageTimestamp },
            |m: &mut NotificationMessageInfo| { &mut m.messageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &NotificationMessageInfo| { &m.participant },
            |m: &mut NotificationMessageInfo| { &mut m.participant },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NotificationMessageInfo>(
            "NotificationMessageInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NotificationMessageInfo {
    const NAME: &'static str = "NotificationMessageInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                24 => {
                    self.messageTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.messageTimestamp {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.messageTimestamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NotificationMessageInfo {
        NotificationMessageInfo::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.message.clear();
        self.messageTimestamp = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NotificationMessageInfo {
        static instance: NotificationMessageInfo = NotificationMessageInfo {
            key: ::protobuf::MessageField::none(),
            message: ::protobuf::MessageField::none(),
            messageTimestamp: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NotificationMessageInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NotificationMessageInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NotificationMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotificationMessageInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WebNotificationsInfo)
pub struct WebNotificationsInfo {
    // message fields
    // @@protoc_insertion_point(field:WebNotificationsInfo.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WebNotificationsInfo.unreadChats)
    pub unreadChats: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WebNotificationsInfo.notifyMessageCount)
    pub notifyMessageCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WebNotificationsInfo.notifyMessages)
    pub notifyMessages: ::std::vec::Vec<WebMessageInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:WebNotificationsInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebNotificationsInfo {
    fn default() -> &'a WebNotificationsInfo {
        <WebNotificationsInfo as ::protobuf::Message>::default_instance()
    }
}

impl WebNotificationsInfo {
    pub fn new() -> WebNotificationsInfo {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 2;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 unreadChats = 3;

    pub fn unreadChats(&self) -> u32 {
        self.unreadChats.unwrap_or(0)
    }

    pub fn clear_unreadChats(&mut self) {
        self.unreadChats = ::std::option::Option::None;
    }

    pub fn has_unreadChats(&self) -> bool {
        self.unreadChats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreadChats(&mut self, v: u32) {
        self.unreadChats = ::std::option::Option::Some(v);
    }

    // optional uint32 notifyMessageCount = 4;

    pub fn notifyMessageCount(&self) -> u32 {
        self.notifyMessageCount.unwrap_or(0)
    }

    pub fn clear_notifyMessageCount(&mut self) {
        self.notifyMessageCount = ::std::option::Option::None;
    }

    pub fn has_notifyMessageCount(&self) -> bool {
        self.notifyMessageCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifyMessageCount(&mut self, v: u32) {
        self.notifyMessageCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &WebNotificationsInfo| { &m.timestamp },
            |m: &mut WebNotificationsInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unreadChats",
            |m: &WebNotificationsInfo| { &m.unreadChats },
            |m: &mut WebNotificationsInfo| { &mut m.unreadChats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notifyMessageCount",
            |m: &WebNotificationsInfo| { &m.notifyMessageCount },
            |m: &mut WebNotificationsInfo| { &mut m.notifyMessageCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notifyMessages",
            |m: &WebNotificationsInfo| { &m.notifyMessages },
            |m: &mut WebNotificationsInfo| { &mut m.notifyMessages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebNotificationsInfo>(
            "WebNotificationsInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebNotificationsInfo {
    const NAME: &'static str = "WebNotificationsInfo";

    fn is_initialized(&self) -> bool {
        for v in &self.notifyMessages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.unreadChats = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.notifyMessageCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.notifyMessages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.unreadChats {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.notifyMessageCount {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.notifyMessages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.unreadChats {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.notifyMessageCount {
            os.write_uint32(4, v)?;
        }
        for v in &self.notifyMessages {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebNotificationsInfo {
        WebNotificationsInfo::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.unreadChats = ::std::option::Option::None;
        self.notifyMessageCount = ::std::option::Option::None;
        self.notifyMessages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebNotificationsInfo {
        static instance: WebNotificationsInfo = WebNotificationsInfo {
            timestamp: ::std::option::Option::None,
            unreadChats: ::std::option::Option::None,
            notifyMessageCount: ::std::option::Option::None,
            notifyMessages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebNotificationsInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebNotificationsInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebNotificationsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebNotificationsInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PaymentInfo)
pub struct PaymentInfo {
    // message fields
    // @@protoc_insertion_point(field:PaymentInfo.currencyDeprecated)
    pub currencyDeprecated: ::std::option::Option<::protobuf::EnumOrUnknown<payment_info::PaymentInfoCurrency>>,
    // @@protoc_insertion_point(field:PaymentInfo.amount1000)
    pub amount1000: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PaymentInfo.receiverJid)
    pub receiverJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:PaymentInfo.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<payment_info::PaymentInfoStatus>>,
    // @@protoc_insertion_point(field:PaymentInfo.transactionTimestamp)
    pub transactionTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PaymentInfo.requestMessageKey)
    pub requestMessageKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:PaymentInfo.expiryTimestamp)
    pub expiryTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PaymentInfo.futureproofed)
    pub futureproofed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:PaymentInfo.currency)
    pub currency: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:PaymentInfo.txnStatus)
    pub txnStatus: ::std::option::Option<::protobuf::EnumOrUnknown<payment_info::PaymentInfoTxnStatus>>,
    // @@protoc_insertion_point(field:PaymentInfo.useNoviFiatFormat)
    pub useNoviFiatFormat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:PaymentInfo.primaryAmount)
    pub primaryAmount: ::protobuf::MessageField<Money>,
    // @@protoc_insertion_point(field:PaymentInfo.exchangeAmount)
    pub exchangeAmount: ::protobuf::MessageField<Money>,
    // special fields
    // @@protoc_insertion_point(special_field:PaymentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentInfo {
    fn default() -> &'a PaymentInfo {
        <PaymentInfo as ::protobuf::Message>::default_instance()
    }
}

impl PaymentInfo {
    pub fn new() -> PaymentInfo {
        ::std::default::Default::default()
    }

    // optional .PaymentInfo.PaymentInfoCurrency currencyDeprecated = 1;

    pub fn currencyDeprecated(&self) -> payment_info::PaymentInfoCurrency {
        match self.currencyDeprecated {
            Some(e) => e.enum_value_or(payment_info::PaymentInfoCurrency::UNKNOWN_CURRENCY),
            None => payment_info::PaymentInfoCurrency::UNKNOWN_CURRENCY,
        }
    }

    pub fn clear_currencyDeprecated(&mut self) {
        self.currencyDeprecated = ::std::option::Option::None;
    }

    pub fn has_currencyDeprecated(&self) -> bool {
        self.currencyDeprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyDeprecated(&mut self, v: payment_info::PaymentInfoCurrency) {
        self.currencyDeprecated = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 amount1000 = 2;

    pub fn amount1000(&self) -> u64 {
        self.amount1000.unwrap_or(0)
    }

    pub fn clear_amount1000(&mut self) {
        self.amount1000 = ::std::option::Option::None;
    }

    pub fn has_amount1000(&self) -> bool {
        self.amount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount1000(&mut self, v: u64) {
        self.amount1000 = ::std::option::Option::Some(v);
    }

    // optional string receiverJid = 3;

    pub fn receiverJid(&self) -> &str {
        match self.receiverJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_receiverJid(&mut self) {
        self.receiverJid = ::std::option::Option::None;
    }

    pub fn has_receiverJid(&self) -> bool {
        self.receiverJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiverJid(&mut self, v: ::std::string::String) {
        self.receiverJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiverJid(&mut self) -> &mut ::std::string::String {
        if self.receiverJid.is_none() {
            self.receiverJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.receiverJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_receiverJid(&mut self) -> ::std::string::String {
        self.receiverJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .PaymentInfo.PaymentInfoStatus status = 4;

    pub fn status(&self) -> payment_info::PaymentInfoStatus {
        match self.status {
            Some(e) => e.enum_value_or(payment_info::PaymentInfoStatus::UNKNOWN_STATUS),
            None => payment_info::PaymentInfoStatus::UNKNOWN_STATUS,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: payment_info::PaymentInfoStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 transactionTimestamp = 5;

    pub fn transactionTimestamp(&self) -> u64 {
        self.transactionTimestamp.unwrap_or(0)
    }

    pub fn clear_transactionTimestamp(&mut self) {
        self.transactionTimestamp = ::std::option::Option::None;
    }

    pub fn has_transactionTimestamp(&self) -> bool {
        self.transactionTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transactionTimestamp(&mut self, v: u64) {
        self.transactionTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 expiryTimestamp = 7;

    pub fn expiryTimestamp(&self) -> u64 {
        self.expiryTimestamp.unwrap_or(0)
    }

    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = ::std::option::Option::None;
    }

    pub fn has_expiryTimestamp(&self) -> bool {
        self.expiryTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: u64) {
        self.expiryTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool futureproofed = 8;

    pub fn futureproofed(&self) -> bool {
        self.futureproofed.unwrap_or(false)
    }

    pub fn clear_futureproofed(&mut self) {
        self.futureproofed = ::std::option::Option::None;
    }

    pub fn has_futureproofed(&self) -> bool {
        self.futureproofed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_futureproofed(&mut self, v: bool) {
        self.futureproofed = ::std::option::Option::Some(v);
    }

    // optional string currency = 9;

    pub fn currency(&self) -> &str {
        match self.currency.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: ::std::string::String) {
        self.currency = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency(&mut self) -> &mut ::std::string::String {
        if self.currency.is_none() {
            self.currency = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currency.as_mut().unwrap()
    }

    // Take field
    pub fn take_currency(&mut self) -> ::std::string::String {
        self.currency.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .PaymentInfo.PaymentInfoTxnStatus txnStatus = 10;

    pub fn txnStatus(&self) -> payment_info::PaymentInfoTxnStatus {
        match self.txnStatus {
            Some(e) => e.enum_value_or(payment_info::PaymentInfoTxnStatus::UNKNOWN),
            None => payment_info::PaymentInfoTxnStatus::UNKNOWN,
        }
    }

    pub fn clear_txnStatus(&mut self) {
        self.txnStatus = ::std::option::Option::None;
    }

    pub fn has_txnStatus(&self) -> bool {
        self.txnStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnStatus(&mut self, v: payment_info::PaymentInfoTxnStatus) {
        self.txnStatus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool useNoviFiatFormat = 11;

    pub fn useNoviFiatFormat(&self) -> bool {
        self.useNoviFiatFormat.unwrap_or(false)
    }

    pub fn clear_useNoviFiatFormat(&mut self) {
        self.useNoviFiatFormat = ::std::option::Option::None;
    }

    pub fn has_useNoviFiatFormat(&self) -> bool {
        self.useNoviFiatFormat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_useNoviFiatFormat(&mut self, v: bool) {
        self.useNoviFiatFormat = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyDeprecated",
            |m: &PaymentInfo| { &m.currencyDeprecated },
            |m: &mut PaymentInfo| { &mut m.currencyDeprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount1000",
            |m: &PaymentInfo| { &m.amount1000 },
            |m: &mut PaymentInfo| { &mut m.amount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiverJid",
            |m: &PaymentInfo| { &m.receiverJid },
            |m: &mut PaymentInfo| { &mut m.receiverJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &PaymentInfo| { &m.status },
            |m: &mut PaymentInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transactionTimestamp",
            |m: &PaymentInfo| { &m.transactionTimestamp },
            |m: &mut PaymentInfo| { &mut m.transactionTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "requestMessageKey",
            |m: &PaymentInfo| { &m.requestMessageKey },
            |m: &mut PaymentInfo| { &mut m.requestMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiryTimestamp",
            |m: &PaymentInfo| { &m.expiryTimestamp },
            |m: &mut PaymentInfo| { &mut m.expiryTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "futureproofed",
            |m: &PaymentInfo| { &m.futureproofed },
            |m: &mut PaymentInfo| { &mut m.futureproofed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &PaymentInfo| { &m.currency },
            |m: &mut PaymentInfo| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txnStatus",
            |m: &PaymentInfo| { &m.txnStatus },
            |m: &mut PaymentInfo| { &mut m.txnStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "useNoviFiatFormat",
            |m: &PaymentInfo| { &m.useNoviFiatFormat },
            |m: &mut PaymentInfo| { &mut m.useNoviFiatFormat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Money>(
            "primaryAmount",
            |m: &PaymentInfo| { &m.primaryAmount },
            |m: &mut PaymentInfo| { &mut m.primaryAmount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Money>(
            "exchangeAmount",
            |m: &PaymentInfo| { &m.exchangeAmount },
            |m: &mut PaymentInfo| { &mut m.exchangeAmount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentInfo>(
            "PaymentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentInfo {
    const NAME: &'static str = "PaymentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.currencyDeprecated = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.amount1000 = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.receiverJid = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.transactionTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requestMessageKey)?;
                },
                56 => {
                    self.expiryTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.futureproofed = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.currency = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.txnStatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.useNoviFiatFormat = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.primaryAmount)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exchangeAmount)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currencyDeprecated {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.amount1000 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.receiverJid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.transactionTimestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expiryTimestamp {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.futureproofed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.currency.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.txnStatus {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.useNoviFiatFormat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.primaryAmount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.exchangeAmount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currencyDeprecated {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.amount1000 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.receiverJid.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.transactionTimestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.expiryTimestamp {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.futureproofed {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.currency.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.txnStatus {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.useNoviFiatFormat {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.primaryAmount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.exchangeAmount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentInfo {
        PaymentInfo::new()
    }

    fn clear(&mut self) {
        self.currencyDeprecated = ::std::option::Option::None;
        self.amount1000 = ::std::option::Option::None;
        self.receiverJid = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.transactionTimestamp = ::std::option::Option::None;
        self.requestMessageKey.clear();
        self.expiryTimestamp = ::std::option::Option::None;
        self.futureproofed = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.txnStatus = ::std::option::Option::None;
        self.useNoviFiatFormat = ::std::option::Option::None;
        self.primaryAmount.clear();
        self.exchangeAmount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentInfo {
        static instance: PaymentInfo = PaymentInfo {
            currencyDeprecated: ::std::option::Option::None,
            amount1000: ::std::option::Option::None,
            receiverJid: ::std::option::Option::None,
            status: ::std::option::Option::None,
            transactionTimestamp: ::std::option::Option::None,
            requestMessageKey: ::protobuf::MessageField::none(),
            expiryTimestamp: ::std::option::Option::None,
            futureproofed: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            txnStatus: ::std::option::Option::None,
            useNoviFiatFormat: ::std::option::Option::None,
            primaryAmount: ::protobuf::MessageField::none(),
            exchangeAmount: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PaymentInfo`
pub mod payment_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:PaymentInfo.PaymentInfoCurrency)
    pub enum PaymentInfoCurrency {
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoCurrency.UNKNOWN_CURRENCY)
        UNKNOWN_CURRENCY = 0,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoCurrency.INR)
        INR = 1,
    }

    impl ::protobuf::Enum for PaymentInfoCurrency {
        const NAME: &'static str = "PaymentInfoCurrency";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PaymentInfoCurrency> {
            match value {
                0 => ::std::option::Option::Some(PaymentInfoCurrency::UNKNOWN_CURRENCY),
                1 => ::std::option::Option::Some(PaymentInfoCurrency::INR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PaymentInfoCurrency] = &[
            PaymentInfoCurrency::UNKNOWN_CURRENCY,
            PaymentInfoCurrency::INR,
        ];
    }

    impl ::protobuf::EnumFull for PaymentInfoCurrency {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInfo.PaymentInfoCurrency").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PaymentInfoCurrency {
        fn default() -> Self {
            PaymentInfoCurrency::UNKNOWN_CURRENCY
        }
    }

    impl PaymentInfoCurrency {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentInfoCurrency>("PaymentInfo.PaymentInfoCurrency")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:PaymentInfo.PaymentInfoStatus)
    pub enum PaymentInfoStatus {
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.UNKNOWN_STATUS)
        UNKNOWN_STATUS = 0,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.PROCESSING)
        PROCESSING = 1,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.SENT)
        SENT = 2,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.NEED_TO_ACCEPT)
        NEED_TO_ACCEPT = 3,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.COMPLETE)
        COMPLETE = 4,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.COULD_NOT_COMPLETE)
        COULD_NOT_COMPLETE = 5,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.REFUNDED)
        REFUNDED = 6,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.EXPIRED)
        EXPIRED = 7,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.REJECTED)
        REJECTED = 8,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.CANCELLED)
        CANCELLED = 9,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.WAITING_FOR_PAYER)
        WAITING_FOR_PAYER = 10,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoStatus.WAITING)
        WAITING = 11,
    }

    impl ::protobuf::Enum for PaymentInfoStatus {
        const NAME: &'static str = "PaymentInfoStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PaymentInfoStatus> {
            match value {
                0 => ::std::option::Option::Some(PaymentInfoStatus::UNKNOWN_STATUS),
                1 => ::std::option::Option::Some(PaymentInfoStatus::PROCESSING),
                2 => ::std::option::Option::Some(PaymentInfoStatus::SENT),
                3 => ::std::option::Option::Some(PaymentInfoStatus::NEED_TO_ACCEPT),
                4 => ::std::option::Option::Some(PaymentInfoStatus::COMPLETE),
                5 => ::std::option::Option::Some(PaymentInfoStatus::COULD_NOT_COMPLETE),
                6 => ::std::option::Option::Some(PaymentInfoStatus::REFUNDED),
                7 => ::std::option::Option::Some(PaymentInfoStatus::EXPIRED),
                8 => ::std::option::Option::Some(PaymentInfoStatus::REJECTED),
                9 => ::std::option::Option::Some(PaymentInfoStatus::CANCELLED),
                10 => ::std::option::Option::Some(PaymentInfoStatus::WAITING_FOR_PAYER),
                11 => ::std::option::Option::Some(PaymentInfoStatus::WAITING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PaymentInfoStatus] = &[
            PaymentInfoStatus::UNKNOWN_STATUS,
            PaymentInfoStatus::PROCESSING,
            PaymentInfoStatus::SENT,
            PaymentInfoStatus::NEED_TO_ACCEPT,
            PaymentInfoStatus::COMPLETE,
            PaymentInfoStatus::COULD_NOT_COMPLETE,
            PaymentInfoStatus::REFUNDED,
            PaymentInfoStatus::EXPIRED,
            PaymentInfoStatus::REJECTED,
            PaymentInfoStatus::CANCELLED,
            PaymentInfoStatus::WAITING_FOR_PAYER,
            PaymentInfoStatus::WAITING,
        ];
    }

    impl ::protobuf::EnumFull for PaymentInfoStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInfo.PaymentInfoStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PaymentInfoStatus {
        fn default() -> Self {
            PaymentInfoStatus::UNKNOWN_STATUS
        }
    }

    impl PaymentInfoStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentInfoStatus>("PaymentInfo.PaymentInfoStatus")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:PaymentInfo.PaymentInfoTxnStatus)
    pub enum PaymentInfoTxnStatus {
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.PENDING_SETUP)
        PENDING_SETUP = 1,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.PENDING_RECEIVER_SETUP)
        PENDING_RECEIVER_SETUP = 2,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.INIT)
        INIT = 3,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.SUCCESS)
        SUCCESS = 4,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COMPLETED)
        COMPLETED = 5,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.FAILED)
        FAILED = 6,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.FAILED_RISK)
        FAILED_RISK = 7,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.FAILED_PROCESSING)
        FAILED_PROCESSING = 8,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.FAILED_RECEIVER_PROCESSING)
        FAILED_RECEIVER_PROCESSING = 9,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.FAILED_DA)
        FAILED_DA = 10,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.FAILED_DA_FINAL)
        FAILED_DA_FINAL = 11,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.REFUNDED_TXN)
        REFUNDED_TXN = 12,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.REFUND_FAILED)
        REFUND_FAILED = 13,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.REFUND_FAILED_PROCESSING)
        REFUND_FAILED_PROCESSING = 14,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.REFUND_FAILED_DA)
        REFUND_FAILED_DA = 15,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.EXPIRED_TXN)
        EXPIRED_TXN = 16,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.AUTH_CANCELED)
        AUTH_CANCELED = 17,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.AUTH_CANCEL_FAILED_PROCESSING)
        AUTH_CANCEL_FAILED_PROCESSING = 18,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.AUTH_CANCEL_FAILED)
        AUTH_CANCEL_FAILED = 19,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_INIT)
        COLLECT_INIT = 20,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_SUCCESS)
        COLLECT_SUCCESS = 21,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_FAILED)
        COLLECT_FAILED = 22,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_FAILED_RISK)
        COLLECT_FAILED_RISK = 23,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_REJECTED)
        COLLECT_REJECTED = 24,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_EXPIRED)
        COLLECT_EXPIRED = 25,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_CANCELED)
        COLLECT_CANCELED = 26,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.COLLECT_CANCELLING)
        COLLECT_CANCELLING = 27,
        // @@protoc_insertion_point(enum_value:PaymentInfo.PaymentInfoTxnStatus.IN_REVIEW)
        IN_REVIEW = 28,
    }

    impl ::protobuf::Enum for PaymentInfoTxnStatus {
        const NAME: &'static str = "PaymentInfoTxnStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PaymentInfoTxnStatus> {
            match value {
                0 => ::std::option::Option::Some(PaymentInfoTxnStatus::UNKNOWN),
                1 => ::std::option::Option::Some(PaymentInfoTxnStatus::PENDING_SETUP),
                2 => ::std::option::Option::Some(PaymentInfoTxnStatus::PENDING_RECEIVER_SETUP),
                3 => ::std::option::Option::Some(PaymentInfoTxnStatus::INIT),
                4 => ::std::option::Option::Some(PaymentInfoTxnStatus::SUCCESS),
                5 => ::std::option::Option::Some(PaymentInfoTxnStatus::COMPLETED),
                6 => ::std::option::Option::Some(PaymentInfoTxnStatus::FAILED),
                7 => ::std::option::Option::Some(PaymentInfoTxnStatus::FAILED_RISK),
                8 => ::std::option::Option::Some(PaymentInfoTxnStatus::FAILED_PROCESSING),
                9 => ::std::option::Option::Some(PaymentInfoTxnStatus::FAILED_RECEIVER_PROCESSING),
                10 => ::std::option::Option::Some(PaymentInfoTxnStatus::FAILED_DA),
                11 => ::std::option::Option::Some(PaymentInfoTxnStatus::FAILED_DA_FINAL),
                12 => ::std::option::Option::Some(PaymentInfoTxnStatus::REFUNDED_TXN),
                13 => ::std::option::Option::Some(PaymentInfoTxnStatus::REFUND_FAILED),
                14 => ::std::option::Option::Some(PaymentInfoTxnStatus::REFUND_FAILED_PROCESSING),
                15 => ::std::option::Option::Some(PaymentInfoTxnStatus::REFUND_FAILED_DA),
                16 => ::std::option::Option::Some(PaymentInfoTxnStatus::EXPIRED_TXN),
                17 => ::std::option::Option::Some(PaymentInfoTxnStatus::AUTH_CANCELED),
                18 => ::std::option::Option::Some(PaymentInfoTxnStatus::AUTH_CANCEL_FAILED_PROCESSING),
                19 => ::std::option::Option::Some(PaymentInfoTxnStatus::AUTH_CANCEL_FAILED),
                20 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_INIT),
                21 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_SUCCESS),
                22 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_FAILED),
                23 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_FAILED_RISK),
                24 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_REJECTED),
                25 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_EXPIRED),
                26 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_CANCELED),
                27 => ::std::option::Option::Some(PaymentInfoTxnStatus::COLLECT_CANCELLING),
                28 => ::std::option::Option::Some(PaymentInfoTxnStatus::IN_REVIEW),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PaymentInfoTxnStatus] = &[
            PaymentInfoTxnStatus::UNKNOWN,
            PaymentInfoTxnStatus::PENDING_SETUP,
            PaymentInfoTxnStatus::PENDING_RECEIVER_SETUP,
            PaymentInfoTxnStatus::INIT,
            PaymentInfoTxnStatus::SUCCESS,
            PaymentInfoTxnStatus::COMPLETED,
            PaymentInfoTxnStatus::FAILED,
            PaymentInfoTxnStatus::FAILED_RISK,
            PaymentInfoTxnStatus::FAILED_PROCESSING,
            PaymentInfoTxnStatus::FAILED_RECEIVER_PROCESSING,
            PaymentInfoTxnStatus::FAILED_DA,
            PaymentInfoTxnStatus::FAILED_DA_FINAL,
            PaymentInfoTxnStatus::REFUNDED_TXN,
            PaymentInfoTxnStatus::REFUND_FAILED,
            PaymentInfoTxnStatus::REFUND_FAILED_PROCESSING,
            PaymentInfoTxnStatus::REFUND_FAILED_DA,
            PaymentInfoTxnStatus::EXPIRED_TXN,
            PaymentInfoTxnStatus::AUTH_CANCELED,
            PaymentInfoTxnStatus::AUTH_CANCEL_FAILED_PROCESSING,
            PaymentInfoTxnStatus::AUTH_CANCEL_FAILED,
            PaymentInfoTxnStatus::COLLECT_INIT,
            PaymentInfoTxnStatus::COLLECT_SUCCESS,
            PaymentInfoTxnStatus::COLLECT_FAILED,
            PaymentInfoTxnStatus::COLLECT_FAILED_RISK,
            PaymentInfoTxnStatus::COLLECT_REJECTED,
            PaymentInfoTxnStatus::COLLECT_EXPIRED,
            PaymentInfoTxnStatus::COLLECT_CANCELED,
            PaymentInfoTxnStatus::COLLECT_CANCELLING,
            PaymentInfoTxnStatus::IN_REVIEW,
        ];
    }

    impl ::protobuf::EnumFull for PaymentInfoTxnStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInfo.PaymentInfoTxnStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PaymentInfoTxnStatus {
        fn default() -> Self {
            PaymentInfoTxnStatus::UNKNOWN
        }
    }

    impl PaymentInfoTxnStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PaymentInfoTxnStatus>("PaymentInfo.PaymentInfoTxnStatus")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WebMessageInfo)
pub struct WebMessageInfo {
    // message fields
    // @@protoc_insertion_point(field:WebMessageInfo.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:WebMessageInfo.message)
    pub message: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:WebMessageInfo.messageTimestamp)
    pub messageTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WebMessageInfo.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<web_message_info::WebMessageInfoStatus>>,
    // @@protoc_insertion_point(field:WebMessageInfo.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WebMessageInfo.messageC2STimestamp)
    pub messageC2STimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WebMessageInfo.ignore)
    pub ignore: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.starred)
    pub starred: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.pushName)
    pub pushName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WebMessageInfo.mediaCiphertextSha256)
    pub mediaCiphertextSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:WebMessageInfo.multicast)
    pub multicast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.urlText)
    pub urlText: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.urlNumber)
    pub urlNumber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.messageStubType)
    pub messageStubType: ::std::option::Option<::protobuf::EnumOrUnknown<web_message_info::WebMessageInfoStubType>>,
    // @@protoc_insertion_point(field:WebMessageInfo.clearMedia)
    pub clearMedia: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.messageStubParameters)
    pub messageStubParameters: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:WebMessageInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WebMessageInfo.labels)
    pub labels: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:WebMessageInfo.paymentInfo)
    pub paymentInfo: ::protobuf::MessageField<PaymentInfo>,
    // @@protoc_insertion_point(field:WebMessageInfo.finalLiveLocation)
    pub finalLiveLocation: ::protobuf::MessageField<LiveLocationMessage>,
    // @@protoc_insertion_point(field:WebMessageInfo.quotedPaymentInfo)
    pub quotedPaymentInfo: ::protobuf::MessageField<PaymentInfo>,
    // @@protoc_insertion_point(field:WebMessageInfo.ephemeralStartTimestamp)
    pub ephemeralStartTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WebMessageInfo.ephemeralDuration)
    pub ephemeralDuration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WebMessageInfo.ephemeralOffToOn)
    pub ephemeralOffToOn: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.ephemeralOutOfSync)
    pub ephemeralOutOfSync: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:WebMessageInfo.bizPrivacyStatus)
    pub bizPrivacyStatus: ::std::option::Option<::protobuf::EnumOrUnknown<web_message_info::WebMessageInfoBizPrivacyStatus>>,
    // @@protoc_insertion_point(field:WebMessageInfo.verifiedBizName)
    pub verifiedBizName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WebMessageInfo.mediaData)
    pub mediaData: ::protobuf::MessageField<MediaData>,
    // @@protoc_insertion_point(field:WebMessageInfo.photoChange)
    pub photoChange: ::protobuf::MessageField<PhotoChange>,
    // @@protoc_insertion_point(field:WebMessageInfo.userReceipt)
    pub userReceipt: ::std::vec::Vec<UserReceipt>,
    // @@protoc_insertion_point(field:WebMessageInfo.reactions)
    pub reactions: ::std::vec::Vec<Reaction>,
    // @@protoc_insertion_point(field:WebMessageInfo.quotedStickerData)
    pub quotedStickerData: ::protobuf::MessageField<MediaData>,
    // @@protoc_insertion_point(field:WebMessageInfo.futureproofData)
    pub futureproofData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:WebMessageInfo.statusPsa)
    pub statusPsa: ::protobuf::MessageField<StatusPSA>,
    // special fields
    // @@protoc_insertion_point(special_field:WebMessageInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebMessageInfo {
    fn default() -> &'a WebMessageInfo {
        <WebMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl WebMessageInfo {
    pub fn new() -> WebMessageInfo {
        ::std::default::Default::default()
    }

    // optional uint64 messageTimestamp = 3;

    pub fn messageTimestamp(&self) -> u64 {
        self.messageTimestamp.unwrap_or(0)
    }

    pub fn clear_messageTimestamp(&mut self) {
        self.messageTimestamp = ::std::option::Option::None;
    }

    pub fn has_messageTimestamp(&self) -> bool {
        self.messageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageTimestamp(&mut self, v: u64) {
        self.messageTimestamp = ::std::option::Option::Some(v);
    }

    // optional .WebMessageInfo.WebMessageInfoStatus status = 4;

    pub fn status(&self) -> web_message_info::WebMessageInfoStatus {
        match self.status {
            Some(e) => e.enum_value_or(web_message_info::WebMessageInfoStatus::ERROR),
            None => web_message_info::WebMessageInfoStatus::ERROR,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: web_message_info::WebMessageInfoStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string participant = 5;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 messageC2STimestamp = 6;

    pub fn messageC2STimestamp(&self) -> u64 {
        self.messageC2STimestamp.unwrap_or(0)
    }

    pub fn clear_messageC2STimestamp(&mut self) {
        self.messageC2STimestamp = ::std::option::Option::None;
    }

    pub fn has_messageC2STimestamp(&self) -> bool {
        self.messageC2STimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageC2STimestamp(&mut self, v: u64) {
        self.messageC2STimestamp = ::std::option::Option::Some(v);
    }

    // optional bool ignore = 16;

    pub fn ignore(&self) -> bool {
        self.ignore.unwrap_or(false)
    }

    pub fn clear_ignore(&mut self) {
        self.ignore = ::std::option::Option::None;
    }

    pub fn has_ignore(&self) -> bool {
        self.ignore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore(&mut self, v: bool) {
        self.ignore = ::std::option::Option::Some(v);
    }

    // optional bool starred = 17;

    pub fn starred(&self) -> bool {
        self.starred.unwrap_or(false)
    }

    pub fn clear_starred(&mut self) {
        self.starred = ::std::option::Option::None;
    }

    pub fn has_starred(&self) -> bool {
        self.starred.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starred(&mut self, v: bool) {
        self.starred = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 18;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }

    // optional string pushName = 19;

    pub fn pushName(&self) -> &str {
        match self.pushName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pushName(&mut self) {
        self.pushName = ::std::option::Option::None;
    }

    pub fn has_pushName(&self) -> bool {
        self.pushName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pushName(&mut self, v: ::std::string::String) {
        self.pushName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pushName(&mut self) -> &mut ::std::string::String {
        if self.pushName.is_none() {
            self.pushName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pushName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pushName(&mut self) -> ::std::string::String {
        self.pushName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes mediaCiphertextSha256 = 20;

    pub fn mediaCiphertextSha256(&self) -> &[u8] {
        match self.mediaCiphertextSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaCiphertextSha256(&mut self) {
        self.mediaCiphertextSha256 = ::std::option::Option::None;
    }

    pub fn has_mediaCiphertextSha256(&self) -> bool {
        self.mediaCiphertextSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaCiphertextSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaCiphertextSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaCiphertextSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaCiphertextSha256.is_none() {
            self.mediaCiphertextSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaCiphertextSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaCiphertextSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaCiphertextSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool multicast = 21;

    pub fn multicast(&self) -> bool {
        self.multicast.unwrap_or(false)
    }

    pub fn clear_multicast(&mut self) {
        self.multicast = ::std::option::Option::None;
    }

    pub fn has_multicast(&self) -> bool {
        self.multicast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast(&mut self, v: bool) {
        self.multicast = ::std::option::Option::Some(v);
    }

    // optional bool urlText = 22;

    pub fn urlText(&self) -> bool {
        self.urlText.unwrap_or(false)
    }

    pub fn clear_urlText(&mut self) {
        self.urlText = ::std::option::Option::None;
    }

    pub fn has_urlText(&self) -> bool {
        self.urlText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_urlText(&mut self, v: bool) {
        self.urlText = ::std::option::Option::Some(v);
    }

    // optional bool urlNumber = 23;

    pub fn urlNumber(&self) -> bool {
        self.urlNumber.unwrap_or(false)
    }

    pub fn clear_urlNumber(&mut self) {
        self.urlNumber = ::std::option::Option::None;
    }

    pub fn has_urlNumber(&self) -> bool {
        self.urlNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_urlNumber(&mut self, v: bool) {
        self.urlNumber = ::std::option::Option::Some(v);
    }

    // optional .WebMessageInfo.WebMessageInfoStubType messageStubType = 24;

    pub fn messageStubType(&self) -> web_message_info::WebMessageInfoStubType {
        match self.messageStubType {
            Some(e) => e.enum_value_or(web_message_info::WebMessageInfoStubType::UNKNOWN),
            None => web_message_info::WebMessageInfoStubType::UNKNOWN,
        }
    }

    pub fn clear_messageStubType(&mut self) {
        self.messageStubType = ::std::option::Option::None;
    }

    pub fn has_messageStubType(&self) -> bool {
        self.messageStubType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageStubType(&mut self, v: web_message_info::WebMessageInfoStubType) {
        self.messageStubType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool clearMedia = 25;

    pub fn clearMedia(&self) -> bool {
        self.clearMedia.unwrap_or(false)
    }

    pub fn clear_clearMedia(&mut self) {
        self.clearMedia = ::std::option::Option::None;
    }

    pub fn has_clearMedia(&self) -> bool {
        self.clearMedia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clearMedia(&mut self, v: bool) {
        self.clearMedia = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 27;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint64 ephemeralStartTimestamp = 32;

    pub fn ephemeralStartTimestamp(&self) -> u64 {
        self.ephemeralStartTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralStartTimestamp(&mut self) {
        self.ephemeralStartTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralStartTimestamp(&self) -> bool {
        self.ephemeralStartTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralStartTimestamp(&mut self, v: u64) {
        self.ephemeralStartTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ephemeralDuration = 33;

    pub fn ephemeralDuration(&self) -> u32 {
        self.ephemeralDuration.unwrap_or(0)
    }

    pub fn clear_ephemeralDuration(&mut self) {
        self.ephemeralDuration = ::std::option::Option::None;
    }

    pub fn has_ephemeralDuration(&self) -> bool {
        self.ephemeralDuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralDuration(&mut self, v: u32) {
        self.ephemeralDuration = ::std::option::Option::Some(v);
    }

    // optional bool ephemeralOffToOn = 34;

    pub fn ephemeralOffToOn(&self) -> bool {
        self.ephemeralOffToOn.unwrap_or(false)
    }

    pub fn clear_ephemeralOffToOn(&mut self) {
        self.ephemeralOffToOn = ::std::option::Option::None;
    }

    pub fn has_ephemeralOffToOn(&self) -> bool {
        self.ephemeralOffToOn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralOffToOn(&mut self, v: bool) {
        self.ephemeralOffToOn = ::std::option::Option::Some(v);
    }

    // optional bool ephemeralOutOfSync = 35;

    pub fn ephemeralOutOfSync(&self) -> bool {
        self.ephemeralOutOfSync.unwrap_or(false)
    }

    pub fn clear_ephemeralOutOfSync(&mut self) {
        self.ephemeralOutOfSync = ::std::option::Option::None;
    }

    pub fn has_ephemeralOutOfSync(&self) -> bool {
        self.ephemeralOutOfSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralOutOfSync(&mut self, v: bool) {
        self.ephemeralOutOfSync = ::std::option::Option::Some(v);
    }

    // optional .WebMessageInfo.WebMessageInfoBizPrivacyStatus bizPrivacyStatus = 36;

    pub fn bizPrivacyStatus(&self) -> web_message_info::WebMessageInfoBizPrivacyStatus {
        match self.bizPrivacyStatus {
            Some(e) => e.enum_value_or(web_message_info::WebMessageInfoBizPrivacyStatus::E2EE),
            None => web_message_info::WebMessageInfoBizPrivacyStatus::E2EE,
        }
    }

    pub fn clear_bizPrivacyStatus(&mut self) {
        self.bizPrivacyStatus = ::std::option::Option::None;
    }

    pub fn has_bizPrivacyStatus(&self) -> bool {
        self.bizPrivacyStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bizPrivacyStatus(&mut self, v: web_message_info::WebMessageInfoBizPrivacyStatus) {
        self.bizPrivacyStatus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string verifiedBizName = 37;

    pub fn verifiedBizName(&self) -> &str {
        match self.verifiedBizName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_verifiedBizName(&mut self) {
        self.verifiedBizName = ::std::option::Option::None;
    }

    pub fn has_verifiedBizName(&self) -> bool {
        self.verifiedBizName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verifiedBizName(&mut self, v: ::std::string::String) {
        self.verifiedBizName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verifiedBizName(&mut self) -> &mut ::std::string::String {
        if self.verifiedBizName.is_none() {
            self.verifiedBizName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.verifiedBizName.as_mut().unwrap()
    }

    // Take field
    pub fn take_verifiedBizName(&mut self) -> ::std::string::String {
        self.verifiedBizName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes futureproofData = 43;

    pub fn futureproofData(&self) -> &[u8] {
        match self.futureproofData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_futureproofData(&mut self) {
        self.futureproofData = ::std::option::Option::None;
    }

    pub fn has_futureproofData(&self) -> bool {
        self.futureproofData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_futureproofData(&mut self, v: ::std::vec::Vec<u8>) {
        self.futureproofData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_futureproofData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.futureproofData.is_none() {
            self.futureproofData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.futureproofData.as_mut().unwrap()
    }

    // Take field
    pub fn take_futureproofData(&mut self) -> ::std::vec::Vec<u8> {
        self.futureproofData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(35);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &WebMessageInfo| { &m.key },
            |m: &mut WebMessageInfo| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &WebMessageInfo| { &m.message },
            |m: &mut WebMessageInfo| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageTimestamp",
            |m: &WebMessageInfo| { &m.messageTimestamp },
            |m: &mut WebMessageInfo| { &mut m.messageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &WebMessageInfo| { &m.status },
            |m: &mut WebMessageInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &WebMessageInfo| { &m.participant },
            |m: &mut WebMessageInfo| { &mut m.participant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageC2STimestamp",
            |m: &WebMessageInfo| { &m.messageC2STimestamp },
            |m: &mut WebMessageInfo| { &mut m.messageC2STimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore",
            |m: &WebMessageInfo| { &m.ignore },
            |m: &mut WebMessageInfo| { &mut m.ignore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "starred",
            |m: &WebMessageInfo| { &m.starred },
            |m: &mut WebMessageInfo| { &mut m.starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast",
            |m: &WebMessageInfo| { &m.broadcast },
            |m: &mut WebMessageInfo| { &mut m.broadcast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pushName",
            |m: &WebMessageInfo| { &m.pushName },
            |m: &mut WebMessageInfo| { &mut m.pushName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaCiphertextSha256",
            |m: &WebMessageInfo| { &m.mediaCiphertextSha256 },
            |m: &mut WebMessageInfo| { &mut m.mediaCiphertextSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multicast",
            |m: &WebMessageInfo| { &m.multicast },
            |m: &mut WebMessageInfo| { &mut m.multicast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "urlText",
            |m: &WebMessageInfo| { &m.urlText },
            |m: &mut WebMessageInfo| { &mut m.urlText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "urlNumber",
            |m: &WebMessageInfo| { &m.urlNumber },
            |m: &mut WebMessageInfo| { &mut m.urlNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageStubType",
            |m: &WebMessageInfo| { &m.messageStubType },
            |m: &mut WebMessageInfo| { &mut m.messageStubType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clearMedia",
            |m: &WebMessageInfo| { &m.clearMedia },
            |m: &mut WebMessageInfo| { &mut m.clearMedia },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messageStubParameters",
            |m: &WebMessageInfo| { &m.messageStubParameters },
            |m: &mut WebMessageInfo| { &mut m.messageStubParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &WebMessageInfo| { &m.duration },
            |m: &mut WebMessageInfo| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &WebMessageInfo| { &m.labels },
            |m: &mut WebMessageInfo| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentInfo>(
            "paymentInfo",
            |m: &WebMessageInfo| { &m.paymentInfo },
            |m: &mut WebMessageInfo| { &mut m.paymentInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LiveLocationMessage>(
            "finalLiveLocation",
            |m: &WebMessageInfo| { &m.finalLiveLocation },
            |m: &mut WebMessageInfo| { &mut m.finalLiveLocation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentInfo>(
            "quotedPaymentInfo",
            |m: &WebMessageInfo| { &m.quotedPaymentInfo },
            |m: &mut WebMessageInfo| { &mut m.quotedPaymentInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralStartTimestamp",
            |m: &WebMessageInfo| { &m.ephemeralStartTimestamp },
            |m: &mut WebMessageInfo| { &mut m.ephemeralStartTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralDuration",
            |m: &WebMessageInfo| { &m.ephemeralDuration },
            |m: &mut WebMessageInfo| { &mut m.ephemeralDuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralOffToOn",
            |m: &WebMessageInfo| { &m.ephemeralOffToOn },
            |m: &mut WebMessageInfo| { &mut m.ephemeralOffToOn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralOutOfSync",
            |m: &WebMessageInfo| { &m.ephemeralOutOfSync },
            |m: &mut WebMessageInfo| { &mut m.ephemeralOutOfSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bizPrivacyStatus",
            |m: &WebMessageInfo| { &m.bizPrivacyStatus },
            |m: &mut WebMessageInfo| { &mut m.bizPrivacyStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verifiedBizName",
            |m: &WebMessageInfo| { &m.verifiedBizName },
            |m: &mut WebMessageInfo| { &mut m.verifiedBizName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaData>(
            "mediaData",
            |m: &WebMessageInfo| { &m.mediaData },
            |m: &mut WebMessageInfo| { &mut m.mediaData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PhotoChange>(
            "photoChange",
            |m: &WebMessageInfo| { &m.photoChange },
            |m: &mut WebMessageInfo| { &mut m.photoChange },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userReceipt",
            |m: &WebMessageInfo| { &m.userReceipt },
            |m: &mut WebMessageInfo| { &mut m.userReceipt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reactions",
            |m: &WebMessageInfo| { &m.reactions },
            |m: &mut WebMessageInfo| { &mut m.reactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaData>(
            "quotedStickerData",
            |m: &WebMessageInfo| { &m.quotedStickerData },
            |m: &mut WebMessageInfo| { &mut m.quotedStickerData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "futureproofData",
            |m: &WebMessageInfo| { &m.futureproofData },
            |m: &mut WebMessageInfo| { &mut m.futureproofData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatusPSA>(
            "statusPsa",
            |m: &WebMessageInfo| { &m.statusPsa },
            |m: &mut WebMessageInfo| { &mut m.statusPsa },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebMessageInfo>(
            "WebMessageInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebMessageInfo {
    const NAME: &'static str = "WebMessageInfo";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paymentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finalLiveLocation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quotedPaymentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mediaData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.photoChange {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userReceipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quotedStickerData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statusPsa {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                24 => {
                    self.messageTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.messageC2STimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                128 => {
                    self.ignore = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.starred = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                154 => {
                    self.pushName = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.mediaCiphertextSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                168 => {
                    self.multicast = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.urlText = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.urlNumber = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.messageStubType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.clearMedia = ::std::option::Option::Some(is.read_bool()?);
                },
                210 => {
                    self.messageStubParameters.push(is.read_string()?);
                },
                216 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                226 => {
                    self.labels.push(is.read_string()?);
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paymentInfo)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.finalLiveLocation)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedPaymentInfo)?;
                },
                256 => {
                    self.ephemeralStartTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                264 => {
                    self.ephemeralDuration = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.ephemeralOffToOn = ::std::option::Option::Some(is.read_bool()?);
                },
                280 => {
                    self.ephemeralOutOfSync = ::std::option::Option::Some(is.read_bool()?);
                },
                288 => {
                    self.bizPrivacyStatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                298 => {
                    self.verifiedBizName = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mediaData)?;
                },
                314 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.photoChange)?;
                },
                322 => {
                    self.userReceipt.push(is.read_message()?);
                },
                330 => {
                    self.reactions.push(is.read_message()?);
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedStickerData)?;
                },
                346 => {
                    self.futureproofData = ::std::option::Option::Some(is.read_bytes()?);
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.statusPsa)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.messageTimestamp {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.messageC2STimestamp {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.ignore {
            my_size += 2 + 1;
        }
        if let Some(v) = self.starred {
            my_size += 2 + 1;
        }
        if let Some(v) = self.broadcast {
            my_size += 2 + 1;
        }
        if let Some(v) = self.pushName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.mediaCiphertextSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        if let Some(v) = self.multicast {
            my_size += 2 + 1;
        }
        if let Some(v) = self.urlText {
            my_size += 2 + 1;
        }
        if let Some(v) = self.urlNumber {
            my_size += 2 + 1;
        }
        if let Some(v) = self.messageStubType {
            my_size += ::protobuf::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.clearMedia {
            my_size += 2 + 1;
        }
        for value in &self.messageStubParameters {
            my_size += ::protobuf::rt::string_size(26, &value);
        };
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(28, &value);
        };
        if let Some(v) = self.paymentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.finalLiveLocation.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quotedPaymentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ephemeralStartTimestamp {
            my_size += ::protobuf::rt::uint64_size(32, v);
        }
        if let Some(v) = self.ephemeralDuration {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.ephemeralOffToOn {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ephemeralOutOfSync {
            my_size += 2 + 1;
        }
        if let Some(v) = self.bizPrivacyStatus {
            my_size += ::protobuf::rt::int32_size(36, v.value());
        }
        if let Some(v) = self.verifiedBizName.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.mediaData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.photoChange.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.userReceipt {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reactions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.quotedStickerData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.futureproofData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(43, &v);
        }
        if let Some(v) = self.statusPsa.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.messageTimestamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.messageC2STimestamp {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.ignore {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.starred {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.pushName.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.mediaCiphertextSha256.as_ref() {
            os.write_bytes(20, v)?;
        }
        if let Some(v) = self.multicast {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.urlText {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.urlNumber {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.messageStubType {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.clearMedia {
            os.write_bool(25, v)?;
        }
        for v in &self.messageStubParameters {
            os.write_string(26, &v)?;
        };
        if let Some(v) = self.duration {
            os.write_uint32(27, v)?;
        }
        for v in &self.labels {
            os.write_string(28, &v)?;
        };
        if let Some(v) = self.paymentInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.finalLiveLocation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.quotedPaymentInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.ephemeralStartTimestamp {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.ephemeralDuration {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.ephemeralOffToOn {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.ephemeralOutOfSync {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.bizPrivacyStatus {
            os.write_enum(36, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.verifiedBizName.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.mediaData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        if let Some(v) = self.photoChange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        for v in &self.userReceipt {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        };
        for v in &self.reactions {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        if let Some(v) = self.quotedStickerData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.futureproofData.as_ref() {
            os.write_bytes(43, v)?;
        }
        if let Some(v) = self.statusPsa.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebMessageInfo {
        WebMessageInfo::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.message.clear();
        self.messageTimestamp = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.messageC2STimestamp = ::std::option::Option::None;
        self.ignore = ::std::option::Option::None;
        self.starred = ::std::option::Option::None;
        self.broadcast = ::std::option::Option::None;
        self.pushName = ::std::option::Option::None;
        self.mediaCiphertextSha256 = ::std::option::Option::None;
        self.multicast = ::std::option::Option::None;
        self.urlText = ::std::option::Option::None;
        self.urlNumber = ::std::option::Option::None;
        self.messageStubType = ::std::option::Option::None;
        self.clearMedia = ::std::option::Option::None;
        self.messageStubParameters.clear();
        self.duration = ::std::option::Option::None;
        self.labels.clear();
        self.paymentInfo.clear();
        self.finalLiveLocation.clear();
        self.quotedPaymentInfo.clear();
        self.ephemeralStartTimestamp = ::std::option::Option::None;
        self.ephemeralDuration = ::std::option::Option::None;
        self.ephemeralOffToOn = ::std::option::Option::None;
        self.ephemeralOutOfSync = ::std::option::Option::None;
        self.bizPrivacyStatus = ::std::option::Option::None;
        self.verifiedBizName = ::std::option::Option::None;
        self.mediaData.clear();
        self.photoChange.clear();
        self.userReceipt.clear();
        self.reactions.clear();
        self.quotedStickerData.clear();
        self.futureproofData = ::std::option::Option::None;
        self.statusPsa.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebMessageInfo {
        static instance: WebMessageInfo = WebMessageInfo {
            key: ::protobuf::MessageField::none(),
            message: ::protobuf::MessageField::none(),
            messageTimestamp: ::std::option::Option::None,
            status: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            messageC2STimestamp: ::std::option::Option::None,
            ignore: ::std::option::Option::None,
            starred: ::std::option::Option::None,
            broadcast: ::std::option::Option::None,
            pushName: ::std::option::Option::None,
            mediaCiphertextSha256: ::std::option::Option::None,
            multicast: ::std::option::Option::None,
            urlText: ::std::option::Option::None,
            urlNumber: ::std::option::Option::None,
            messageStubType: ::std::option::Option::None,
            clearMedia: ::std::option::Option::None,
            messageStubParameters: ::std::vec::Vec::new(),
            duration: ::std::option::Option::None,
            labels: ::std::vec::Vec::new(),
            paymentInfo: ::protobuf::MessageField::none(),
            finalLiveLocation: ::protobuf::MessageField::none(),
            quotedPaymentInfo: ::protobuf::MessageField::none(),
            ephemeralStartTimestamp: ::std::option::Option::None,
            ephemeralDuration: ::std::option::Option::None,
            ephemeralOffToOn: ::std::option::Option::None,
            ephemeralOutOfSync: ::std::option::Option::None,
            bizPrivacyStatus: ::std::option::Option::None,
            verifiedBizName: ::std::option::Option::None,
            mediaData: ::protobuf::MessageField::none(),
            photoChange: ::protobuf::MessageField::none(),
            userReceipt: ::std::vec::Vec::new(),
            reactions: ::std::vec::Vec::new(),
            quotedStickerData: ::protobuf::MessageField::none(),
            futureproofData: ::std::option::Option::None,
            statusPsa: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebMessageInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebMessageInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebMessageInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebMessageInfo`
pub mod web_message_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WebMessageInfo.WebMessageInfoStatus)
    pub enum WebMessageInfoStatus {
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStatus.ERROR)
        ERROR = 0,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStatus.PENDING)
        PENDING = 1,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStatus.SERVER_ACK)
        SERVER_ACK = 2,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStatus.DELIVERY_ACK)
        DELIVERY_ACK = 3,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStatus.READ)
        READ = 4,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStatus.PLAYED)
        PLAYED = 5,
    }

    impl ::protobuf::Enum for WebMessageInfoStatus {
        const NAME: &'static str = "WebMessageInfoStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WebMessageInfoStatus> {
            match value {
                0 => ::std::option::Option::Some(WebMessageInfoStatus::ERROR),
                1 => ::std::option::Option::Some(WebMessageInfoStatus::PENDING),
                2 => ::std::option::Option::Some(WebMessageInfoStatus::SERVER_ACK),
                3 => ::std::option::Option::Some(WebMessageInfoStatus::DELIVERY_ACK),
                4 => ::std::option::Option::Some(WebMessageInfoStatus::READ),
                5 => ::std::option::Option::Some(WebMessageInfoStatus::PLAYED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WebMessageInfoStatus] = &[
            WebMessageInfoStatus::ERROR,
            WebMessageInfoStatus::PENDING,
            WebMessageInfoStatus::SERVER_ACK,
            WebMessageInfoStatus::DELIVERY_ACK,
            WebMessageInfoStatus::READ,
            WebMessageInfoStatus::PLAYED,
        ];
    }

    impl ::protobuf::EnumFull for WebMessageInfoStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebMessageInfo.WebMessageInfoStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WebMessageInfoStatus {
        fn default() -> Self {
            WebMessageInfoStatus::ERROR
        }
    }

    impl WebMessageInfoStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebMessageInfoStatus>("WebMessageInfo.WebMessageInfoStatus")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WebMessageInfo.WebMessageInfoStubType)
    pub enum WebMessageInfoStubType {
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.REVOKE)
        REVOKE = 1,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.CIPHERTEXT)
        CIPHERTEXT = 2,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.FUTUREPROOF)
        FUTUREPROOF = 3,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.NON_VERIFIED_TRANSITION)
        NON_VERIFIED_TRANSITION = 4,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.UNVERIFIED_TRANSITION)
        UNVERIFIED_TRANSITION = 5,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION)
        VERIFIED_TRANSITION = 6,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_LOW_UNKNOWN)
        VERIFIED_LOW_UNKNOWN = 7,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_HIGH)
        VERIFIED_HIGH = 8,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_INITIAL_UNKNOWN)
        VERIFIED_INITIAL_UNKNOWN = 9,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_INITIAL_LOW)
        VERIFIED_INITIAL_LOW = 10,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_INITIAL_HIGH)
        VERIFIED_INITIAL_HIGH = 11,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_ANY_TO_NONE)
        VERIFIED_TRANSITION_ANY_TO_NONE = 12,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_ANY_TO_HIGH)
        VERIFIED_TRANSITION_ANY_TO_HIGH = 13,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_HIGH_TO_LOW)
        VERIFIED_TRANSITION_HIGH_TO_LOW = 14,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_HIGH_TO_UNKNOWN)
        VERIFIED_TRANSITION_HIGH_TO_UNKNOWN = 15,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_UNKNOWN_TO_LOW)
        VERIFIED_TRANSITION_UNKNOWN_TO_LOW = 16,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_LOW_TO_UNKNOWN)
        VERIFIED_TRANSITION_LOW_TO_UNKNOWN = 17,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_NONE_TO_LOW)
        VERIFIED_TRANSITION_NONE_TO_LOW = 18,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VERIFIED_TRANSITION_NONE_TO_UNKNOWN)
        VERIFIED_TRANSITION_NONE_TO_UNKNOWN = 19,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CREATE)
        GROUP_CREATE = 20,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CHANGE_SUBJECT)
        GROUP_CHANGE_SUBJECT = 21,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CHANGE_ICON)
        GROUP_CHANGE_ICON = 22,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CHANGE_INVITE_LINK)
        GROUP_CHANGE_INVITE_LINK = 23,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CHANGE_DESCRIPTION)
        GROUP_CHANGE_DESCRIPTION = 24,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CHANGE_RESTRICT)
        GROUP_CHANGE_RESTRICT = 25,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CHANGE_ANNOUNCE)
        GROUP_CHANGE_ANNOUNCE = 26,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_ADD)
        GROUP_PARTICIPANT_ADD = 27,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_REMOVE)
        GROUP_PARTICIPANT_REMOVE = 28,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_PROMOTE)
        GROUP_PARTICIPANT_PROMOTE = 29,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_DEMOTE)
        GROUP_PARTICIPANT_DEMOTE = 30,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_INVITE)
        GROUP_PARTICIPANT_INVITE = 31,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_LEAVE)
        GROUP_PARTICIPANT_LEAVE = 32,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_CHANGE_NUMBER)
        GROUP_PARTICIPANT_CHANGE_NUMBER = 33,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BROADCAST_CREATE)
        BROADCAST_CREATE = 34,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BROADCAST_ADD)
        BROADCAST_ADD = 35,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BROADCAST_REMOVE)
        BROADCAST_REMOVE = 36,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GENERIC_NOTIFICATION)
        GENERIC_NOTIFICATION = 37,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.E2E_IDENTITY_CHANGED)
        E2E_IDENTITY_CHANGED = 38,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.E2E_ENCRYPTED)
        E2E_ENCRYPTED = 39,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.CALL_MISSED_VOICE)
        CALL_MISSED_VOICE = 40,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.CALL_MISSED_VIDEO)
        CALL_MISSED_VIDEO = 41,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.INDIVIDUAL_CHANGE_NUMBER)
        INDIVIDUAL_CHANGE_NUMBER = 42,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_DELETE)
        GROUP_DELETE = 43,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE)
        GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE = 44,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.CALL_MISSED_GROUP_VOICE)
        CALL_MISSED_GROUP_VOICE = 45,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.CALL_MISSED_GROUP_VIDEO)
        CALL_MISSED_GROUP_VIDEO = 46,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_CIPHERTEXT)
        PAYMENT_CIPHERTEXT = 47,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_FUTUREPROOF)
        PAYMENT_FUTUREPROOF = 48,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED)
        PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED = 49,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED)
        PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED = 50,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED)
        PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED = 51,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP)
        PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP = 52,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP)
        PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP = 53,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER)
        PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER = 54,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_ACTION_SEND_PAYMENT_REMINDER)
        PAYMENT_ACTION_SEND_PAYMENT_REMINDER = 55,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_ACTION_SEND_PAYMENT_INVITATION)
        PAYMENT_ACTION_SEND_PAYMENT_INVITATION = 56,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_ACTION_REQUEST_DECLINED)
        PAYMENT_ACTION_REQUEST_DECLINED = 57,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_ACTION_REQUEST_EXPIRED)
        PAYMENT_ACTION_REQUEST_EXPIRED = 58,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.PAYMENT_ACTION_REQUEST_CANCELLED)
        PAYMENT_ACTION_REQUEST_CANCELLED = 59,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM)
        BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM = 60,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP)
        BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP = 61,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_INTRO_TOP)
        BIZ_INTRO_TOP = 62,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_INTRO_BOTTOM)
        BIZ_INTRO_BOTTOM = 63,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_NAME_CHANGE)
        BIZ_NAME_CHANGE = 64,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_MOVE_TO_CONSUMER_APP)
        BIZ_MOVE_TO_CONSUMER_APP = 65,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_TWO_TIER_MIGRATION_TOP)
        BIZ_TWO_TIER_MIGRATION_TOP = 66,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_TWO_TIER_MIGRATION_BOTTOM)
        BIZ_TWO_TIER_MIGRATION_BOTTOM = 67,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.OVERSIZED)
        OVERSIZED = 68,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CHANGE_NO_FREQUENTLY_FORWARDED)
        GROUP_CHANGE_NO_FREQUENTLY_FORWARDED = 69,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_V4_ADD_INVITE_SENT)
        GROUP_V4_ADD_INVITE_SENT = 70,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_PARTICIPANT_ADD_REQUEST_JOIN)
        GROUP_PARTICIPANT_ADD_REQUEST_JOIN = 71,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.CHANGE_EPHEMERAL_SETTING)
        CHANGE_EPHEMERAL_SETTING = 72,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.E2E_DEVICE_CHANGED)
        E2E_DEVICE_CHANGED = 73,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.VIEWED_ONCE)
        VIEWED_ONCE = 74,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.E2E_ENCRYPTED_NOW)
        E2E_ENCRYPTED_NOW = 75,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_TO_BSP_PREMISE)
        BLUE_MSG_BSP_FB_TO_BSP_PREMISE = 76,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_TO_SELF_FB)
        BLUE_MSG_BSP_FB_TO_SELF_FB = 77,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_TO_SELF_PREMISE)
        BLUE_MSG_BSP_FB_TO_SELF_PREMISE = 78,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_UNVERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED = 79,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 80,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_VERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED = 81,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 82,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE)
        BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE = 83,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_PREMISE_UNVERIFIED = 84,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED)
        BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 85,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_PREMISE_VERIFIED)
        BLUE_MSG_BSP_PREMISE_VERIFIED = 86,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 87,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED = 88,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED = 89,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED = 90,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED = 91,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_TO_BSP_PREMISE)
        BLUE_MSG_SELF_FB_TO_BSP_PREMISE = 92,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_TO_SELF_PREMISE)
        BLUE_MSG_SELF_FB_TO_SELF_PREMISE = 93,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_UNVERIFIED)
        BLUE_MSG_SELF_FB_UNVERIFIED = 94,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED)
        BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 95,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_VERIFIED)
        BLUE_MSG_SELF_FB_VERIFIED = 96,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 97,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE)
        BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE = 98,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_SELF_PREMISE_UNVERIFIED = 99,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_PREMISE_VERIFIED)
        BLUE_MSG_SELF_PREMISE_VERIFIED = 100,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_TO_BSP_FB)
        BLUE_MSG_TO_BSP_FB = 101,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_TO_CONSUMER)
        BLUE_MSG_TO_CONSUMER = 102,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_TO_SELF_FB)
        BLUE_MSG_TO_SELF_FB = 103,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED = 104,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 105,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED = 106,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_UNVERIFIED_TO_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_VERIFIED = 107,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED = 108,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 109,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED = 110,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_VERIFIED_TO_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_UNVERIFIED = 111,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 112,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED = 113,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 114,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED = 115,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED)
        BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 116,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 117,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.E2E_IDENTITY_UNAVAILABLE)
        E2E_IDENTITY_UNAVAILABLE = 118,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CREATING)
        GROUP_CREATING = 119,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_CREATE_FAILED)
        GROUP_CREATE_FAILED = 120,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_BOUNCED)
        GROUP_BOUNCED = 121,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BLOCK_CONTACT)
        BLOCK_CONTACT = 122,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.EPHEMERAL_SETTING_NOT_APPLIED)
        EPHEMERAL_SETTING_NOT_APPLIED = 123,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.SYNC_FAILED)
        SYNC_FAILED = 124,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.SYNCING)
        SYNCING = 125,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_PRIVACY_MODE_INIT_FB)
        BIZ_PRIVACY_MODE_INIT_FB = 126,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_PRIVACY_MODE_INIT_BSP)
        BIZ_PRIVACY_MODE_INIT_BSP = 127,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_PRIVACY_MODE_TO_FB)
        BIZ_PRIVACY_MODE_TO_FB = 128,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.BIZ_PRIVACY_MODE_TO_BSP)
        BIZ_PRIVACY_MODE_TO_BSP = 129,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.DISAPPEARING_MODE)
        DISAPPEARING_MODE = 130,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.E2E_DEVICE_FETCH_FAILED)
        E2E_DEVICE_FETCH_FAILED = 131,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.ADMIN_REVOKE)
        ADMIN_REVOKE = 132,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoStubType.GROUP_INVITE_LINK_GROWTH_LOCKED)
        GROUP_INVITE_LINK_GROWTH_LOCKED = 133,
    }

    impl ::protobuf::Enum for WebMessageInfoStubType {
        const NAME: &'static str = "WebMessageInfoStubType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WebMessageInfoStubType> {
            match value {
                0 => ::std::option::Option::Some(WebMessageInfoStubType::UNKNOWN),
                1 => ::std::option::Option::Some(WebMessageInfoStubType::REVOKE),
                2 => ::std::option::Option::Some(WebMessageInfoStubType::CIPHERTEXT),
                3 => ::std::option::Option::Some(WebMessageInfoStubType::FUTUREPROOF),
                4 => ::std::option::Option::Some(WebMessageInfoStubType::NON_VERIFIED_TRANSITION),
                5 => ::std::option::Option::Some(WebMessageInfoStubType::UNVERIFIED_TRANSITION),
                6 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION),
                7 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_LOW_UNKNOWN),
                8 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_HIGH),
                9 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_INITIAL_UNKNOWN),
                10 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_INITIAL_LOW),
                11 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_INITIAL_HIGH),
                12 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_ANY_TO_NONE),
                13 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_ANY_TO_HIGH),
                14 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_HIGH_TO_LOW),
                15 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_HIGH_TO_UNKNOWN),
                16 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_UNKNOWN_TO_LOW),
                17 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_LOW_TO_UNKNOWN),
                18 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_NONE_TO_LOW),
                19 => ::std::option::Option::Some(WebMessageInfoStubType::VERIFIED_TRANSITION_NONE_TO_UNKNOWN),
                20 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CREATE),
                21 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CHANGE_SUBJECT),
                22 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CHANGE_ICON),
                23 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CHANGE_INVITE_LINK),
                24 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CHANGE_DESCRIPTION),
                25 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CHANGE_RESTRICT),
                26 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CHANGE_ANNOUNCE),
                27 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_ADD),
                28 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_REMOVE),
                29 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_PROMOTE),
                30 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_DEMOTE),
                31 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_INVITE),
                32 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_LEAVE),
                33 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_CHANGE_NUMBER),
                34 => ::std::option::Option::Some(WebMessageInfoStubType::BROADCAST_CREATE),
                35 => ::std::option::Option::Some(WebMessageInfoStubType::BROADCAST_ADD),
                36 => ::std::option::Option::Some(WebMessageInfoStubType::BROADCAST_REMOVE),
                37 => ::std::option::Option::Some(WebMessageInfoStubType::GENERIC_NOTIFICATION),
                38 => ::std::option::Option::Some(WebMessageInfoStubType::E2E_IDENTITY_CHANGED),
                39 => ::std::option::Option::Some(WebMessageInfoStubType::E2E_ENCRYPTED),
                40 => ::std::option::Option::Some(WebMessageInfoStubType::CALL_MISSED_VOICE),
                41 => ::std::option::Option::Some(WebMessageInfoStubType::CALL_MISSED_VIDEO),
                42 => ::std::option::Option::Some(WebMessageInfoStubType::INDIVIDUAL_CHANGE_NUMBER),
                43 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_DELETE),
                44 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE),
                45 => ::std::option::Option::Some(WebMessageInfoStubType::CALL_MISSED_GROUP_VOICE),
                46 => ::std::option::Option::Some(WebMessageInfoStubType::CALL_MISSED_GROUP_VIDEO),
                47 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_CIPHERTEXT),
                48 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_FUTUREPROOF),
                49 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED),
                50 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED),
                51 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED),
                52 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP),
                53 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP),
                54 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER),
                55 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_ACTION_SEND_PAYMENT_REMINDER),
                56 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_ACTION_SEND_PAYMENT_INVITATION),
                57 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_ACTION_REQUEST_DECLINED),
                58 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_ACTION_REQUEST_EXPIRED),
                59 => ::std::option::Option::Some(WebMessageInfoStubType::PAYMENT_ACTION_REQUEST_CANCELLED),
                60 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM),
                61 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP),
                62 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_INTRO_TOP),
                63 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_INTRO_BOTTOM),
                64 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_NAME_CHANGE),
                65 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_MOVE_TO_CONSUMER_APP),
                66 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_TWO_TIER_MIGRATION_TOP),
                67 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_TWO_TIER_MIGRATION_BOTTOM),
                68 => ::std::option::Option::Some(WebMessageInfoStubType::OVERSIZED),
                69 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CHANGE_NO_FREQUENTLY_FORWARDED),
                70 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_V4_ADD_INVITE_SENT),
                71 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_PARTICIPANT_ADD_REQUEST_JOIN),
                72 => ::std::option::Option::Some(WebMessageInfoStubType::CHANGE_EPHEMERAL_SETTING),
                73 => ::std::option::Option::Some(WebMessageInfoStubType::E2E_DEVICE_CHANGED),
                74 => ::std::option::Option::Some(WebMessageInfoStubType::VIEWED_ONCE),
                75 => ::std::option::Option::Some(WebMessageInfoStubType::E2E_ENCRYPTED_NOW),
                76 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_TO_BSP_PREMISE),
                77 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_TO_SELF_FB),
                78 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_TO_SELF_PREMISE),
                79 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED),
                80 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED),
                81 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED),
                82 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED),
                83 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE),
                84 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED),
                85 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED),
                86 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_VERIFIED),
                87 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED),
                88 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED),
                89 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED),
                90 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED),
                91 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED),
                92 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_TO_BSP_PREMISE),
                93 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_TO_SELF_PREMISE),
                94 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_UNVERIFIED),
                95 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED),
                96 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_VERIFIED),
                97 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED),
                98 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE),
                99 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_PREMISE_UNVERIFIED),
                100 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_PREMISE_VERIFIED),
                101 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_TO_BSP_FB),
                102 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_TO_CONSUMER),
                103 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_TO_SELF_FB),
                104 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED),
                105 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED),
                106 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED),
                107 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_VERIFIED),
                108 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED),
                109 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED),
                110 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED),
                111 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_UNVERIFIED),
                112 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED),
                113 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED),
                114 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED),
                115 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED),
                116 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED),
                117 => ::std::option::Option::Some(WebMessageInfoStubType::BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED),
                118 => ::std::option::Option::Some(WebMessageInfoStubType::E2E_IDENTITY_UNAVAILABLE),
                119 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CREATING),
                120 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_CREATE_FAILED),
                121 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_BOUNCED),
                122 => ::std::option::Option::Some(WebMessageInfoStubType::BLOCK_CONTACT),
                123 => ::std::option::Option::Some(WebMessageInfoStubType::EPHEMERAL_SETTING_NOT_APPLIED),
                124 => ::std::option::Option::Some(WebMessageInfoStubType::SYNC_FAILED),
                125 => ::std::option::Option::Some(WebMessageInfoStubType::SYNCING),
                126 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_PRIVACY_MODE_INIT_FB),
                127 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_PRIVACY_MODE_INIT_BSP),
                128 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_PRIVACY_MODE_TO_FB),
                129 => ::std::option::Option::Some(WebMessageInfoStubType::BIZ_PRIVACY_MODE_TO_BSP),
                130 => ::std::option::Option::Some(WebMessageInfoStubType::DISAPPEARING_MODE),
                131 => ::std::option::Option::Some(WebMessageInfoStubType::E2E_DEVICE_FETCH_FAILED),
                132 => ::std::option::Option::Some(WebMessageInfoStubType::ADMIN_REVOKE),
                133 => ::std::option::Option::Some(WebMessageInfoStubType::GROUP_INVITE_LINK_GROWTH_LOCKED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WebMessageInfoStubType] = &[
            WebMessageInfoStubType::UNKNOWN,
            WebMessageInfoStubType::REVOKE,
            WebMessageInfoStubType::CIPHERTEXT,
            WebMessageInfoStubType::FUTUREPROOF,
            WebMessageInfoStubType::NON_VERIFIED_TRANSITION,
            WebMessageInfoStubType::UNVERIFIED_TRANSITION,
            WebMessageInfoStubType::VERIFIED_TRANSITION,
            WebMessageInfoStubType::VERIFIED_LOW_UNKNOWN,
            WebMessageInfoStubType::VERIFIED_HIGH,
            WebMessageInfoStubType::VERIFIED_INITIAL_UNKNOWN,
            WebMessageInfoStubType::VERIFIED_INITIAL_LOW,
            WebMessageInfoStubType::VERIFIED_INITIAL_HIGH,
            WebMessageInfoStubType::VERIFIED_TRANSITION_ANY_TO_NONE,
            WebMessageInfoStubType::VERIFIED_TRANSITION_ANY_TO_HIGH,
            WebMessageInfoStubType::VERIFIED_TRANSITION_HIGH_TO_LOW,
            WebMessageInfoStubType::VERIFIED_TRANSITION_HIGH_TO_UNKNOWN,
            WebMessageInfoStubType::VERIFIED_TRANSITION_UNKNOWN_TO_LOW,
            WebMessageInfoStubType::VERIFIED_TRANSITION_LOW_TO_UNKNOWN,
            WebMessageInfoStubType::VERIFIED_TRANSITION_NONE_TO_LOW,
            WebMessageInfoStubType::VERIFIED_TRANSITION_NONE_TO_UNKNOWN,
            WebMessageInfoStubType::GROUP_CREATE,
            WebMessageInfoStubType::GROUP_CHANGE_SUBJECT,
            WebMessageInfoStubType::GROUP_CHANGE_ICON,
            WebMessageInfoStubType::GROUP_CHANGE_INVITE_LINK,
            WebMessageInfoStubType::GROUP_CHANGE_DESCRIPTION,
            WebMessageInfoStubType::GROUP_CHANGE_RESTRICT,
            WebMessageInfoStubType::GROUP_CHANGE_ANNOUNCE,
            WebMessageInfoStubType::GROUP_PARTICIPANT_ADD,
            WebMessageInfoStubType::GROUP_PARTICIPANT_REMOVE,
            WebMessageInfoStubType::GROUP_PARTICIPANT_PROMOTE,
            WebMessageInfoStubType::GROUP_PARTICIPANT_DEMOTE,
            WebMessageInfoStubType::GROUP_PARTICIPANT_INVITE,
            WebMessageInfoStubType::GROUP_PARTICIPANT_LEAVE,
            WebMessageInfoStubType::GROUP_PARTICIPANT_CHANGE_NUMBER,
            WebMessageInfoStubType::BROADCAST_CREATE,
            WebMessageInfoStubType::BROADCAST_ADD,
            WebMessageInfoStubType::BROADCAST_REMOVE,
            WebMessageInfoStubType::GENERIC_NOTIFICATION,
            WebMessageInfoStubType::E2E_IDENTITY_CHANGED,
            WebMessageInfoStubType::E2E_ENCRYPTED,
            WebMessageInfoStubType::CALL_MISSED_VOICE,
            WebMessageInfoStubType::CALL_MISSED_VIDEO,
            WebMessageInfoStubType::INDIVIDUAL_CHANGE_NUMBER,
            WebMessageInfoStubType::GROUP_DELETE,
            WebMessageInfoStubType::GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE,
            WebMessageInfoStubType::CALL_MISSED_GROUP_VOICE,
            WebMessageInfoStubType::CALL_MISSED_GROUP_VIDEO,
            WebMessageInfoStubType::PAYMENT_CIPHERTEXT,
            WebMessageInfoStubType::PAYMENT_FUTUREPROOF,
            WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED,
            WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED,
            WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED,
            WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP,
            WebMessageInfoStubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP,
            WebMessageInfoStubType::PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER,
            WebMessageInfoStubType::PAYMENT_ACTION_SEND_PAYMENT_REMINDER,
            WebMessageInfoStubType::PAYMENT_ACTION_SEND_PAYMENT_INVITATION,
            WebMessageInfoStubType::PAYMENT_ACTION_REQUEST_DECLINED,
            WebMessageInfoStubType::PAYMENT_ACTION_REQUEST_EXPIRED,
            WebMessageInfoStubType::PAYMENT_ACTION_REQUEST_CANCELLED,
            WebMessageInfoStubType::BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM,
            WebMessageInfoStubType::BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP,
            WebMessageInfoStubType::BIZ_INTRO_TOP,
            WebMessageInfoStubType::BIZ_INTRO_BOTTOM,
            WebMessageInfoStubType::BIZ_NAME_CHANGE,
            WebMessageInfoStubType::BIZ_MOVE_TO_CONSUMER_APP,
            WebMessageInfoStubType::BIZ_TWO_TIER_MIGRATION_TOP,
            WebMessageInfoStubType::BIZ_TWO_TIER_MIGRATION_BOTTOM,
            WebMessageInfoStubType::OVERSIZED,
            WebMessageInfoStubType::GROUP_CHANGE_NO_FREQUENTLY_FORWARDED,
            WebMessageInfoStubType::GROUP_V4_ADD_INVITE_SENT,
            WebMessageInfoStubType::GROUP_PARTICIPANT_ADD_REQUEST_JOIN,
            WebMessageInfoStubType::CHANGE_EPHEMERAL_SETTING,
            WebMessageInfoStubType::E2E_DEVICE_CHANGED,
            WebMessageInfoStubType::VIEWED_ONCE,
            WebMessageInfoStubType::E2E_ENCRYPTED_NOW,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_TO_BSP_PREMISE,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_TO_SELF_FB,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_TO_SELF_PREMISE,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE,
            WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_TO_BSP_PREMISE,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_TO_SELF_PREMISE,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE,
            WebMessageInfoStubType::BLUE_MSG_SELF_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_TO_BSP_FB,
            WebMessageInfoStubType::BLUE_MSG_TO_CONSUMER,
            WebMessageInfoStubType::BLUE_MSG_TO_SELF_FB,
            WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_UNVERIFIED_TO_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_VERIFIED_TO_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED,
            WebMessageInfoStubType::BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED,
            WebMessageInfoStubType::E2E_IDENTITY_UNAVAILABLE,
            WebMessageInfoStubType::GROUP_CREATING,
            WebMessageInfoStubType::GROUP_CREATE_FAILED,
            WebMessageInfoStubType::GROUP_BOUNCED,
            WebMessageInfoStubType::BLOCK_CONTACT,
            WebMessageInfoStubType::EPHEMERAL_SETTING_NOT_APPLIED,
            WebMessageInfoStubType::SYNC_FAILED,
            WebMessageInfoStubType::SYNCING,
            WebMessageInfoStubType::BIZ_PRIVACY_MODE_INIT_FB,
            WebMessageInfoStubType::BIZ_PRIVACY_MODE_INIT_BSP,
            WebMessageInfoStubType::BIZ_PRIVACY_MODE_TO_FB,
            WebMessageInfoStubType::BIZ_PRIVACY_MODE_TO_BSP,
            WebMessageInfoStubType::DISAPPEARING_MODE,
            WebMessageInfoStubType::E2E_DEVICE_FETCH_FAILED,
            WebMessageInfoStubType::ADMIN_REVOKE,
            WebMessageInfoStubType::GROUP_INVITE_LINK_GROWTH_LOCKED,
        ];
    }

    impl ::protobuf::EnumFull for WebMessageInfoStubType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebMessageInfo.WebMessageInfoStubType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WebMessageInfoStubType {
        fn default() -> Self {
            WebMessageInfoStubType::UNKNOWN
        }
    }

    impl WebMessageInfoStubType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebMessageInfoStubType>("WebMessageInfo.WebMessageInfoStubType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WebMessageInfo.WebMessageInfoBizPrivacyStatus)
    pub enum WebMessageInfoBizPrivacyStatus {
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoBizPrivacyStatus.E2EE)
        E2EE = 0,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoBizPrivacyStatus.FB)
        FB = 2,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoBizPrivacyStatus.BSP)
        BSP = 1,
        // @@protoc_insertion_point(enum_value:WebMessageInfo.WebMessageInfoBizPrivacyStatus.BSP_AND_FB)
        BSP_AND_FB = 3,
    }

    impl ::protobuf::Enum for WebMessageInfoBizPrivacyStatus {
        const NAME: &'static str = "WebMessageInfoBizPrivacyStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WebMessageInfoBizPrivacyStatus> {
            match value {
                0 => ::std::option::Option::Some(WebMessageInfoBizPrivacyStatus::E2EE),
                2 => ::std::option::Option::Some(WebMessageInfoBizPrivacyStatus::FB),
                1 => ::std::option::Option::Some(WebMessageInfoBizPrivacyStatus::BSP),
                3 => ::std::option::Option::Some(WebMessageInfoBizPrivacyStatus::BSP_AND_FB),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WebMessageInfoBizPrivacyStatus] = &[
            WebMessageInfoBizPrivacyStatus::E2EE,
            WebMessageInfoBizPrivacyStatus::FB,
            WebMessageInfoBizPrivacyStatus::BSP,
            WebMessageInfoBizPrivacyStatus::BSP_AND_FB,
        ];
    }

    impl ::protobuf::EnumFull for WebMessageInfoBizPrivacyStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebMessageInfo.WebMessageInfoBizPrivacyStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                WebMessageInfoBizPrivacyStatus::E2EE => 0,
                WebMessageInfoBizPrivacyStatus::FB => 1,
                WebMessageInfoBizPrivacyStatus::BSP => 2,
                WebMessageInfoBizPrivacyStatus::BSP_AND_FB => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WebMessageInfoBizPrivacyStatus {
        fn default() -> Self {
            WebMessageInfoBizPrivacyStatus::E2EE
        }
    }

    impl WebMessageInfoBizPrivacyStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebMessageInfoBizPrivacyStatus>("WebMessageInfo.WebMessageInfoBizPrivacyStatus")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaVisibility)
pub enum MediaVisibility {
    // @@protoc_insertion_point(enum_value:MediaVisibility.DEFAULT)
    DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:MediaVisibility.OFF)
    OFF = 1,
    // @@protoc_insertion_point(enum_value:MediaVisibility.ON)
    ON = 2,
}

impl ::protobuf::Enum for MediaVisibility {
    const NAME: &'static str = "MediaVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaVisibility> {
        match value {
            0 => ::std::option::Option::Some(MediaVisibility::DEFAULT),
            1 => ::std::option::Option::Some(MediaVisibility::OFF),
            2 => ::std::option::Option::Some(MediaVisibility::ON),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaVisibility] = &[
        MediaVisibility::DEFAULT,
        MediaVisibility::OFF,
        MediaVisibility::ON,
    ];
}

impl ::protobuf::EnumFull for MediaVisibility {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaVisibility").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MediaVisibility {
    fn default() -> Self {
        MediaVisibility::DEFAULT
    }
}

impl MediaVisibility {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaVisibility>("MediaVisibility")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ewhatsapp.proto\"\x9a\x01\n\nAppVersion\x12\x18\n\x07primary\x18\
    \x01\x20\x01(\rR\x07primary\x12\x1c\n\tsecondary\x18\x02\x20\x01(\rR\tse\
    condary\x12\x1a\n\x08tertiary\x18\x03\x20\x01(\rR\x08tertiary\x12\x1e\n\
    \nquaternary\x18\x04\x20\x01(\rR\nquaternary\x12\x18\n\x07quinary\x18\
    \x05\x20\x01(\rR\x07quinary\"\x97\x08\n\tUserAgent\x128\n\x08platform\
    \x18\x01\x20\x01(\x0e2\x1c.UserAgent.UserAgentPlatformR\x08platform\x12+\
    \n\nappVersion\x18\x02\x20\x01(\x0b2\x0b.AppVersionR\nappVersion\x12\x10\
    \n\x03mcc\x18\x03\x20\x01(\tR\x03mcc\x12\x10\n\x03mnc\x18\x04\x20\x01(\t\
    R\x03mnc\x12\x1c\n\tosVersion\x18\x05\x20\x01(\tR\tosVersion\x12\"\n\x0c\
    manufacturer\x18\x06\x20\x01(\tR\x0cmanufacturer\x12\x16\n\x06device\x18\
    \x07\x20\x01(\tR\x06device\x12$\n\rosBuildNumber\x18\x08\x20\x01(\tR\ros\
    BuildNumber\x12\x18\n\x07phoneId\x18\t\x20\x01(\tR\x07phoneId\x12J\n\x0e\
    releaseChannel\x18\n\x20\x01(\x0e2\".UserAgent.UserAgentReleaseChannelR\
    \x0ereleaseChannel\x124\n\x15localeLanguageIso6391\x18\x0b\x20\x01(\tR\
    \x15localeLanguageIso6391\x12@\n\x1blocaleCountryIso31661Alpha2\x18\x0c\
    \x20\x01(\tR\x1blocaleCountryIso31661Alpha2\x12\x20\n\x0bdeviceBoard\x18\
    \r\x20\x01(\tR\x0bdeviceBoard\"\xb6\x03\n\x11UserAgentPlatform\x12\x0b\n\
    \x07ANDROID\x10\0\x12\x07\n\x03IOS\x10\x01\x12\x11\n\rWINDOWS_PHONE\x10\
    \x02\x12\x0e\n\nBLACKBERRY\x10\x03\x12\x0f\n\x0bBLACKBERRYX\x10\x04\x12\
    \x07\n\x03S40\x10\x05\x12\x07\n\x03S60\x10\x06\x12\x11\n\rPYTHON_CLIENT\
    \x10\x07\x12\t\n\x05TIZEN\x10\x08\x12\x0e\n\nENTERPRISE\x10\t\x12\x0f\n\
    \x0bSMB_ANDROID\x10\n\x12\t\n\x05KAIOS\x10\x0b\x12\x0b\n\x07SMB_IOS\x10\
    \x0c\x12\x0b\n\x07WINDOWS\x10\r\x12\x07\n\x03WEB\x10\x0e\x12\n\n\x06PORT\
    AL\x10\x0f\x12\x11\n\rGREEN_ANDROID\x10\x10\x12\x10\n\x0cGREEN_IPHONE\
    \x10\x11\x12\x10\n\x0cBLUE_ANDROID\x10\x12\x12\x0f\n\x0bBLUE_IPHONE\x10\
    \x13\x12\x12\n\x0eFBLITE_ANDROID\x10\x14\x12\x11\n\rMLITE_ANDROID\x10\
    \x15\x12\x12\n\x0eIGLITE_ANDROID\x10\x16\x12\x08\n\x04PAGE\x10\x17\x12\t\
    \n\x05MACOS\x10\x18\x12\x0e\n\nOCULUS_MSG\x10\x19\x12\x0f\n\x0bOCULUS_CA\
    LL\x10\x1a\x12\t\n\x05MILAN\x10\x1b\x12\x08\n\x04CAPI\x10\x1c\"F\n\x17Us\
    erAgentReleaseChannel\x12\x0b\n\x07RELEASE\x10\0\x12\x08\n\x04BETA\x10\
    \x01\x12\t\n\x05ALPHA\x10\x02\x12\t\n\x05DEBUG\x10\x03\"\x91\x04\n\x0bWe\
    bdPayload\x122\n\x14usesParticipantInKey\x18\x01\x20\x01(\x08R\x14usesPa\
    rticipantInKey\x128\n\x17supportsStarredMessages\x18\x02\x20\x01(\x08R\
    \x17supportsStarredMessages\x12:\n\x18supportsDocumentMessages\x18\x03\
    \x20\x01(\x08R\x18supportsDocumentMessages\x120\n\x13supportsUrlMessages\
    \x18\x04\x20\x01(\x08R\x13supportsUrlMessages\x12.\n\x12supportsMediaRet\
    ry\x18\x05\x20\x01(\x08R\x12supportsMediaRetry\x12*\n\x10supportsE2EImag\
    e\x18\x06\x20\x01(\x08R\x10supportsE2EImage\x12*\n\x10supportsE2EVideo\
    \x18\x07\x20\x01(\x08R\x10supportsE2EVideo\x12*\n\x10supportsE2EAudio\
    \x18\x08\x20\x01(\x08R\x10supportsE2EAudio\x120\n\x13supportsE2EDocument\
    \x18\t\x20\x01(\x08R\x13supportsE2EDocument\x12$\n\rdocumentTypes\x18\n\
    \x20\x01(\tR\rdocumentTypes\x12\x1a\n\x08features\x18\x0b\x20\x01(\x0cR\
    \x08features\"\x96\x02\n\x07WebInfo\x12\x1a\n\x08refToken\x18\x01\x20\
    \x01(\tR\x08refToken\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\
    \x12.\n\x0bwebdPayload\x18\x03\x20\x01(\x0b2\x0c.WebdPayloadR\x0bwebdPay\
    load\x12F\n\x0ewebSubPlatform\x18\x04\x20\x01(\x0e2\x1e.WebInfo.WebInfoW\
    ebSubPlatformR\x0ewebSubPlatform\"]\n\x15WebInfoWebSubPlatform\x12\x0f\n\
    \x0bWEB_BROWSER\x10\0\x12\r\n\tAPP_STORE\x10\x01\x12\r\n\tWIN_STORE\x10\
    \x02\x12\n\n\x06DARWIN\x10\x03\x12\t\n\x05WIN32\x10\x04\"\xd3\x01\n\tDNS\
    Source\x12E\n\tdnsMethod\x18\x0f\x20\x01(\x0e2'.DNSSource.DNSSourceDNSRe\
    solutionMethodR\tdnsMethod\x12\x1c\n\tappCached\x18\x10\x20\x01(\x08R\ta\
    ppCached\"a\n\x1cDNSSourceDNSResolutionMethod\x12\n\n\x06SYSTEM\x10\0\
    \x12\n\n\x06GOOGLE\x10\x01\x12\r\n\tHARDCODED\x10\x02\x12\x0c\n\x08OVERR\
    IDE\x10\x03\x12\x0c\n\x08FALLBACK\x10\x04\"\xf6\x01\n\x10CompanionRegDat\
    a\x12\x16\n\x06eRegid\x18\x01\x20\x01(\x0cR\x06eRegid\x12\x1a\n\x08eKeyt\
    ype\x18\x02\x20\x01(\x0cR\x08eKeytype\x12\x16\n\x06eIdent\x18\x03\x20\
    \x01(\x0cR\x06eIdent\x12\x18\n\x07eSkeyId\x18\x04\x20\x01(\x0cR\x07eSkey\
    Id\x12\x1a\n\x08eSkeyVal\x18\x05\x20\x01(\x0cR\x08eSkeyVal\x12\x1a\n\x08\
    eSkeySig\x18\x06\x20\x01(\x0cR\x08eSkeySig\x12\x1c\n\tbuildHash\x18\x07\
    \x20\x01(\x0cR\tbuildHash\x12&\n\x0ecompanionProps\x18\x08\x20\x01(\x0cR\
    \x0ecompanionProps\"\xcf\x0b\n\rClientPayload\x12\x1a\n\x08username\x18\
    \x01\x20\x01(\x04R\x08username\x12\x18\n\x07passive\x18\x03\x20\x01(\x08\
    R\x07passive\x12(\n\tuserAgent\x18\x05\x20\x01(\x0b2\n.UserAgentR\tuserA\
    gent\x12\"\n\x07webInfo\x18\x06\x20\x01(\x0b2\x08.WebInfoR\x07webInfo\
    \x12\x1a\n\x08pushName\x18\x07\x20\x01(\tR\x08pushName\x12\x1c\n\tsessio\
    nId\x18\t\x20\x01(\x0fR\tsessionId\x12\"\n\x0cshortConnect\x18\n\x20\x01\
    (\x08R\x0cshortConnect\x12I\n\x0bconnectType\x18\x0c\x20\x01(\x0e2'.Clie\
    ntPayload.ClientPayloadConnectTypeR\x0bconnectType\x12O\n\rconnectReason\
    \x18\r\x20\x01(\x0e2).ClientPayload.ClientPayloadConnectReasonR\rconnect\
    Reason\x12\x16\n\x06shards\x18\x0e\x20\x03(\x05R\x06shards\x12(\n\tdnsSo\
    urce\x18\x0f\x20\x01(\x0b2\n.DNSSourceR\tdnsSource\x120\n\x13connectAtte\
    mptCount\x18\x10\x20\x01(\rR\x13connectAttemptCount\x12\x16\n\x06device\
    \x18\x12\x20\x01(\rR\x06device\x12+\n\x07regData\x18\x13\x20\x01(\x0b2\
    \x11.CompanionRegDataR\x07regData\x12=\n\x07product\x18\x14\x20\x01(\x0e\
    2#.ClientPayload.ClientPayloadProductR\x07product\x12\x14\n\x05fbCat\x18\
    \x15\x20\x01(\x0cR\x05fbCat\x12\x20\n\x0bfbUserAgent\x18\x16\x20\x01(\
    \x0cR\x0bfbUserAgent\x12\x0e\n\x02oc\x18\x17\x20\x01(\x08R\x02oc\x12\x0e\
    \n\x02lc\x18\x18\x20\x01(\x05R\x02lc\x12U\n\x0fiosAppExtension\x18\x1e\
    \x20\x01(\x0e2+.ClientPayload.ClientPayloadIOSAppExtensionR\x0fiosAppExt\
    ension\x12\x18\n\x07fbAppId\x18\x1f\x20\x01(\x04R\x07fbAppId\x12\x1e\n\n\
    fbDeviceId\x18\x20\x20\x01(\x0cR\nfbDeviceId\"\xbd\x02\n\x18ClientPayloa\
    dConnectType\x12\x14\n\x10CELLULAR_UNKNOWN\x10\0\x12\x10\n\x0cWIFI_UNKNO\
    WN\x10\x01\x12\x11\n\rCELLULAR_EDGE\x10d\x12\x11\n\rCELLULAR_IDEN\x10e\
    \x12\x11\n\rCELLULAR_UMTS\x10f\x12\x11\n\rCELLULAR_EVDO\x10g\x12\x11\n\r\
    CELLULAR_GPRS\x10h\x12\x12\n\x0eCELLULAR_HSDPA\x10i\x12\x12\n\x0eCELLULA\
    R_HSUPA\x10j\x12\x11\n\rCELLULAR_HSPA\x10k\x12\x11\n\rCELLULAR_CDMA\x10l\
    \x12\x12\n\x0eCELLULAR_1XRTT\x10m\x12\x12\n\x0eCELLULAR_EHRPD\x10n\x12\
    \x10\n\x0cCELLULAR_LTE\x10o\x12\x12\n\x0eCELLULAR_HSPAP\x10p\"\x86\x01\n\
    \x1aClientPayloadConnectReason\x12\x08\n\x04PUSH\x10\0\x12\x12\n\x0eUSER\
    _ACTIVATED\x10\x01\x12\r\n\tSCHEDULED\x10\x02\x12\x13\n\x0fERROR_RECONNE\
    CT\x10\x03\x12\x12\n\x0eNETWORK_SWITCH\x10\x04\x12\x12\n\x0ePING_RECONNE\
    CT\x10\x05\"3\n\x14ClientPayloadProduct\x12\x0c\n\x08WHATSAPP\x10\0\x12\
    \r\n\tMESSENGER\x10\x01\"a\n\x1cClientPayloadIOSAppExtension\x12\x13\n\
    \x0fSHARE_EXTENSION\x10\0\x12\x15\n\x11SERVICE_EXTENSION\x10\x01\x12\x15\
    \n\x11INTENTS_EXTENSION\x10\x02\"\x8f\x01\n\x17NoiseCertificateDetails\
    \x12\x16\n\x06serial\x18\x01\x20\x01(\rR\x06serial\x12\x16\n\x06issuer\
    \x18\x02\x20\x01(\tR\x06issuer\x12\x18\n\x07expires\x18\x03\x20\x01(\x04\
    R\x07expires\x12\x18\n\x07subject\x18\x04\x20\x01(\tR\x07subject\x12\x10\
    \n\x03key\x18\x05\x20\x01(\x0cR\x03key\"J\n\x10NoiseCertificate\x12\x18\
    \n\x07details\x18\x01\x20\x01(\x0cR\x07details\x12\x1c\n\tsignature\x18\
    \x02\x20\x01(\x0cR\tsignature\"]\n\x0bClientHello\x12\x1c\n\tephemeral\
    \x18\x01\x20\x01(\x0cR\tephemeral\x12\x16\n\x06static\x18\x02\x20\x01(\
    \x0cR\x06static\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\x07payload\"]\
    \n\x0bServerHello\x12\x1c\n\tephemeral\x18\x01\x20\x01(\x0cR\tephemeral\
    \x12\x16\n\x06static\x18\x02\x20\x01(\x0cR\x06static\x12\x18\n\x07payloa\
    d\x18\x03\x20\x01(\x0cR\x07payload\"@\n\x0cClientFinish\x12\x16\n\x06sta\
    tic\x18\x01\x20\x01(\x0cR\x06static\x12\x18\n\x07payload\x18\x02\x20\x01\
    (\x0cR\x07payload\"\xa5\x01\n\x10HandshakeMessage\x12.\n\x0bclientHello\
    \x18\x02\x20\x01(\x0b2\x0c.ClientHelloR\x0bclientHello\x12.\n\x0bserverH\
    ello\x18\x03\x20\x01(\x0b2\x0c.ServerHelloR\x0bserverHello\x121\n\x0ccli\
    entFinish\x18\x04\x20\x01(\x0b2\r.ClientFinishR\x0cclientFinish\"\xfb\
    \x04\n\x0fBizIdentityInfo\x12J\n\x06vlevel\x18\x01\x20\x01(\x0e22.BizIde\
    ntityInfo.BizIdentityInfoVerifiedLevelValueR\x06vlevel\x126\n\tvnameCert\
    \x18\x02\x20\x01(\x0b2\x18.VerifiedNameCertificateR\tvnameCert\x12\x16\n\
    \x06signed\x18\x03\x20\x01(\x08R\x06signed\x12\x18\n\x07revoked\x18\x04\
    \x20\x01(\x08R\x07revoked\x12Q\n\x0bhostStorage\x18\x05\x20\x01(\x0e2/.B\
    izIdentityInfo.BizIdentityInfoHostStorageTypeR\x0bhostStorage\x12T\n\x0c\
    actualActors\x18\x06\x20\x01(\x0e20.BizIdentityInfo.BizIdentityInfoActua\
    lActorsTypeR\x0cactualActors\x12$\n\rprivacyModeTs\x18\x07\x20\x01(\x04R\
    \rprivacyModeTs\x12(\n\x0ffeatureControls\x18\x08\x20\x01(\x04R\x0ffeatu\
    reControls\"C\n!BizIdentityInfoVerifiedLevelValue\x12\x0b\n\x07UNKNOWN\
    \x10\0\x12\x07\n\x03LOW\x10\x01\x12\x08\n\x04HIGH\x10\x02\">\n\x1eBizIde\
    ntityInfoHostStorageType\x12\x0e\n\nON_PREMISE\x10\0\x12\x0c\n\x08FACEBO\
    OK\x10\x01\"4\n\x1fBizIdentityInfoActualActorsType\x12\x08\n\x04SELF\x10\
    \0\x12\x07\n\x03BSP\x10\x01\"\xb6\x03\n\x12BizAccountLinkInfo\x120\n\x13\
    whatsappBizAcctFbid\x18\x01\x20\x01(\x04R\x13whatsappBizAcctFbid\x12.\n\
    \x12whatsappAcctNumber\x18\x02\x20\x01(\tR\x12whatsappAcctNumber\x12\x1c\
    \n\tissueTime\x18\x03\x20\x01(\x04R\tissueTime\x12W\n\x0bhostStorage\x18\
    \x04\x20\x01(\x0e25.BizAccountLinkInfo.BizAccountLinkInfoHostStorageType\
    R\x0bhostStorage\x12S\n\x0baccountType\x18\x05\x20\x01(\x0e21.BizAccount\
    LinkInfo.BizAccountLinkInfoAccountTypeR\x0baccountType\"A\n!BizAccountLi\
    nkInfoHostStorageType\x12\x0e\n\nON_PREMISE\x10\0\x12\x0c\n\x08FACEBOOK\
    \x10\x01\"/\n\x1dBizAccountLinkInfoAccountType\x12\x0e\n\nENTERPRISE\x10\
    \0\"u\n\x11BizAccountPayload\x126\n\tvnameCert\x18\x01\x20\x01(\x0b2\x18\
    .VerifiedNameCertificateR\tvnameCert\x12(\n\x0fbizAcctLinkInfo\x18\x02\
    \x20\x01(\x0cR\x0fbizAcctLinkInfo\"\xbf\x01\n\x13VerifiedNameDetails\x12\
    \x16\n\x06serial\x18\x01\x20\x01(\x04R\x06serial\x12\x16\n\x06issuer\x18\
    \x02\x20\x01(\tR\x06issuer\x12\"\n\x0cverifiedName\x18\x04\x20\x01(\tR\
    \x0cverifiedName\x126\n\x0elocalizedNames\x18\x08\x20\x03(\x0b2\x0e.Loca\
    lizedNameR\x0elocalizedNames\x12\x1c\n\tissueTime\x18\n\x20\x01(\x04R\ti\
    ssueTime\"{\n\x17VerifiedNameCertificate\x12\x18\n\x07details\x18\x01\
    \x20\x01(\x0cR\x07details\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsi\
    gnature\x12(\n\x0fserverSignature\x18\x03\x20\x01(\x0cR\x0fserverSignatu\
    re\"S\n\rLocalizedName\x12\x0e\n\x02lg\x18\x01\x20\x01(\tR\x02lg\x12\x0e\
    \n\x02lc\x18\x02\x20\x01(\tR\x02lc\x12\"\n\x0cverifiedName\x18\x03\x20\
    \x01(\tR\x0cverifiedName\"\x82\x01\n\x0eSyncActionData\x12\x14\n\x05inde\
    x\x18\x01\x20\x01(\x0cR\x05index\x12&\n\x05value\x18\x02\x20\x01(\x0b2\
    \x10.SyncActionValueR\x05value\x12\x18\n\x07padding\x18\x03\x20\x01(\x0c\
    R\x07padding\x12\x18\n\x07version\x18\x04\x20\x01(\x05R\x07version\"&\n\
    \nStarAction\x12\x18\n\x07starred\x18\x01\x20\x01(\x08R\x07starred\"I\n\
    \rContactAction\x12\x1a\n\x08fullName\x18\x01\x20\x01(\tR\x08fullName\
    \x12\x1c\n\tfirstName\x18\x02\x20\x01(\tR\tfirstName\"N\n\nMuteAction\
    \x12\x14\n\x05muted\x18\x01\x20\x01(\x08R\x05muted\x12*\n\x10muteEndTime\
    stamp\x18\x02\x20\x01(\x03R\x10muteEndTimestamp\"#\n\tPinAction\x12\x16\
    \n\x06pinned\x18\x01\x20\x01(\x08R\x06pinned\"I\n\x1bSecurityNotificatio\
    nSetting\x12*\n\x10showNotification\x18\x01\x20\x01(\x08R\x10showNotific\
    ation\"%\n\x0fPushNameSetting\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\"'\n\rLocaleSetting\x12\x16\n\x06locale\x18\x01\x20\x01(\tR\x06local\
    e\"\x94\x01\n\x10QuickReplyAction\x12\x1a\n\x08shortcut\x18\x01\x20\x01(\
    \tR\x08shortcut\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12\
    \x1a\n\x08keywords\x18\x03\x20\x03(\tR\x08keywords\x12\x14\n\x05count\
    \x18\x04\x20\x01(\x05R\x05count\x12\x18\n\x07deleted\x18\x05\x20\x01(\
    \x08R\x07deleted\"2\n\x16LabelAssociationAction\x12\x18\n\x07labeled\x18\
    \x01\x20\x01(\x08R\x07labeled\"y\n\x0fLabelEditAction\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05color\x18\x02\x20\x01(\x05R\
    \x05color\x12\"\n\x0cpredefinedId\x18\x03\x20\x01(\x05R\x0cpredefinedId\
    \x12\x18\n\x07deleted\x18\x04\x20\x01(\x08R\x07deleted\"L\n\x1aRecentSti\
    ckerWeightsAction\x12.\n\x07weights\x18\x01\x20\x03(\x0b2\x14.RecentStic\
    kerWeightR\x07weights\"\xed\x01\n\x15RecentStickerMetadata\x12\x1e\n\ndi\
    rectPath\x18\x01\x20\x01(\tR\ndirectPath\x12\x20\n\x0bencFilehash\x18\
    \x02\x20\x01(\tR\x0bencFilehash\x12\x1a\n\x08mediaKey\x18\x03\x20\x01(\t\
    R\x08mediaKey\x12\x1a\n\x08stanzaId\x18\x04\x20\x01(\tR\x08stanzaId\x12\
    \x18\n\x07chatJid\x18\x05\x20\x01(\tR\x07chatJid\x12\x20\n\x0bparticipan\
    t\x18\x06\x20\x01(\tR\x0bparticipant\x12\x1e\n\nisSentByMe\x18\x07\x20\
    \x01(\x08R\nisSentByMe\"H\n\x18RecentEmojiWeightsAction\x12,\n\x07weight\
    s\x18\x01\x20\x03(\x0b2\x12.RecentEmojiWeightR\x07weights\"\xc5\x02\n\
    \x15FavoriteStickerAction\x12\x1e\n\ndirectPath\x18\x01\x20\x01(\tR\ndir\
    ectPath\x120\n\x13lastUploadTimestamp\x18\x02\x20\x01(\tR\x13lastUploadT\
    imestamp\x12\x16\n\x06handle\x18\x03\x20\x01(\tR\x06handle\x12\x20\n\x0b\
    encFilehash\x18\x04\x20\x01(\tR\x0bencFilehash\x126\n\x16stickerHashWith\
    outMeta\x18\x05\x20\x01(\tR\x16stickerHashWithoutMeta\x12\x1a\n\x08media\
    Key\x18\x06\x20\x01(\tR\x08mediaKey\x12,\n\x11mediaKeyTimestamp\x18\x07\
    \x20\x01(\x03R\x11mediaKeyTimestamp\x12\x1e\n\nisFavorite\x18\x08\x20\
    \x01(\x08R\nisFavorite\"l\n\x11ArchiveChatAction\x12\x1a\n\x08archived\
    \x18\x01\x20\x01(\x08R\x08archived\x12;\n\x0cmessageRange\x18\x02\x20\
    \x01(\x0b2\x17.SyncActionMessageRangeR\x0cmessageRange\"h\n\x18DeleteMes\
    sageForMeAction\x12\x20\n\x0bdeleteMedia\x18\x01\x20\x01(\x08R\x0bdelete\
    Media\x12*\n\x10messageTimestamp\x18\x02\x20\x01(\x03R\x10messageTimesta\
    mp\"g\n\x14MarkChatAsReadAction\x12\x12\n\x04read\x18\x01\x20\x01(\x08R\
    \x04read\x12;\n\x0cmessageRange\x18\x02\x20\x01(\x0b2\x17.SyncActionMess\
    ageRangeR\x0cmessageRange\"N\n\x0fClearChatAction\x12;\n\x0cmessageRange\
    \x18\x01\x20\x01(\x0b2\x17.SyncActionMessageRangeR\x0cmessageRange\"O\n\
    \x10DeleteChatAction\x12;\n\x0cmessageRange\x18\x01\x20\x01(\x0b2\x17.Sy\
    ncActionMessageRangeR\x0cmessageRange\"?\n\x15UnarchiveChatsSetting\x12&\
    \n\x0eunarchiveChats\x18\x01\x20\x01(\x08R\x0eunarchiveChats\"\xbc\x01\n\
    \x16SyncActionMessageRange\x122\n\x14lastMessageTimestamp\x18\x01\x20\
    \x01(\x03R\x14lastMessageTimestamp\x12>\n\x1alastSystemMessageTimestamp\
    \x18\x02\x20\x01(\x03R\x1alastSystemMessageTimestamp\x12.\n\x08messages\
    \x18\x03\x20\x03(\x0b2\x12.SyncActionMessageR\x08messages\"P\n\x11SyncAc\
    tionMessage\x12\x1d\n\x03key\x18\x01\x20\x01(\x0b2\x0b.MessageKeyR\x03ke\
    y\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\"9\n\rKeyExpirat\
    ion\x12(\n\x0fexpiredKeyEpoch\x18\x01\x20\x01(\x05R\x0fexpiredKeyEpoch\"\
    &\n\x0ePrimaryFeature\x12\x14\n\x05flags\x18\x01\x20\x03(\tR\x05flags\"5\
    \n\x19AndroidUnsupportedActions\x12\x18\n\x07allowed\x18\x01\x20\x01(\
    \x08R\x07allowed\"\xcd\x0c\n\x0fSyncActionValue\x12\x1c\n\ttimestamp\x18\
    \x01\x20\x01(\x03R\ttimestamp\x12+\n\nstarAction\x18\x02\x20\x01(\x0b2\
    \x0b.StarActionR\nstarAction\x124\n\rcontactAction\x18\x03\x20\x01(\x0b2\
    \x0e.ContactActionR\rcontactAction\x12+\n\nmuteAction\x18\x04\x20\x01(\
    \x0b2\x0b.MuteActionR\nmuteAction\x12(\n\tpinAction\x18\x05\x20\x01(\x0b\
    2\n.PinActionR\tpinAction\x12^\n\x1bsecurityNotificationSetting\x18\x06\
    \x20\x01(\x0b2\x1c.SecurityNotificationSettingR\x1bsecurityNotificationS\
    etting\x12:\n\x0fpushNameSetting\x18\x07\x20\x01(\x0b2\x10.PushNameSetti\
    ngR\x0fpushNameSetting\x12=\n\x10quickReplyAction\x18\x08\x20\x01(\x0b2\
    \x11.QuickReplyActionR\x10quickReplyAction\x12[\n\x1arecentStickerWeight\
    sAction\x18\t\x20\x01(\x0b2\x1b.RecentStickerWeightsActionR\x1arecentSti\
    ckerWeightsAction\x12L\n\x15recentStickerMetadata\x18\n\x20\x01(\x0b2\
    \x16.RecentStickerMetadataR\x15recentStickerMetadata\x12U\n\x18recentEmo\
    jiWeightsAction\x18\x0b\x20\x01(\x0b2\x19.RecentEmojiWeightsActionR\x18r\
    ecentEmojiWeightsAction\x12:\n\x0flabelEditAction\x18\x0e\x20\x01(\x0b2\
    \x10.LabelEditActionR\x0flabelEditAction\x12O\n\x16labelAssociationActio\
    n\x18\x0f\x20\x01(\x0b2\x17.LabelAssociationActionR\x16labelAssociationA\
    ction\x124\n\rlocaleSetting\x18\x10\x20\x01(\x0b2\x0e.LocaleSettingR\rlo\
    caleSetting\x12@\n\x11archiveChatAction\x18\x11\x20\x01(\x0b2\x12.Archiv\
    eChatActionR\x11archiveChatAction\x12U\n\x18deleteMessageForMeAction\x18\
    \x12\x20\x01(\x0b2\x19.DeleteMessageForMeActionR\x18deleteMessageForMeAc\
    tion\x124\n\rkeyExpiration\x18\x13\x20\x01(\x0b2\x0e.KeyExpirationR\rkey\
    Expiration\x12I\n\x14markChatAsReadAction\x18\x14\x20\x01(\x0b2\x15.Mark\
    ChatAsReadActionR\x14markChatAsReadAction\x12:\n\x0fclearChatAction\x18\
    \x15\x20\x01(\x0b2\x10.ClearChatActionR\x0fclearChatAction\x12=\n\x10del\
    eteChatAction\x18\x16\x20\x01(\x0b2\x11.DeleteChatActionR\x10deleteChatA\
    ction\x12L\n\x15unarchiveChatsSetting\x18\x17\x20\x01(\x0b2\x16.Unarchiv\
    eChatsSettingR\x15unarchiveChatsSetting\x127\n\x0eprimaryFeature\x18\x18\
    \x20\x01(\x0b2\x0f.PrimaryFeatureR\x0eprimaryFeature\x12L\n\x15favoriteS\
    tickerAction\x18\x19\x20\x01(\x0b2\x16.FavoriteStickerActionR\x15favorit\
    eStickerAction\x12X\n\x19androidUnsupportedActions\x18\x1a\x20\x01(\x0b2\
    \x1a.AndroidUnsupportedActionsR\x19androidUnsupportedActions\"A\n\x11Rec\
    entEmojiWeight\x12\x14\n\x05emoji\x18\x01\x20\x01(\tR\x05emoji\x12\x16\n\
    \x06weight\x18\x02\x20\x01(\x02R\x06weight\"I\n\x13RecentStickerWeight\
    \x12\x1a\n\x08filehash\x18\x01\x20\x01(\tR\x08filehash\x12\x16\n\x06weig\
    ht\x18\x02\x20\x01(\x02R\x06weight\"\xce\x02\n\nSyncdPatch\x12'\n\x07ver\
    sion\x18\x01\x20\x01(\x0b2\r.SyncdVersionR\x07version\x12,\n\tmutations\
    \x18\x02\x20\x03(\x0b2\x0e.SyncdMutationR\tmutations\x12D\n\x11externalM\
    utations\x18\x03\x20\x01(\x0b2\x16.ExternalBlobReferenceR\x11externalMut\
    ations\x12\x20\n\x0bsnapshotMac\x18\x04\x20\x01(\x0cR\x0bsnapshotMac\x12\
    \x1a\n\x08patchMac\x18\x05\x20\x01(\x0cR\x08patchMac\x12\x1c\n\x05keyId\
    \x18\x06\x20\x01(\x0b2\x06.KeyIdR\x05keyId\x12%\n\x08exitCode\x18\x07\
    \x20\x01(\x0b2\t.ExitCodeR\x08exitCode\x12\x20\n\x0bdeviceIndex\x18\x08\
    \x20\x01(\rR\x0bdeviceIndex\"\xb3\x01\n\rSyncdMutation\x12H\n\toperation\
    \x18\x01\x20\x01(\x0e2*.SyncdMutation.SyncdMutationSyncdOperationR\toper\
    ation\x12$\n\x06record\x18\x02\x20\x01(\x0b2\x0c.SyncdRecordR\x06record\
    \"2\n\x1bSyncdMutationSyncdOperation\x12\x07\n\x03SET\x10\0\x12\n\n\x06R\
    EMOVE\x10\x01\">\n\x0eSyncdMutations\x12,\n\tmutations\x18\x01\x20\x03(\
    \x0b2\x0e.SyncdMutationR\tmutations\"\x90\x01\n\rSyncdSnapshot\x12'\n\
    \x07version\x18\x01\x20\x01(\x0b2\r.SyncdVersionR\x07version\x12&\n\x07r\
    ecords\x18\x02\x20\x03(\x0b2\x0c.SyncdRecordR\x07records\x12\x10\n\x03ma\
    c\x18\x03\x20\x01(\x0cR\x03mac\x12\x1c\n\x05keyId\x18\x04\x20\x01(\x0b2\
    \x06.KeyIdR\x05keyId\"\xd7\x01\n\x15ExternalBlobReference\x12\x1a\n\x08m\
    ediaKey\x18\x01\x20\x01(\x0cR\x08mediaKey\x12\x1e\n\ndirectPath\x18\x02\
    \x20\x01(\tR\ndirectPath\x12\x16\n\x06handle\x18\x03\x20\x01(\tR\x06hand\
    le\x12$\n\rfileSizeBytes\x18\x04\x20\x01(\x04R\rfileSizeBytes\x12\x1e\n\
    \nfileSha256\x18\x05\x20\x01(\x0cR\nfileSha256\x12$\n\rfileEncSha256\x18\
    \x06\x20\x01(\x0cR\rfileEncSha256\"q\n\x0bSyncdRecord\x12!\n\x05index\
    \x18\x01\x20\x01(\x0b2\x0b.SyncdIndexR\x05index\x12!\n\x05value\x18\x02\
    \x20\x01(\x0b2\x0b.SyncdValueR\x05value\x12\x1c\n\x05keyId\x18\x03\x20\
    \x01(\x0b2\x06.KeyIdR\x05keyId\"\x17\n\x05KeyId\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x0cR\x02id\"\x20\n\nSyncdValue\x12\x12\n\x04blob\x18\x01\x20\
    \x01(\x0cR\x04blob\"\x20\n\nSyncdIndex\x12\x12\n\x04blob\x18\x01\x20\x01\
    (\x0cR\x04blob\"2\n\x08ExitCode\x12\x12\n\x04code\x18\x01\x20\x01(\x04R\
    \x04code\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"(\n\x0cSyncdVers\
    ion\x12\x18\n\x07version\x18\x01\x20\x01(\x04R\x07version\"0\n\x12Server\
    ErrorReceipt\x12\x1a\n\x08stanzaId\x18\x01\x20\x01(\tR\x08stanzaId\"\x8f\
    \x02\n\x16MediaRetryNotification\x12\x1a\n\x08stanzaId\x18\x01\x20\x01(\
    \tR\x08stanzaId\x12\x1e\n\ndirectPath\x18\x02\x20\x01(\tR\ndirectPath\
    \x12P\n\x06result\x18\x03\x20\x01(\x0e28.MediaRetryNotification.MediaRet\
    ryNotificationResultTypeR\x06result\"g\n\x20MediaRetryNotificationResult\
    Type\x12\x11\n\rGENERAL_ERROR\x10\0\x12\x0b\n\x07SUCCESS\x10\x01\x12\r\n\
    \tNOT_FOUND\x10\x02\x12\x14\n\x10DECRYPTION_ERROR\x10\x03\"\x9b\x03\n\rM\
    sgOpaqueData\x12\x12\n\x04body\x18\x01\x20\x01(\tR\x04body\x12\x18\n\x07\
    caption\x18\x03\x20\x01(\tR\x07caption\x12\x10\n\x03lng\x18\x05\x20\x01(\
    \x01R\x03lng\x12\x10\n\x03lat\x18\x07\x20\x01(\x01R\x03lat\x12,\n\x11pay\
    mentAmount1000\x18\x08\x20\x01(\x05R\x11paymentAmount1000\x12.\n\x12paym\
    entNoteMsgBody\x18\t\x20\x01(\tR\x12paymentNoteMsgBody\x12\"\n\x0ccanoni\
    calUrl\x18\n\x20\x01(\tR\x0ccanonicalUrl\x12\x20\n\x0bmatchedText\x18\
    \x0b\x20\x01(\tR\x0bmatchedText\x12\x14\n\x05title\x18\x0c\x20\x01(\tR\
    \x05title\x12\x20\n\x0bdescription\x18\r\x20\x01(\tR\x0bdescription\x12,\
    \n\x11futureproofBuffer\x18\x0e\x20\x01(\x0cR\x11futureproofBuffer\x12\
    \x1c\n\tclientUrl\x18\x0f\x20\x01(\tR\tclientUrl\x12\x10\n\x03loc\x18\
    \x10\x20\x01(\tR\x03loc\"p\n\x10MsgRowOpaqueData\x12.\n\ncurrentMsg\x18\
    \x01\x20\x01(\x0b2\x0e.MsgOpaqueDataR\ncurrentMsg\x12,\n\tquotedMsg\x18\
    \x02\x20\x01(\x0b2\x0e.MsgOpaqueDataR\tquotedMsg\"\xd6\x01\n\x0eGlobalSe\
    ttings\x12D\n\x13lightThemeWallpaper\x18\x01\x20\x01(\x0b2\x12.Wallpaper\
    SettingsR\x13lightThemeWallpaper\x12:\n\x0fmediaVisibility\x18\x02\x20\
    \x01(\x0e2\x10.MediaVisibilityR\x0fmediaVisibility\x12B\n\x12darkThemeWa\
    llpaper\x18\x03\x20\x01(\x0b2\x12.WallpaperSettingsR\x12darkThemeWallpap\
    er\"I\n\x11WallpaperSettings\x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\
    \x08filename\x12\x18\n\x07opacity\x18\x02\x20\x01(\rR\x07opacity\"\xa8\
    \x01\n\x10GroupParticipant\x12\x18\n\x07userJid\x18\x01\x20\x02(\tR\x07u\
    serJid\x12:\n\x04rank\x18\x02\x20\x01(\x0e2&.GroupParticipant.GroupParti\
    cipantRankR\x04rank\">\n\x14GroupParticipantRank\x12\x0b\n\x07REGULAR\
    \x10\0\x12\t\n\x05ADMIN\x10\x01\x12\x0e\n\nSUPERADMIN\x10\x02\"6\n\x08Pu\
    shname\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1a\n\x08pushname\
    \x18\x02\x20\x01(\tR\x08pushname\"[\n\x0eHistorySyncMsg\x12)\n\x07messag\
    e\x18\x01\x20\x01(\x0b2\x0f.WebMessageInfoR\x07message\x12\x1e\n\nmsgOrd\
    erId\x18\x02\x20\x01(\x04R\nmsgOrderId\"\xec\n\n\x0cConversation\x12\x0e\
    \n\x02id\x18\x01\x20\x02(\tR\x02id\x12+\n\x08messages\x18\x02\x20\x03(\
    \x0b2\x0f.HistorySyncMsgR\x08messages\x12\x16\n\x06newJid\x18\x03\x20\
    \x01(\tR\x06newJid\x12\x16\n\x06oldJid\x18\x04\x20\x01(\tR\x06oldJid\x12\
    *\n\x10lastMsgTimestamp\x18\x05\x20\x01(\x04R\x10lastMsgTimestamp\x12\
    \x20\n\x0bunreadCount\x18\x06\x20\x01(\rR\x0bunreadCount\x12\x1a\n\x08re\
    adOnly\x18\x07\x20\x01(\x08R\x08readOnly\x122\n\x14endOfHistoryTransfer\
    \x18\x08\x20\x01(\x08R\x14endOfHistoryTransfer\x120\n\x13ephemeralExpira\
    tion\x18\t\x20\x01(\rR\x13ephemeralExpiration\x12<\n\x19ephemeralSetting\
    Timestamp\x18\n\x20\x01(\x03R\x19ephemeralSettingTimestamp\x12n\n\x18end\
    OfHistoryTransferType\x18\x0b\x20\x01(\x0e22.Conversation.ConversationEn\
    dOfHistoryTransferTypeR\x18endOfHistoryTransferType\x124\n\x15conversati\
    onTimestamp\x18\x0c\x20\x01(\x04R\x15conversationTimestamp\x12\x12\n\x04\
    name\x18\r\x20\x01(\tR\x04name\x12\x14\n\x05pHash\x18\x0e\x20\x01(\tR\
    \x05pHash\x12\x18\n\x07notSpam\x18\x0f\x20\x01(\x08R\x07notSpam\x12\x1a\
    \n\x08archived\x18\x10\x20\x01(\x08R\x08archived\x12=\n\x10disappearingM\
    ode\x18\x11\x20\x01(\x0b2\x11.DisappearingModeR\x10disappearingMode\x12.\
    \n\x12unreadMentionCount\x18\x12\x20\x01(\rR\x12unreadMentionCount\x12&\
    \n\x0emarkedAsUnread\x18\x13\x20\x01(\x08R\x0emarkedAsUnread\x123\n\x0bp\
    articipant\x18\x14\x20\x03(\x0b2\x11.GroupParticipantR\x0bparticipant\
    \x12\x18\n\x07tcToken\x18\x15\x20\x01(\x0cR\x07tcToken\x12*\n\x10tcToken\
    Timestamp\x18\x16\x20\x01(\x04R\x10tcTokenTimestamp\x12<\n\x19contactPri\
    maryIdentityKey\x18\x17\x20\x01(\x0cR\x19contactPrimaryIdentityKey\x12\
    \x16\n\x06pinned\x18\x18\x20\x01(\rR\x06pinned\x12\x20\n\x0bmuteEndTime\
    \x18\x19\x20\x01(\x04R\x0bmuteEndTime\x120\n\twallpaper\x18\x1a\x20\x01(\
    \x0b2\x12.WallpaperSettingsR\twallpaper\x12:\n\x0fmediaVisibility\x18\
    \x1b\x20\x01(\x0e2\x10.MediaVisibilityR\x0fmediaVisibility\x126\n\x16tcT\
    okenSenderTimestamp\x18\x1c\x20\x01(\x04R\x16tcTokenSenderTimestamp\x12\
    \x1c\n\tsuspended\x18\x1d\x20\x01(\x08R\tsuspended\"\x8c\x01\n$Conversat\
    ionEndOfHistoryTransferType\x120\n,COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_\
    PRIMARY\x10\0\x122\n.COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY\x10\
    \x01\"\xbd\x04\n\x0bHistorySync\x12C\n\x08syncType\x18\x01\x20\x02(\x0e2\
    '.HistorySync.HistorySyncHistorySyncTypeR\x08syncType\x123\n\rconversati\
    ons\x18\x02\x20\x03(\x0b2\r.ConversationR\rconversations\x12;\n\x10statu\
    sV3Messages\x18\x03\x20\x03(\x0b2\x0f.WebMessageInfoR\x10statusV3Message\
    s\x12\x1e\n\nchunkOrder\x18\x05\x20\x01(\rR\nchunkOrder\x12\x1a\n\x08pro\
    gress\x18\x06\x20\x01(\rR\x08progress\x12'\n\tpushnames\x18\x07\x20\x03(\
    \x0b2\t.PushnameR\tpushnames\x127\n\x0eglobalSettings\x18\x08\x20\x01(\
    \x0b2\x0f.GlobalSettingsR\x0eglobalSettings\x12.\n\x12threadIdUserSecret\
    \x18\t\x20\x01(\x0cR\x12threadIdUserSecret\x128\n\x17threadDsTimeframeOf\
    fset\x18\n\x20\x01(\rR\x17threadDsTimeframeOffset\"o\n\x1aHistorySyncHis\
    torySyncType\x12\x15\n\x11INITIAL_BOOTSTRAP\x10\0\x12\x15\n\x11INITIAL_S\
    TATUS_V3\x10\x01\x12\x08\n\x04FULL\x10\x02\x12\n\n\x06RECENT\x10\x03\x12\
    \r\n\tPUSH_NAME\x10\x04\"L\n\x10EphemeralSetting\x12\x1a\n\x08duration\
    \x18\x01\x20\x01(\x0fR\x08duration\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\
    \x10R\ttimestamp\"|\n\x15InteractiveAnnotation\x120\n\x0fpolygonVertices\
    \x18\x01\x20\x03(\x0b2\x06.PointR\x0fpolygonVertices\x12'\n\x08location\
    \x18\x02\x20\x01(\x0b2\t.LocationH\0R\x08locationB\x08\n\x06action\"\xa6\
    \x02\n\x12DeviceListMetadata\x12$\n\rsenderKeyHash\x18\x01\x20\x01(\x0cR\
    \rsenderKeyHash\x12(\n\x0fsenderTimestamp\x18\x02\x20\x01(\x04R\x0fsende\
    rTimestamp\x12.\n\x10senderKeyIndexes\x18\x03\x20\x03(\rR\x10senderKeyIn\
    dexesB\x02\x10\x01\x12*\n\x10recipientKeyHash\x18\x08\x20\x01(\x0cR\x10r\
    ecipientKeyHash\x12.\n\x12recipientTimestamp\x18\t\x20\x01(\x04R\x12reci\
    pientTimestamp\x124\n\x13recipientKeyIndexes\x18\n\x20\x03(\rR\x13recipi\
    entKeyIndexesB\x02\x10\x01\"\x97\x01\n\x12MessageContextInfo\x12C\n\x12d\
    eviceListMetadata\x18\x01\x20\x01(\x0b2\x13.DeviceListMetadataR\x12devic\
    eListMetadata\x12<\n\x19deviceListMetadataVersion\x18\x02\x20\x01(\x05R\
    \x19deviceListMetadataVersion\"\xee\x01\n\x0bAdReplyInfo\x12&\n\x0eadver\
    tiserName\x18\x01\x20\x01(\tR\x0eadvertiserName\x12?\n\tmediaType\x18\
    \x02\x20\x01(\x0e2!.AdReplyInfo.AdReplyInfoMediaTypeR\tmediaType\x12$\n\
    \rjpegThumbnail\x18\x10\x20\x01(\x0cR\rjpegThumbnail\x12\x18\n\x07captio\
    n\x18\x11\x20\x01(\tR\x07caption\"6\n\x14AdReplyInfoMediaType\x12\x08\n\
    \x04NONE\x10\0\x12\t\n\x05IMAGE\x10\x01\x12\t\n\x05VIDEO\x10\x02\"\xb6\
    \x03\n\x13ExternalAdReplyInfo\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05\
    title\x12\x12\n\x04body\x18\x02\x20\x01(\tR\x04body\x12O\n\tmediaType\
    \x18\x03\x20\x01(\x0e21.ExternalAdReplyInfo.ExternalAdReplyInfoMediaType\
    R\tmediaType\x12\"\n\x0cthumbnailUrl\x18\x04\x20\x01(\tR\x0cthumbnailUrl\
    \x12\x1a\n\x08mediaUrl\x18\x05\x20\x01(\tR\x08mediaUrl\x12\x1c\n\tthumbn\
    ail\x18\x06\x20\x01(\x0cR\tthumbnail\x12\x1e\n\nsourceType\x18\x07\x20\
    \x01(\tR\nsourceType\x12\x1a\n\x08sourceId\x18\x08\x20\x01(\tR\x08source\
    Id\x12\x1c\n\tsourceUrl\x18\t\x20\x01(\tR\tsourceUrl\x12,\n\x11containsA\
    utoReply\x18\n\x20\x01(\x08R\x11containsAutoReply\">\n\x1cExternalAdRepl\
    yInfoMediaType\x12\x08\n\x04NONE\x10\0\x12\t\n\x05IMAGE\x10\x01\x12\t\n\
    \x05VIDEO\x10\x02\"\xc6\x08\n\x0bContextInfo\x12\x1a\n\x08stanzaId\x18\
    \x01\x20\x01(\tR\x08stanzaId\x12\x20\n\x0bparticipant\x18\x02\x20\x01(\t\
    R\x0bparticipant\x12.\n\rquotedMessage\x18\x03\x20\x01(\x0b2\x08.Message\
    R\rquotedMessage\x12\x1c\n\tremoteJid\x18\x04\x20\x01(\tR\tremoteJid\x12\
    \"\n\x0cmentionedJid\x18\x0f\x20\x03(\tR\x0cmentionedJid\x12*\n\x10conve\
    rsionSource\x18\x12\x20\x01(\tR\x10conversionSource\x12&\n\x0econversion\
    Data\x18\x13\x20\x01(\x0cR\x0econversionData\x126\n\x16conversionDelaySe\
    conds\x18\x14\x20\x01(\rR\x16conversionDelaySeconds\x12(\n\x0fforwarding\
    Score\x18\x15\x20\x01(\rR\x0fforwardingScore\x12\x20\n\x0bisForwarded\
    \x18\x16\x20\x01(\x08R\x0bisForwarded\x12(\n\x08quotedAd\x18\x17\x20\x01\
    (\x0b2\x0c.AdReplyInfoR\x08quotedAd\x123\n\x0eplaceholderKey\x18\x18\x20\
    \x01(\x0b2\x0b.MessageKeyR\x0eplaceholderKey\x12\x1e\n\nexpiration\x18\
    \x19\x20\x01(\rR\nexpiration\x12<\n\x19ephemeralSettingTimestamp\x18\x1a\
    \x20\x01(\x03R\x19ephemeralSettingTimestamp\x124\n\x15ephemeralSharedSec\
    ret\x18\x1b\x20\x01(\x0cR\x15ephemeralSharedSecret\x12>\n\x0fexternalAdR\
    eply\x18\x1c\x20\x01(\x0b2\x14.ExternalAdReplyInfoR\x0fexternalAdReply\
    \x12>\n\x1aentryPointConversionSource\x18\x1d\x20\x01(\tR\x1aentryPointC\
    onversionSource\x128\n\x17entryPointConversionApp\x18\x1e\x20\x01(\tR\
    \x17entryPointConversionApp\x12J\n\x20entryPointConversionDelaySeconds\
    \x18\x1f\x20\x01(\rR\x20entryPointConversionDelaySeconds\x12=\n\x10disap\
    pearingMode\x18\x20\x20\x01(\x0b2\x11.DisappearingModeR\x10disappearingM\
    ode\x12+\n\nactionLink\x18!\x20\x01(\x0b2\x0b.ActionLinkR\nactionLink\
    \x12\"\n\x0cgroupSubject\x18\"\x20\x01(\tR\x0cgroupSubject\x12&\n\x0epar\
    entGroupJid\x18#\x20\x01(\tR\x0eparentGroupJid\"\x8a\x01\n\x1cSenderKeyD\
    istributionMessage\x12\x18\n\x07groupId\x18\x01\x20\x01(\tR\x07groupId\
    \x12P\n#axolotlSenderKeyDistributionMessage\x18\x02\x20\x01(\x0cR#axolot\
    lSenderKeyDistributionMessage\"\xf8\x07\n\x0cImageMessage\x12\x10\n\x03u\
    rl\x18\x01\x20\x01(\tR\x03url\x12\x1a\n\x08mimetype\x18\x02\x20\x01(\tR\
    \x08mimetype\x12\x18\n\x07caption\x18\x03\x20\x01(\tR\x07caption\x12\x1e\
    \n\nfileSha256\x18\x04\x20\x01(\x0cR\nfileSha256\x12\x1e\n\nfileLength\
    \x18\x05\x20\x01(\x04R\nfileLength\x12\x16\n\x06height\x18\x06\x20\x01(\
    \rR\x06height\x12\x14\n\x05width\x18\x07\x20\x01(\rR\x05width\x12\x1a\n\
    \x08mediaKey\x18\x08\x20\x01(\x0cR\x08mediaKey\x12$\n\rfileEncSha256\x18\
    \t\x20\x01(\x0cR\rfileEncSha256\x12N\n\x16interactiveAnnotations\x18\n\
    \x20\x03(\x0b2\x16.InteractiveAnnotationR\x16interactiveAnnotations\x12\
    \x1e\n\ndirectPath\x18\x0b\x20\x01(\tR\ndirectPath\x12,\n\x11mediaKeyTim\
    estamp\x18\x0c\x20\x01(\x03R\x11mediaKeyTimestamp\x12$\n\rjpegThumbnail\
    \x18\x10\x20\x01(\x0cR\rjpegThumbnail\x12.\n\x0bcontextInfo\x18\x11\x20\
    \x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\x12*\n\x10firstScanSidecar\
    \x18\x12\x20\x01(\x0cR\x10firstScanSidecar\x12(\n\x0ffirstScanLength\x18\
    \x13\x20\x01(\rR\x0ffirstScanLength\x12,\n\x11experimentGroupId\x18\x14\
    \x20\x01(\rR\x11experimentGroupId\x12\"\n\x0cscansSidecar\x18\x15\x20\
    \x01(\x0cR\x0cscansSidecar\x12\x20\n\x0bscanLengths\x18\x16\x20\x03(\rR\
    \x0bscanLengths\x122\n\x14midQualityFileSha256\x18\x17\x20\x01(\x0cR\x14\
    midQualityFileSha256\x128\n\x17midQualityFileEncSha256\x18\x18\x20\x01(\
    \x0cR\x17midQualityFileEncSha256\x12\x1a\n\x08viewOnce\x18\x19\x20\x01(\
    \x08R\x08viewOnce\x120\n\x13thumbnailDirectPath\x18\x1a\x20\x01(\tR\x13t\
    humbnailDirectPath\x12(\n\x0fthumbnailSha256\x18\x1b\x20\x01(\x0cR\x0fth\
    umbnailSha256\x12.\n\x12thumbnailEncSha256\x18\x1c\x20\x01(\x0cR\x12thum\
    bnailEncSha256\x12\x1c\n\tstaticUrl\x18\x1d\x20\x01(\tR\tstaticUrl\"\xc2\
    \x04\n\x0eInvoiceMessage\x12\x12\n\x04note\x18\x01\x20\x01(\tR\x04note\
    \x12\x14\n\x05token\x18\x02\x20\x01(\tR\x05token\x12T\n\x0eattachmentTyp\
    e\x18\x03\x20\x01(\x0e2,.InvoiceMessage.InvoiceMessageAttachmentTypeR\
    \x0eattachmentType\x12.\n\x12attachmentMimetype\x18\x04\x20\x01(\tR\x12a\
    ttachmentMimetype\x12.\n\x12attachmentMediaKey\x18\x05\x20\x01(\x0cR\x12\
    attachmentMediaKey\x12@\n\x1battachmentMediaKeyTimestamp\x18\x06\x20\x01\
    (\x03R\x1battachmentMediaKeyTimestamp\x122\n\x14attachmentFileSha256\x18\
    \x07\x20\x01(\x0cR\x14attachmentFileSha256\x128\n\x17attachmentFileEncSh\
    a256\x18\x08\x20\x01(\x0cR\x17attachmentFileEncSha256\x122\n\x14attachme\
    ntDirectPath\x18\t\x20\x01(\tR\x14attachmentDirectPath\x128\n\x17attachm\
    entJpegThumbnail\x18\n\x20\x01(\x0cR\x17attachmentJpegThumbnail\"2\n\x1c\
    InvoiceMessageAttachmentType\x12\t\n\x05IMAGE\x10\0\x12\x07\n\x03PDF\x10\
    \x01\"x\n\x0eContactMessage\x12\x20\n\x0bdisplayName\x18\x01\x20\x01(\tR\
    \x0bdisplayName\x12\x14\n\x05vcard\x18\x10\x20\x01(\tR\x05vcard\x12.\n\
    \x0bcontextInfo\x18\x11\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\"\
    \xc9\x03\n\x0fLocationMessage\x12(\n\x0fdegreesLatitude\x18\x01\x20\x01(\
    \x01R\x0fdegreesLatitude\x12*\n\x10degreesLongitude\x18\x02\x20\x01(\x01\
    R\x10degreesLongitude\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\
    \x18\n\x07address\x18\x04\x20\x01(\tR\x07address\x12\x10\n\x03url\x18\
    \x05\x20\x01(\tR\x03url\x12\x16\n\x06isLive\x18\x06\x20\x01(\x08R\x06isL\
    ive\x12*\n\x10accuracyInMeters\x18\x07\x20\x01(\rR\x10accuracyInMeters\
    \x12\x1e\n\nspeedInMps\x18\x08\x20\x01(\x02R\nspeedInMps\x12L\n!degreesC\
    lockwiseFromMagneticNorth\x18\t\x20\x01(\rR!degreesClockwiseFromMagnetic\
    North\x12\x18\n\x07comment\x18\x0b\x20\x01(\tR\x07comment\x12$\n\rjpegTh\
    umbnail\x18\x10\x20\x01(\x0cR\rjpegThumbnail\x12.\n\x0bcontextInfo\x18\
    \x11\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\"\xa5\t\n\x13Extended\
    TextMessage\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\x12\x20\n\x0bm\
    atchedText\x18\x02\x20\x01(\tR\x0bmatchedText\x12\"\n\x0ccanonicalUrl\
    \x18\x04\x20\x01(\tR\x0ccanonicalUrl\x12\x20\n\x0bdescription\x18\x05\
    \x20\x01(\tR\x0bdescription\x12\x14\n\x05title\x18\x06\x20\x01(\tR\x05ti\
    tle\x12\x1a\n\x08textArgb\x18\x07\x20\x01(\x07R\x08textArgb\x12&\n\x0eba\
    ckgroundArgb\x18\x08\x20\x01(\x07R\x0ebackgroundArgb\x12D\n\x04font\x18\
    \t\x20\x01(\x0e20.ExtendedTextMessage.ExtendedTextMessageFontTypeR\x04fo\
    nt\x12U\n\x0bpreviewType\x18\n\x20\x01(\x0e23.ExtendedTextMessage.Extend\
    edTextMessagePreviewTypeR\x0bpreviewType\x12$\n\rjpegThumbnail\x18\x10\
    \x20\x01(\x0cR\rjpegThumbnail\x12.\n\x0bcontextInfo\x18\x11\x20\x01(\x0b\
    2\x0c.ContextInfoR\x0bcontextInfo\x12(\n\x0fdoNotPlayInline\x18\x12\x20\
    \x01(\x08R\x0fdoNotPlayInline\x120\n\x13thumbnailDirectPath\x18\x13\x20\
    \x01(\tR\x13thumbnailDirectPath\x12(\n\x0fthumbnailSha256\x18\x14\x20\
    \x01(\x0cR\x0fthumbnailSha256\x12.\n\x12thumbnailEncSha256\x18\x15\x20\
    \x01(\x0cR\x12thumbnailEncSha256\x12\x1a\n\x08mediaKey\x18\x16\x20\x01(\
    \x0cR\x08mediaKey\x12,\n\x11mediaKeyTimestamp\x18\x17\x20\x01(\x03R\x11m\
    ediaKeyTimestamp\x12(\n\x0fthumbnailHeight\x18\x18\x20\x01(\rR\x0fthumbn\
    ailHeight\x12&\n\x0ethumbnailWidth\x18\x19\x20\x01(\rR\x0ethumbnailWidth\
    \x12m\n\x13inviteLinkGroupType\x18\x1a\x20\x01(\x0e2;.ExtendedTextMessag\
    e.ExtendedTextMessageInviteLinkGroupTypeR\x13inviteLinkGroupType\"\x89\
    \x01\n\x1bExtendedTextMessageFontType\x12\x0e\n\nSANS_SERIF\x10\0\x12\t\
    \n\x05SERIF\x10\x01\x12\x13\n\x0fNORICAN_REGULAR\x10\x02\x12\x11\n\rBRYN\
    DAN_WRITE\x10\x03\x12\x15\n\x11BEBASNEUE_REGULAR\x10\x04\x12\x10\n\x0cOS\
    WALD_HEAVY\x10\x05\"5\n\x1eExtendedTextMessagePreviewType\x12\x08\n\x04N\
    ONE\x10\0\x12\t\n\x05VIDEO\x10\x01\"A\n&ExtendedTextMessageInviteLinkGro\
    upType\x12\x0b\n\x07DEFAULT\x10\0\x12\n\n\x06PARENT\x10\x01\"\xb7\x05\n\
    \x0fDocumentMessage\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x1a\
    \n\x08mimetype\x18\x02\x20\x01(\tR\x08mimetype\x12\x14\n\x05title\x18\
    \x03\x20\x01(\tR\x05title\x12\x1e\n\nfileSha256\x18\x04\x20\x01(\x0cR\nf\
    ileSha256\x12\x1e\n\nfileLength\x18\x05\x20\x01(\x04R\nfileLength\x12\
    \x1c\n\tpageCount\x18\x06\x20\x01(\rR\tpageCount\x12\x1a\n\x08mediaKey\
    \x18\x07\x20\x01(\x0cR\x08mediaKey\x12\x1a\n\x08fileName\x18\x08\x20\x01\
    (\tR\x08fileName\x12$\n\rfileEncSha256\x18\t\x20\x01(\x0cR\rfileEncSha25\
    6\x12\x1e\n\ndirectPath\x18\n\x20\x01(\tR\ndirectPath\x12,\n\x11mediaKey\
    Timestamp\x18\x0b\x20\x01(\x03R\x11mediaKeyTimestamp\x12\"\n\x0ccontactV\
    card\x18\x0c\x20\x01(\x08R\x0ccontactVcard\x120\n\x13thumbnailDirectPath\
    \x18\r\x20\x01(\tR\x13thumbnailDirectPath\x12(\n\x0fthumbnailSha256\x18\
    \x0e\x20\x01(\x0cR\x0fthumbnailSha256\x12.\n\x12thumbnailEncSha256\x18\
    \x0f\x20\x01(\x0cR\x12thumbnailEncSha256\x12$\n\rjpegThumbnail\x18\x10\
    \x20\x01(\x0cR\rjpegThumbnail\x12.\n\x0bcontextInfo\x18\x11\x20\x01(\x0b\
    2\x0c.ContextInfoR\x0bcontextInfo\x12(\n\x0fthumbnailHeight\x18\x12\x20\
    \x01(\rR\x0fthumbnailHeight\x12&\n\x0ethumbnailWidth\x18\x13\x20\x01(\rR\
    \x0ethumbnailWidth\"\xb0\x03\n\x0cAudioMessage\x12\x10\n\x03url\x18\x01\
    \x20\x01(\tR\x03url\x12\x1a\n\x08mimetype\x18\x02\x20\x01(\tR\x08mimetyp\
    e\x12\x1e\n\nfileSha256\x18\x03\x20\x01(\x0cR\nfileSha256\x12\x1e\n\nfil\
    eLength\x18\x04\x20\x01(\x04R\nfileLength\x12\x18\n\x07seconds\x18\x05\
    \x20\x01(\rR\x07seconds\x12\x10\n\x03ptt\x18\x06\x20\x01(\x08R\x03ptt\
    \x12\x1a\n\x08mediaKey\x18\x07\x20\x01(\x0cR\x08mediaKey\x12$\n\rfileEnc\
    Sha256\x18\x08\x20\x01(\x0cR\rfileEncSha256\x12\x1e\n\ndirectPath\x18\t\
    \x20\x01(\tR\ndirectPath\x12,\n\x11mediaKeyTimestamp\x18\n\x20\x01(\x03R\
    \x11mediaKeyTimestamp\x12.\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x0c.Co\
    ntextInfoR\x0bcontextInfo\x12*\n\x10streamingSidecar\x18\x12\x20\x01(\
    \x0cR\x10streamingSidecar\x12\x1a\n\x08waveform\x18\x13\x20\x01(\x0cR\
    \x08waveform\"\xb2\x07\n\x0cVideoMessage\x12\x10\n\x03url\x18\x01\x20\
    \x01(\tR\x03url\x12\x1a\n\x08mimetype\x18\x02\x20\x01(\tR\x08mimetype\
    \x12\x1e\n\nfileSha256\x18\x03\x20\x01(\x0cR\nfileSha256\x12\x1e\n\nfile\
    Length\x18\x04\x20\x01(\x04R\nfileLength\x12\x18\n\x07seconds\x18\x05\
    \x20\x01(\rR\x07seconds\x12\x1a\n\x08mediaKey\x18\x06\x20\x01(\x0cR\x08m\
    ediaKey\x12\x18\n\x07caption\x18\x07\x20\x01(\tR\x07caption\x12\x20\n\
    \x0bgifPlayback\x18\x08\x20\x01(\x08R\x0bgifPlayback\x12\x16\n\x06height\
    \x18\t\x20\x01(\rR\x06height\x12\x14\n\x05width\x18\n\x20\x01(\rR\x05wid\
    th\x12$\n\rfileEncSha256\x18\x0b\x20\x01(\x0cR\rfileEncSha256\x12N\n\x16\
    interactiveAnnotations\x18\x0c\x20\x03(\x0b2\x16.InteractiveAnnotationR\
    \x16interactiveAnnotations\x12\x1e\n\ndirectPath\x18\r\x20\x01(\tR\ndire\
    ctPath\x12,\n\x11mediaKeyTimestamp\x18\x0e\x20\x01(\x03R\x11mediaKeyTime\
    stamp\x12$\n\rjpegThumbnail\x18\x10\x20\x01(\x0cR\rjpegThumbnail\x12.\n\
    \x0bcontextInfo\x18\x11\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\
    \x12*\n\x10streamingSidecar\x18\x12\x20\x01(\x0cR\x10streamingSidecar\
    \x12M\n\x0egifAttribution\x18\x13\x20\x01(\x0e2%.VideoMessage.VideoMessa\
    geAttributionR\x0egifAttribution\x12\x1a\n\x08viewOnce\x18\x14\x20\x01(\
    \x08R\x08viewOnce\x120\n\x13thumbnailDirectPath\x18\x15\x20\x01(\tR\x13t\
    humbnailDirectPath\x12(\n\x0fthumbnailSha256\x18\x16\x20\x01(\x0cR\x0fth\
    umbnailSha256\x12.\n\x12thumbnailEncSha256\x18\x17\x20\x01(\x0cR\x12thum\
    bnailEncSha256\x12\x1c\n\tstaticUrl\x18\x18\x20\x01(\tR\tstaticUrl\"9\n\
    \x17VideoMessageAttribution\x12\x08\n\x04NONE\x10\0\x12\t\n\x05GIPHY\x10\
    \x01\x12\t\n\x05TENOR\x10\x02\"\xac\x01\n\x04Call\x12\x18\n\x07callKey\
    \x18\x01\x20\x01(\x0cR\x07callKey\x12*\n\x10conversionSource\x18\x02\x20\
    \x01(\tR\x10conversionSource\x12&\n\x0econversionData\x18\x03\x20\x01(\
    \x0cR\x0econversionData\x126\n\x16conversionDelaySeconds\x18\x04\x20\x01\
    (\rR\x16conversionDelaySeconds\"8\n\x04Chat\x12\x20\n\x0bdisplayName\x18\
    \x01\x20\x01(\tR\x0bdisplayName\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02i\
    d\"\xb1\x08\n\x0fProtocolMessage\x12\x1d\n\x03key\x18\x01\x20\x01(\x0b2\
    \x0b.MessageKeyR\x03key\x128\n\x04type\x18\x02\x20\x01(\x0e2$.ProtocolMe\
    ssage.ProtocolMessageTypeR\x04type\x120\n\x13ephemeralExpiration\x18\x04\
    \x20\x01(\rR\x13ephemeralExpiration\x12<\n\x19ephemeralSettingTimestamp\
    \x18\x05\x20\x01(\x03R\x19ephemeralSettingTimestamp\x12R\n\x17historySyn\
    cNotification\x18\x06\x20\x01(\x0b2\x18.HistorySyncNotificationR\x17hist\
    orySyncNotification\x12I\n\x14appStateSyncKeyShare\x18\x07\x20\x01(\x0b2\
    \x15.AppStateSyncKeyShareR\x14appStateSyncKeyShare\x12O\n\x16appStateSyn\
    cKeyRequest\x18\x08\x20\x01(\x0b2\x17.AppStateSyncKeyRequestR\x16appStat\
    eSyncKeyRequest\x12\x7f\n&initialSecurityNotificationSettingSync\x18\t\
    \x20\x01(\x0b2'.InitialSecurityNotificationSettingSyncR&initialSecurityN\
    otificationSettingSync\x12s\n\"appStateFatalExceptionNotification\x18\n\
    \x20\x01(\x0b2#.AppStateFatalExceptionNotificationR\"appStateFatalExcept\
    ionNotification\x12=\n\x10disappearingMode\x18\x0b\x20\x01(\x0b2\x11.Dis\
    appearingModeR\x10disappearingMode\"\xaf\x02\n\x13ProtocolMessageType\
    \x12\n\n\x06REVOKE\x10\0\x12\x15\n\x11EPHEMERAL_SETTING\x10\x03\x12\x1b\
    \n\x17EPHEMERAL_SYNC_RESPONSE\x10\x04\x12\x1d\n\x19HISTORY_SYNC_NOTIFICA\
    TION\x10\x05\x12\x1c\n\x18APP_STATE_SYNC_KEY_SHARE\x10\x06\x12\x1e\n\x1a\
    APP_STATE_SYNC_KEY_REQUEST\x10\x07\x12\x1f\n\x1bMSG_FANOUT_BACKFILL_REQU\
    EST\x10\x08\x12.\n*INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC\x10\t\x12*\
    \n&APP_STATE_FATAL_EXCEPTION_NOTIFICATION\x10\n\"\xe3\x03\n\x17HistorySy\
    ncNotification\x12\x1e\n\nfileSha256\x18\x01\x20\x01(\x0cR\nfileSha256\
    \x12\x1e\n\nfileLength\x18\x02\x20\x01(\x04R\nfileLength\x12\x1a\n\x08me\
    diaKey\x18\x03\x20\x01(\x0cR\x08mediaKey\x12$\n\rfileEncSha256\x18\x04\
    \x20\x01(\x0cR\rfileEncSha256\x12\x1e\n\ndirectPath\x18\x05\x20\x01(\tR\
    \ndirectPath\x12[\n\x08syncType\x18\x06\x20\x01(\x0e2?.HistorySyncNotifi\
    cation.HistorySyncNotificationHistorySyncTypeR\x08syncType\x12\x1e\n\nch\
    unkOrder\x18\x07\x20\x01(\rR\nchunkOrder\x12,\n\x11originalMessageId\x18\
    \x08\x20\x01(\tR\x11originalMessageId\"{\n&HistorySyncNotificationHistor\
    ySyncType\x12\x15\n\x11INITIAL_BOOTSTRAP\x10\0\x12\x15\n\x11INITIAL_STAT\
    US_V3\x10\x01\x12\x08\n\x04FULL\x10\x02\x12\n\n\x06RECENT\x10\x03\x12\r\
    \n\tPUSH_NAME\x10\x04\"k\n\x0fAppStateSyncKey\x12(\n\x05keyId\x18\x01\
    \x20\x01(\x0b2\x12.AppStateSyncKeyIdR\x05keyId\x12.\n\x07keyData\x18\x02\
    \x20\x01(\x0b2\x14.AppStateSyncKeyDataR\x07keyData\")\n\x11AppStateSyncK\
    eyId\x12\x14\n\x05keyId\x18\x01\x20\x01(\x0cR\x05keyId\"\x80\x01\n\x1aAp\
    pStateSyncKeyFingerprint\x12\x14\n\x05rawId\x18\x01\x20\x01(\rR\x05rawId\
    \x12\"\n\x0ccurrentIndex\x18\x02\x20\x01(\rR\x0ccurrentIndex\x12(\n\rdev\
    iceIndexes\x18\x03\x20\x03(\rR\rdeviceIndexesB\x02\x10\x01\"\x8c\x01\n\
    \x13AppStateSyncKeyData\x12\x18\n\x07keyData\x18\x01\x20\x01(\x0cR\x07ke\
    yData\x12=\n\x0bfingerprint\x18\x02\x20\x01(\x0b2\x1b.AppStateSyncKeyFin\
    gerprintR\x0bfingerprint\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttim\
    estamp\"<\n\x14AppStateSyncKeyShare\x12$\n\x04keys\x18\x01\x20\x03(\x0b2\
    \x10.AppStateSyncKeyR\x04keys\"D\n\x16AppStateSyncKeyRequest\x12*\n\x06k\
    eyIds\x18\x01\x20\x03(\x0b2\x12.AppStateSyncKeyIdR\x06keyIds\"l\n\"AppSt\
    ateFatalExceptionNotification\x12(\n\x0fcollectionNames\x18\x01\x20\x03(\
    \tR\x0fcollectionNames\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimes\
    tamp\"j\n&InitialSecurityNotificationSettingSync\x12@\n\x1bsecurityNotif\
    icationEnabled\x18\x01\x20\x01(\x08R\x1bsecurityNotificationEnabled\"\
    \x95\x01\n\x14ContactsArrayMessage\x12\x20\n\x0bdisplayName\x18\x01\x20\
    \x01(\tR\x0bdisplayName\x12+\n\x08contacts\x18\x02\x20\x03(\x0b2\x0f.Con\
    tactMessageR\x08contacts\x12.\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x0c\
    .ContextInfoR\x0bcontextInfo\"Q\n\x0bHSMCurrency\x12\"\n\x0ccurrencyCode\
    \x18\x01\x20\x01(\tR\x0ccurrencyCode\x12\x1e\n\namount1000\x18\x02\x20\
    \x01(\x03R\namount1000\"\xfc\x03\n\x14HSMDateTimeComponent\x12U\n\tdayOf\
    Week\x18\x01\x20\x01(\x0e27.HSMDateTimeComponent.HSMDateTimeComponentDay\
    OfWeekTypeR\tdayOfWeek\x12\x12\n\x04year\x18\x02\x20\x01(\rR\x04year\x12\
    \x14\n\x05month\x18\x03\x20\x01(\rR\x05month\x12\x1e\n\ndayOfMonth\x18\
    \x04\x20\x01(\rR\ndayOfMonth\x12\x12\n\x04hour\x18\x05\x20\x01(\rR\x04ho\
    ur\x12\x16\n\x06minute\x18\x06\x20\x01(\rR\x06minute\x12R\n\x08calendar\
    \x18\x07\x20\x01(\x0e26.HSMDateTimeComponent.HSMDateTimeComponentCalenda\
    rTypeR\x08calendar\"\x7f\n!HSMDateTimeComponentDayOfWeekType\x12\n\n\x06\
    MONDAY\x10\x01\x12\x0b\n\x07TUESDAY\x10\x02\x12\r\n\tWEDNESDAY\x10\x03\
    \x12\x0c\n\x08THURSDAY\x10\x04\x12\n\n\x06FRIDAY\x10\x05\x12\x0c\n\x08SA\
    TURDAY\x10\x06\x12\n\n\x06SUNDAY\x10\x07\"B\n\x20HSMDateTimeComponentCal\
    endarType\x12\r\n\tGREGORIAN\x10\x01\x12\x0f\n\x0bSOLAR_HIJRI\x10\x02\"4\
    \n\x14HSMDateTimeUnixEpoch\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\tt\
    imestamp\"\x8c\x01\n\x0bHSMDateTime\x125\n\tcomponent\x18\x01\x20\x01(\
    \x0b2\x15.HSMDateTimeComponentH\0R\tcomponent\x125\n\tunixEpoch\x18\x02\
    \x20\x01(\x0b2\x15.HSMDateTimeUnixEpochH\0R\tunixEpochB\x0f\n\rdatetimeO\
    neof\"\x99\x01\n\x17HSMLocalizableParameter\x12\x18\n\x07default\x18\x01\
    \x20\x01(\tR\x07default\x12*\n\x08currency\x18\x02\x20\x01(\x0b2\x0c.HSM\
    CurrencyH\0R\x08currency\x12*\n\x08dateTime\x18\x03\x20\x01(\x0b2\x0c.HS\
    MDateTimeH\0R\x08dateTimeB\x0c\n\nparamOneof\"\x81\x03\n\x17HighlyStruct\
    uredMessage\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespace\x12\x20\
    \n\x0belementName\x18\x02\x20\x01(\tR\x0belementName\x12\x16\n\x06params\
    \x18\x03\x20\x03(\tR\x06params\x12\x1e\n\nfallbackLg\x18\x04\x20\x01(\tR\
    \nfallbackLg\x12\x1e\n\nfallbackLc\x18\x05\x20\x01(\tR\nfallbackLc\x12F\
    \n\x11localizableParams\x18\x06\x20\x03(\x0b2\x18.HSMLocalizableParamete\
    rR\x11localizableParams\x12(\n\x0fdeterministicLg\x18\x07\x20\x01(\tR\
    \x0fdeterministicLg\x12(\n\x0fdeterministicLc\x18\x08\x20\x01(\tR\x0fdet\
    erministicLc\x122\n\x0bhydratedHsm\x18\t\x20\x01(\x0b2\x10.TemplateMessa\
    geR\x0bhydratedHsm\"\xaf\x01\n\x12SendPaymentMessage\x12*\n\x0bnoteMessa\
    ge\x18\x02\x20\x01(\x0b2\x08.MessageR\x0bnoteMessage\x129\n\x11requestMe\
    ssageKey\x18\x03\x20\x01(\x0b2\x0b.MessageKeyR\x11requestMessageKey\x122\
    \n\nbackground\x18\x04\x20\x01(\x0b2\x12.PaymentBackgroundR\nbackground\
    \"\xb5\x02\n\x15RequestPaymentMessage\x12*\n\x0bnoteMessage\x18\x04\x20\
    \x01(\x0b2\x08.MessageR\x0bnoteMessage\x120\n\x13currencyCodeIso4217\x18\
    \x01\x20\x01(\tR\x13currencyCodeIso4217\x12\x1e\n\namount1000\x18\x02\
    \x20\x01(\x04R\namount1000\x12\x20\n\x0brequestFrom\x18\x03\x20\x01(\tR\
    \x0brequestFrom\x12(\n\x0fexpiryTimestamp\x18\x05\x20\x01(\x03R\x0fexpir\
    yTimestamp\x12\x1e\n\x06amount\x18\x06\x20\x01(\x0b2\x06.MoneyR\x06amoun\
    t\x122\n\nbackground\x18\x07\x20\x01(\x0b2\x12.PaymentBackgroundR\nbackg\
    round\"=\n\x1cDeclinePaymentRequestMessage\x12\x1d\n\x03key\x18\x01\x20\
    \x01(\x0b2\x0b.MessageKeyR\x03key\"<\n\x1bCancelPaymentRequestMessage\
    \x12\x1d\n\x03key\x18\x01\x20\x01(\x0b2\x0b.MessageKeyR\x03key\"\xe7\x01\
    \n\x14PaymentInviteMessage\x12W\n\x0bserviceType\x18\x01\x20\x01(\x0e25.\
    PaymentInviteMessage.PaymentInviteMessageServiceTypeR\x0bserviceType\x12\
    (\n\x0fexpiryTimestamp\x18\x02\x20\x01(\x03R\x0fexpiryTimestamp\"L\n\x1f\
    PaymentInviteMessageServiceType\x12\x0b\n\x07UNKNOWN\x10\0\x12\t\n\x05FB\
    PAY\x10\x01\x12\x08\n\x04NOVI\x10\x02\x12\x07\n\x03UPI\x10\x03\"\xbd\x03\
    \n\x13LiveLocationMessage\x12(\n\x0fdegreesLatitude\x18\x01\x20\x01(\x01\
    R\x0fdegreesLatitude\x12*\n\x10degreesLongitude\x18\x02\x20\x01(\x01R\
    \x10degreesLongitude\x12*\n\x10accuracyInMeters\x18\x03\x20\x01(\rR\x10a\
    ccuracyInMeters\x12\x1e\n\nspeedInMps\x18\x04\x20\x01(\x02R\nspeedInMps\
    \x12L\n!degreesClockwiseFromMagneticNorth\x18\x05\x20\x01(\rR!degreesClo\
    ckwiseFromMagneticNorth\x12\x18\n\x07caption\x18\x06\x20\x01(\tR\x07capt\
    ion\x12&\n\x0esequenceNumber\x18\x07\x20\x01(\x03R\x0esequenceNumber\x12\
    \x1e\n\ntimeOffset\x18\x08\x20\x01(\rR\ntimeOffset\x12$\n\rjpegThumbnail\
    \x18\x10\x20\x01(\x0cR\rjpegThumbnail\x12.\n\x0bcontextInfo\x18\x11\x20\
    \x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\"\x8a\x04\n\x0eStickerMessage\
    \x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x1e\n\nfileSha256\x18\
    \x02\x20\x01(\x0cR\nfileSha256\x12$\n\rfileEncSha256\x18\x03\x20\x01(\
    \x0cR\rfileEncSha256\x12\x1a\n\x08mediaKey\x18\x04\x20\x01(\x0cR\x08medi\
    aKey\x12\x1a\n\x08mimetype\x18\x05\x20\x01(\tR\x08mimetype\x12\x16\n\x06\
    height\x18\x06\x20\x01(\rR\x06height\x12\x14\n\x05width\x18\x07\x20\x01(\
    \rR\x05width\x12\x1e\n\ndirectPath\x18\x08\x20\x01(\tR\ndirectPath\x12\
    \x1e\n\nfileLength\x18\t\x20\x01(\x04R\nfileLength\x12,\n\x11mediaKeyTim\
    estamp\x18\n\x20\x01(\x03R\x11mediaKeyTimestamp\x12*\n\x10firstFrameLeng\
    th\x18\x0b\x20\x01(\rR\x10firstFrameLength\x12,\n\x11firstFrameSidecar\
    \x18\x0c\x20\x01(\x0cR\x11firstFrameSidecar\x12\x1e\n\nisAnimated\x18\r\
    \x20\x01(\x08R\nisAnimated\x12\"\n\x0cpngThumbnail\x18\x10\x20\x01(\x0cR\
    \x0cpngThumbnail\x12.\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x0c.Context\
    InfoR\x0bcontextInfo\"\xe7\x03\n\x0fFourRowTemplate\x122\n\x07content\
    \x18\x06\x20\x01(\x0b2\x18.HighlyStructuredMessageR\x07content\x120\n\
    \x06footer\x18\x07\x20\x01(\x0b2\x18.HighlyStructuredMessageR\x06footer\
    \x12)\n\x07buttons\x18\x08\x20\x03(\x0b2\x0f.TemplateButtonR\x07buttons\
    \x12<\n\x0fdocumentMessage\x18\x01\x20\x01(\x0b2\x10.DocumentMessageH\0R\
    \x0fdocumentMessage\x12T\n\x17highlyStructuredMessage\x18\x02\x20\x01(\
    \x0b2\x18.HighlyStructuredMessageH\0R\x17highlyStructuredMessage\x123\n\
    \x0cimageMessage\x18\x03\x20\x01(\x0b2\r.ImageMessageH\0R\x0cimageMessag\
    e\x123\n\x0cvideoMessage\x18\x04\x20\x01(\x0b2\r.VideoMessageH\0R\x0cvid\
    eoMessage\x12<\n\x0flocationMessage\x18\x05\x20\x01(\x0b2\x10.LocationMe\
    ssageH\0R\x0flocationMessageB\x07\n\x05title\"\xfd\x03\n\x17HydratedFour\
    RowTemplate\x120\n\x13hydratedContentText\x18\x06\x20\x01(\tR\x13hydrate\
    dContentText\x12.\n\x12hydratedFooterText\x18\x07\x20\x01(\tR\x12hydrate\
    dFooterText\x12A\n\x0fhydratedButtons\x18\x08\x20\x03(\x0b2\x17.Hydrated\
    TemplateButtonR\x0fhydratedButtons\x12\x1e\n\ntemplateId\x18\t\x20\x01(\
    \tR\ntemplateId\x12<\n\x0fdocumentMessage\x18\x01\x20\x01(\x0b2\x10.Docu\
    mentMessageH\0R\x0fdocumentMessage\x12.\n\x11hydratedTitleText\x18\x02\
    \x20\x01(\tH\0R\x11hydratedTitleText\x123\n\x0cimageMessage\x18\x03\x20\
    \x01(\x0b2\r.ImageMessageH\0R\x0cimageMessage\x123\n\x0cvideoMessage\x18\
    \x04\x20\x01(\x0b2\r.VideoMessageH\0R\x0cvideoMessage\x12<\n\x0flocation\
    Message\x18\x05\x20\x01(\x0b2\x10.LocationMessageH\0R\x0flocationMessage\
    B\x07\n\x05title\"\xa5\x02\n\x0fTemplateMessage\x12.\n\x0bcontextInfo\
    \x18\x03\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\x12D\n\x10hydrate\
    dTemplate\x18\x04\x20\x01(\x0b2\x18.HydratedFourRowTemplateR\x10hydrated\
    Template\x12<\n\x0ffourRowTemplate\x18\x01\x20\x01(\x0b2\x10.FourRowTemp\
    lateH\0R\x0ffourRowTemplate\x12T\n\x17hydratedFourRowTemplate\x18\x02\
    \x20\x01(\x0b2\x18.HydratedFourRowTemplateH\0R\x17hydratedFourRowTemplat\
    eB\x08\n\x06format\"\xc4\x01\n\x1aTemplateButtonReplyMessage\x12\x1e\n\n\
    selectedId\x18\x01\x20\x01(\tR\nselectedId\x120\n\x13selectedDisplayText\
    \x18\x02\x20\x01(\tR\x13selectedDisplayText\x12.\n\x0bcontextInfo\x18\
    \x03\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\x12$\n\rselectedIndex\
    \x18\x04\x20\x01(\rR\rselectedIndex\"|\n\x0fCatalogSnapshot\x121\n\x0cca\
    talogImage\x18\x01\x20\x01(\x0b2\r.ImageMessageR\x0ccatalogImage\x12\x14\
    \n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x20\n\x0bdescription\x18\
    \x03\x20\x01(\tR\x0bdescription\"\x9e\x03\n\x0fProductSnapshot\x121\n\
    \x0cproductImage\x18\x01\x20\x01(\x0b2\r.ImageMessageR\x0cproductImage\
    \x12\x1c\n\tproductId\x18\x02\x20\x01(\tR\tproductId\x12\x14\n\x05title\
    \x18\x03\x20\x01(\tR\x05title\x12\x20\n\x0bdescription\x18\x04\x20\x01(\
    \tR\x0bdescription\x12\"\n\x0ccurrencyCode\x18\x05\x20\x01(\tR\x0ccurren\
    cyCode\x12(\n\x0fpriceAmount1000\x18\x06\x20\x01(\x03R\x0fpriceAmount100\
    0\x12\x1e\n\nretailerId\x18\x07\x20\x01(\tR\nretailerId\x12\x10\n\x03url\
    \x18\x08\x20\x01(\tR\x03url\x12,\n\x11productImageCount\x18\t\x20\x01(\r\
    R\x11productImageCount\x12\"\n\x0cfirstImageId\x18\x0b\x20\x01(\tR\x0cfi\
    rstImageId\x120\n\x13salePriceAmount1000\x18\x0c\x20\x01(\x03R\x13salePr\
    iceAmount1000\"\xf0\x01\n\x0eProductMessage\x12*\n\x07product\x18\x01\
    \x20\x01(\x0b2\x10.ProductSnapshotR\x07product\x12*\n\x10businessOwnerJi\
    d\x18\x02\x20\x01(\tR\x10businessOwnerJid\x12*\n\x07catalog\x18\x04\x20\
    \x01(\x0b2\x10.CatalogSnapshotR\x07catalog\x12\x12\n\x04body\x18\x05\x20\
    \x01(\tR\x04body\x12\x16\n\x06footer\x18\x06\x20\x01(\tR\x06footer\x12.\
    \n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\
    \"\xac\x04\n\x0cOrderMessage\x12\x18\n\x07orderId\x18\x01\x20\x01(\tR\
    \x07orderId\x12\x1c\n\tthumbnail\x18\x02\x20\x01(\x0cR\tthumbnail\x12\
    \x1c\n\titemCount\x18\x03\x20\x01(\x05R\titemCount\x12=\n\x06status\x18\
    \x04\x20\x01(\x0e2%.OrderMessage.OrderMessageOrderStatusR\x06status\x12@\
    \n\x07surface\x18\x05\x20\x01(\x0e2&.OrderMessage.OrderMessageOrderSurfa\
    ceR\x07surface\x12\x18\n\x07message\x18\x06\x20\x01(\tR\x07message\x12\
    \x1e\n\norderTitle\x18\x07\x20\x01(\tR\norderTitle\x12\x1c\n\tsellerJid\
    \x18\x08\x20\x01(\tR\tsellerJid\x12\x14\n\x05token\x18\t\x20\x01(\tR\x05\
    token\x12(\n\x0ftotalAmount1000\x18\n\x20\x01(\x03R\x0ftotalAmount1000\
    \x12,\n\x11totalCurrencyCode\x18\x0b\x20\x01(\tR\x11totalCurrencyCode\
    \x12.\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontext\
    Info\"&\n\x17OrderMessageOrderStatus\x12\x0b\n\x07INQUIRY\x10\x01\"'\n\
    \x18OrderMessageOrderSurface\x12\x0b\n\x07CATALOG\x10\x01\"S\n\x03Row\
    \x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x20\n\x0bdescriptio\
    n\x18\x02\x20\x01(\tR\x0bdescription\x12\x14\n\x05rowId\x18\x03\x20\x01(\
    \tR\x05rowId\"9\n\x07Section\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05t\
    itle\x12\x18\n\x04rows\x18\x02\x20\x03(\x0b2\x04.RowR\x04rows\"'\n\x07Pr\
    oduct\x12\x1c\n\tproductId\x18\x01\x20\x01(\tR\tproductId\"L\n\x0eProduc\
    tSection\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12$\n\x08produ\
    cts\x18\x02\x20\x03(\x0b2\x08.ProductR\x08products\"\\\n\x16ProductListH\
    eaderImage\x12\x1c\n\tproductId\x18\x01\x20\x01(\tR\tproductId\x12$\n\rj\
    pegThumbnail\x18\x02\x20\x01(\x0cR\rjpegThumbnail\"\xb3\x01\n\x0fProduct\
    ListInfo\x129\n\x0fproductSections\x18\x01\x20\x03(\x0b2\x0f.ProductSect\
    ionR\x0fproductSections\x129\n\x0bheaderImage\x18\x02\x20\x01(\x0b2\x17.\
    ProductListHeaderImageR\x0bheaderImage\x12*\n\x10businessOwnerJid\x18\
    \x03\x20\x01(\tR\x10businessOwnerJid\"\x9e\x03\n\x0bListMessage\x12\x14\
    \n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x20\n\x0bdescription\x18\
    \x02\x20\x01(\tR\x0bdescription\x12\x1e\n\nbuttonText\x18\x03\x20\x01(\t\
    R\nbuttonText\x12<\n\x08listType\x18\x04\x20\x01(\x0e2\x20.ListMessage.L\
    istMessageListTypeR\x08listType\x12$\n\x08sections\x18\x05\x20\x03(\x0b2\
    \x08.SectionR\x08sections\x12:\n\x0fproductListInfo\x18\x06\x20\x01(\x0b\
    2\x10.ProductListInfoR\x0fproductListInfo\x12\x1e\n\nfooterText\x18\x07\
    \x20\x01(\tR\nfooterText\x12.\n\x0bcontextInfo\x18\x08\x20\x01(\x0b2\x0c\
    .ContextInfoR\x0bcontextInfo\"G\n\x13ListMessageListType\x12\x0b\n\x07UN\
    KNOWN\x10\0\x12\x11\n\rSINGLE_SELECT\x10\x01\x12\x10\n\x0cPRODUCT_LIST\
    \x10\x02\"9\n\x11SingleSelectReply\x12$\n\rselectedRowId\x18\x01\x20\x01\
    (\tR\rselectedRowId\"\xcc\x02\n\x13ListResponseMessage\x12\x14\n\x05titl\
    e\x18\x01\x20\x01(\tR\x05title\x12L\n\x08listType\x18\x02\x20\x01(\x0e20\
    .ListResponseMessage.ListResponseMessageListTypeR\x08listType\x12@\n\x11\
    singleSelectReply\x18\x03\x20\x01(\x0b2\x12.SingleSelectReplyR\x11single\
    SelectReply\x12.\n\x0bcontextInfo\x18\x04\x20\x01(\x0b2\x0c.ContextInfoR\
    \x0bcontextInfo\x12\x20\n\x0bdescription\x18\x05\x20\x01(\tR\x0bdescript\
    ion\"=\n\x1bListResponseMessageListType\x12\x0b\n\x07UNKNOWN\x10\0\x12\
    \x11\n\rSINGLE_SELECT\x10\x01\"\xc3\x02\n\x06Header\x12\x14\n\x05title\
    \x18\x01\x20\x01(\tR\x05title\x12\x1a\n\x08subtitle\x18\x02\x20\x01(\tR\
    \x08subtitle\x12.\n\x12hasMediaAttachment\x18\x05\x20\x01(\x08R\x12hasMe\
    diaAttachment\x12<\n\x0fdocumentMessage\x18\x03\x20\x01(\x0b2\x10.Docume\
    ntMessageH\0R\x0fdocumentMessage\x123\n\x0cimageMessage\x18\x04\x20\x01(\
    \x0b2\r.ImageMessageH\0R\x0cimageMessage\x12&\n\rjpegThumbnail\x18\x06\
    \x20\x01(\x0cH\0R\rjpegThumbnail\x123\n\x0cvideoMessage\x18\x07\x20\x01(\
    \x0b2\r.VideoMessageH\0R\x0cvideoMessageB\x07\n\x05media\"\x1a\n\x04Body\
    \x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"\x1c\n\x06Footer\x12\x12\
    \n\x04text\x18\x01\x20\x01(\tR\x04text\"\xc3\x01\n\x0bShopMessage\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x129\n\x07surface\x18\x02\x20\x01\
    (\x0e2\x1f.ShopMessage.ShopMessageSurfaceR\x07surface\x12&\n\x0emessageV\
    ersion\x18\x03\x20\x01(\x05R\x0emessageVersion\"A\n\x12ShopMessageSurfac\
    e\x12\x13\n\x0fUNKNOWN_SURFACE\x10\0\x12\x06\n\x02FB\x10\x01\x12\x06\n\
    \x02IG\x10\x02\x12\x06\n\x02WA\x10\x03\"c\n\x11CollectionMessage\x12\x16\
    \n\x06bizJid\x18\x01\x20\x01(\tR\x06bizJid\x12\x0e\n\x02id\x18\x02\x20\
    \x01(\tR\x02id\x12&\n\x0emessageVersion\x18\x03\x20\x01(\x05R\x0emessage\
    Version\"R\n\x10NativeFlowButton\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12*\n\x10buttonParamsJson\x18\x02\x20\x01(\tR\x10buttonParamsJ\
    son\"\x96\x01\n\x11NativeFlowMessage\x12+\n\x07buttons\x18\x01\x20\x03(\
    \x0b2\x11.NativeFlowButtonR\x07buttons\x12,\n\x11messageParamsJson\x18\
    \x02\x20\x01(\tR\x11messageParamsJson\x12&\n\x0emessageVersion\x18\x03\
    \x20\x01(\x05R\x0emessageVersion\"\x85\x03\n\x12InteractiveMessage\x12\
    \x1f\n\x06header\x18\x01\x20\x01(\x0b2\x07.HeaderR\x06header\x12\x19\n\
    \x04body\x18\x02\x20\x01(\x0b2\x05.BodyR\x04body\x12\x1f\n\x06footer\x18\
    \x03\x20\x01(\x0b2\x07.FooterR\x06footer\x12.\n\x0bcontextInfo\x18\x0f\
    \x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\x12D\n\x15shopStorefrontM\
    essage\x18\x04\x20\x01(\x0b2\x0c.ShopMessageH\0R\x15shopStorefrontMessag\
    e\x12B\n\x11collectionMessage\x18\x05\x20\x01(\x0b2\x12.CollectionMessag\
    eH\0R\x11collectionMessage\x12B\n\x11nativeFlowMessage\x18\x06\x20\x01(\
    \x0b2\x12.NativeFlowMessageH\0R\x11nativeFlowMessageB\x14\n\x12interacti\
    veMessage\"\x91\x03\n\x12GroupInviteMessage\x12\x1a\n\x08groupJid\x18\
    \x01\x20\x01(\tR\x08groupJid\x12\x1e\n\ninviteCode\x18\x02\x20\x01(\tR\n\
    inviteCode\x12*\n\x10inviteExpiration\x18\x03\x20\x01(\x03R\x10inviteExp\
    iration\x12\x1c\n\tgroupName\x18\x04\x20\x01(\tR\tgroupName\x12$\n\rjpeg\
    Thumbnail\x18\x05\x20\x01(\x0cR\rjpegThumbnail\x12\x18\n\x07caption\x18\
    \x06\x20\x01(\tR\x07caption\x12.\n\x0bcontextInfo\x18\x07\x20\x01(\x0b2\
    \x0c.ContextInfoR\x0bcontextInfo\x12M\n\tgroupType\x18\x08\x20\x01(\x0e2\
    /.GroupInviteMessage.GroupInviteMessageGroupTypeR\tgroupType\"6\n\x1bGro\
    upInviteMessageGroupType\x12\x0b\n\x07DEFAULT\x10\0\x12\n\n\x06PARENT\
    \x10\x01\"u\n\x11DeviceSentMessage\x12&\n\x0edestinationJid\x18\x01\x20\
    \x01(\tR\x0edestinationJid\x12\"\n\x07message\x18\x02\x20\x01(\x0b2\x08.\
    MessageR\x07message\x12\x14\n\x05phash\x18\x03\x20\x01(\tR\x05phash\"8\n\
    \x12FutureProofMessage\x12\"\n\x07message\x18\x01\x20\x01(\x0b2\x08.Mess\
    ageR\x07message\".\n\nButtonText\x12\x20\n\x0bdisplayText\x18\x01\x20\
    \x01(\tR\x0bdisplayText\"D\n\x0eNativeFlowInfo\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x1e\n\nparamsJson\x18\x02\x20\x01(\tR\nparamsJs\
    on\"\xec\x01\n\x06Button\x12\x1a\n\x08buttonId\x18\x01\x20\x01(\tR\x08bu\
    ttonId\x12+\n\nbuttonText\x18\x02\x20\x01(\x0b2\x0b.ButtonTextR\nbuttonT\
    ext\x12&\n\x04type\x18\x03\x20\x01(\x0e2\x12.Button.ButtonTypeR\x04type\
    \x127\n\x0enativeFlowInfo\x18\x04\x20\x01(\x0b2\x0f.NativeFlowInfoR\x0en\
    ativeFlowInfo\"8\n\nButtonType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0c\n\x08R\
    ESPONSE\x10\x01\x12\x0f\n\x0bNATIVE_FLOW\x10\x02\"\xe5\x04\n\x0eButtonsM\
    essage\x12\x20\n\x0bcontentText\x18\x06\x20\x01(\tR\x0bcontentText\x12\
    \x1e\n\nfooterText\x18\x07\x20\x01(\tR\nfooterText\x12.\n\x0bcontextInfo\
    \x18\x08\x20\x01(\x0b2\x0c.ContextInfoR\x0bcontextInfo\x12!\n\x07buttons\
    \x18\t\x20\x03(\x0b2\x07.ButtonR\x07buttons\x12H\n\nheaderType\x18\n\x20\
    \x01(\x0e2(.ButtonsMessage.ButtonsMessageHeaderTypeR\nheaderType\x12\x14\
    \n\x04text\x18\x01\x20\x01(\tH\0R\x04text\x12<\n\x0fdocumentMessage\x18\
    \x02\x20\x01(\x0b2\x10.DocumentMessageH\0R\x0fdocumentMessage\x123\n\x0c\
    imageMessage\x18\x03\x20\x01(\x0b2\r.ImageMessageH\0R\x0cimageMessage\
    \x123\n\x0cvideoMessage\x18\x04\x20\x01(\x0b2\r.VideoMessageH\0R\x0cvide\
    oMessage\x12<\n\x0flocationMessage\x18\x05\x20\x01(\x0b2\x10.LocationMes\
    sageH\0R\x0flocationMessage\"n\n\x18ButtonsMessageHeaderType\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\t\n\x05EMPTY\x10\x01\x12\x08\n\x04TEXT\x10\x02\x12\
    \x0c\n\x08DOCUMENT\x10\x03\x12\t\n\x05IMAGE\x10\x04\x12\t\n\x05VIDEO\x10\
    \x05\x12\x0c\n\x08LOCATION\x10\x06B\x08\n\x06header\"\xb9\x02\n\x16Butto\
    nsResponseMessage\x12*\n\x10selectedButtonId\x18\x01\x20\x01(\tR\x10sele\
    ctedButtonId\x12.\n\x0bcontextInfo\x18\x03\x20\x01(\x0b2\x0c.ContextInfo\
    R\x0bcontextInfo\x12F\n\x04type\x18\x04\x20\x01(\x0e22.ButtonsResponseMe\
    ssage.ButtonsResponseMessageTypeR\x04type\x122\n\x13selectedDisplayText\
    \x18\x02\x20\x01(\tH\0R\x13selectedDisplayText\";\n\x1aButtonsResponseMe\
    ssageType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x10\n\x0cDISPLAY_TEXT\x10\x01B\
    \n\n\x08response\"\x94\x01\n\x0fReactionMessage\x12\x1d\n\x03key\x18\x01\
    \x20\x01(\x0b2\x0b.MessageKeyR\x03key\x12\x12\n\x04text\x18\x02\x20\x01(\
    \tR\x04text\x12\x20\n\x0bgroupingKey\x18\x03\x20\x01(\tR\x0bgroupingKey\
    \x12,\n\x11senderTimestampMs\x18\x04\x20\x01(\x03R\x11senderTimestampMs\
    \"}\n\x15StickerSyncRMRMessage\x12\x1a\n\x08filehash\x18\x01\x20\x03(\tR\
    \x08filehash\x12\x1c\n\trmrSource\x18\x02\x20\x01(\tR\trmrSource\x12*\n\
    \x10requestTimestamp\x18\x03\x20\x01(\x03R\x10requestTimestamp\"\xaf\x14\
    \n\x07Message\x12\"\n\x0cconversation\x18\x01\x20\x01(\tR\x0cconversatio\
    n\x12a\n\x1csenderKeyDistributionMessage\x18\x02\x20\x01(\x0b2\x1d.Sende\
    rKeyDistributionMessageR\x1csenderKeyDistributionMessage\x121\n\x0cimage\
    Message\x18\x03\x20\x01(\x0b2\r.ImageMessageR\x0cimageMessage\x127\n\x0e\
    contactMessage\x18\x04\x20\x01(\x0b2\x0f.ContactMessageR\x0econtactMessa\
    ge\x12:\n\x0flocationMessage\x18\x05\x20\x01(\x0b2\x10.LocationMessageR\
    \x0flocationMessage\x12F\n\x13extendedTextMessage\x18\x06\x20\x01(\x0b2\
    \x14.ExtendedTextMessageR\x13extendedTextMessage\x12:\n\x0fdocumentMessa\
    ge\x18\x07\x20\x01(\x0b2\x10.DocumentMessageR\x0fdocumentMessage\x121\n\
    \x0caudioMessage\x18\x08\x20\x01(\x0b2\r.AudioMessageR\x0caudioMessage\
    \x121\n\x0cvideoMessage\x18\t\x20\x01(\x0b2\r.VideoMessageR\x0cvideoMess\
    age\x12\x19\n\x04call\x18\n\x20\x01(\x0b2\x05.CallR\x04call\x12\x19\n\
    \x04chat\x18\x0b\x20\x01(\x0b2\x05.ChatR\x04chat\x12:\n\x0fprotocolMessa\
    ge\x18\x0c\x20\x01(\x0b2\x10.ProtocolMessageR\x0fprotocolMessage\x12I\n\
    \x14contactsArrayMessage\x18\r\x20\x01(\x0b2\x15.ContactsArrayMessageR\
    \x14contactsArrayMessage\x12R\n\x17highlyStructuredMessage\x18\x0e\x20\
    \x01(\x0b2\x18.HighlyStructuredMessageR\x17highlyStructuredMessage\x12}\
    \n*fastRatchetKeySenderKeyDistributionMessage\x18\x0f\x20\x01(\x0b2\x1d.\
    SenderKeyDistributionMessageR*fastRatchetKeySenderKeyDistributionMessage\
    \x12C\n\x12sendPaymentMessage\x18\x10\x20\x01(\x0b2\x13.SendPaymentMessa\
    geR\x12sendPaymentMessage\x12F\n\x13liveLocationMessage\x18\x12\x20\x01(\
    \x0b2\x14.LiveLocationMessageR\x13liveLocationMessage\x12L\n\x15requestP\
    aymentMessage\x18\x16\x20\x01(\x0b2\x16.RequestPaymentMessageR\x15reques\
    tPaymentMessage\x12a\n\x1cdeclinePaymentRequestMessage\x18\x17\x20\x01(\
    \x0b2\x1d.DeclinePaymentRequestMessageR\x1cdeclinePaymentRequestMessage\
    \x12^\n\x1bcancelPaymentRequestMessage\x18\x18\x20\x01(\x0b2\x1c.CancelP\
    aymentRequestMessageR\x1bcancelPaymentRequestMessage\x12:\n\x0ftemplateM\
    essage\x18\x19\x20\x01(\x0b2\x10.TemplateMessageR\x0ftemplateMessage\x12\
    7\n\x0estickerMessage\x18\x1a\x20\x01(\x0b2\x0f.StickerMessageR\x0estick\
    erMessage\x12C\n\x12groupInviteMessage\x18\x1c\x20\x01(\x0b2\x13.GroupIn\
    viteMessageR\x12groupInviteMessage\x12[\n\x1atemplateButtonReplyMessage\
    \x18\x1d\x20\x01(\x0b2\x1b.TemplateButtonReplyMessageR\x1atemplateButton\
    ReplyMessage\x127\n\x0eproductMessage\x18\x1e\x20\x01(\x0b2\x0f.ProductM\
    essageR\x0eproductMessage\x12@\n\x11deviceSentMessage\x18\x1f\x20\x01(\
    \x0b2\x12.DeviceSentMessageR\x11deviceSentMessage\x12C\n\x12messageConte\
    xtInfo\x18#\x20\x01(\x0b2\x13.MessageContextInfoR\x12messageContextInfo\
    \x12.\n\x0blistMessage\x18$\x20\x01(\x0b2\x0c.ListMessageR\x0blistMessag\
    e\x12=\n\x0fviewOnceMessage\x18%\x20\x01(\x0b2\x13.FutureProofMessageR\
    \x0fviewOnceMessage\x121\n\x0corderMessage\x18&\x20\x01(\x0b2\r.OrderMes\
    sageR\x0corderMessage\x12F\n\x13listResponseMessage\x18'\x20\x01(\x0b2\
    \x14.ListResponseMessageR\x13listResponseMessage\x12?\n\x10ephemeralMess\
    age\x18(\x20\x01(\x0b2\x13.FutureProofMessageR\x10ephemeralMessage\x127\
    \n\x0einvoiceMessage\x18)\x20\x01(\x0b2\x0f.InvoiceMessageR\x0einvoiceMe\
    ssage\x127\n\x0ebuttonsMessage\x18*\x20\x01(\x0b2\x0f.ButtonsMessageR\
    \x0ebuttonsMessage\x12O\n\x16buttonsResponseMessage\x18+\x20\x01(\x0b2\
    \x17.ButtonsResponseMessageR\x16buttonsResponseMessage\x12I\n\x14payment\
    InviteMessage\x18,\x20\x01(\x0b2\x15.PaymentInviteMessageR\x14paymentInv\
    iteMessage\x12C\n\x12interactiveMessage\x18-\x20\x01(\x0b2\x13.Interacti\
    veMessageR\x12interactiveMessage\x12:\n\x0freactionMessage\x18.\x20\x01(\
    \x0b2\x10.ReactionMessageR\x0freactionMessage\x12L\n\x15stickerSyncRmrMe\
    ssage\x18/\x20\x01(\x0b2\x16.StickerSyncRMRMessageR\x15stickerSyncRmrMes\
    sage\"@\n\nActionLink\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\
    \x20\n\x0bbuttonTitle\x18\x02\x20\x01(\tR\x0bbuttonTitle\"\xbc\x01\n\x10\
    DisappearingMode\x12I\n\tinitiator\x18\x01\x20\x01(\x0e2+.DisappearingMo\
    de.DisappearingModeInitiatorR\tinitiator\"]\n\x19DisappearingModeInitiat\
    or\x12\x13\n\x0fCHANGED_IN_CHAT\x10\0\x12\x13\n\x0fINITIATED_BY_ME\x10\
    \x01\x12\x16\n\x12INITIATED_BY_OTHER\x10\x02\"\xbd\x01\n\x0bPBMediaData\
    \x12\x1a\n\x08mediaKey\x18\x01\x20\x01(\x0cR\x08mediaKey\x12,\n\x11media\
    KeyTimestamp\x18\x02\x20\x01(\x03R\x11mediaKeyTimestamp\x12\x1e\n\nfileS\
    ha256\x18\x03\x20\x01(\x0cR\nfileSha256\x12$\n\rfileEncSha256\x18\x04\
    \x20\x01(\x0cR\rfileEncSha256\x12\x1e\n\ndirectPath\x18\x05\x20\x01(\tR\
    \ndirectPath\"\x92\x03\n\x11PaymentBackground\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x1e\n\nfileLength\x18\x02\x20\x01(\x04R\nfileLeng\
    th\x12\x14\n\x05width\x18\x03\x20\x01(\rR\x05width\x12\x16\n\x06height\
    \x18\x04\x20\x01(\rR\x06height\x12\x1a\n\x08mimetype\x18\x05\x20\x01(\tR\
    \x08mimetype\x12(\n\x0fplaceholderArgb\x18\x06\x20\x01(\x07R\x0fplacehol\
    derArgb\x12\x1a\n\x08textArgb\x18\x07\x20\x01(\x07R\x08textArgb\x12\x20\
    \n\x0bsubtextArgb\x18\x08\x20\x01(\x07R\x0bsubtextArgb\x12*\n\tmediaData\
    \x18\t\x20\x01(\x0b2\x0c.PBMediaDataR\tmediaData\x12<\n\x04type\x18\n\
    \x20\x01(\x0e2(.PaymentBackground.PaymentBackgroundTypeR\x04type\"1\n\
    \x15PaymentBackgroundType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07DEFAUL\
    T\x10\x01\"Y\n\x05Money\x12\x14\n\x05value\x18\x01\x20\x01(\x03R\x05valu\
    e\x12\x16\n\x06offset\x18\x02\x20\x01(\rR\x06offset\x12\"\n\x0ccurrencyC\
    ode\x18\x03\x20\x01(\tR\x0ccurrencyCode\"L\n\x18HydratedQuickReplyButton\
    \x12\x20\n\x0bdisplayText\x18\x01\x20\x01(\tR\x0bdisplayText\x12\x0e\n\
    \x02id\x18\x02\x20\x01(\tR\x02id\"G\n\x11HydratedURLButton\x12\x20\n\x0b\
    displayText\x18\x01\x20\x01(\tR\x0bdisplayText\x12\x10\n\x03url\x18\x02\
    \x20\x01(\tR\x03url\"X\n\x12HydratedCallButton\x12\x20\n\x0bdisplayText\
    \x18\x01\x20\x01(\tR\x0bdisplayText\x12\x20\n\x0bphoneNumber\x18\x02\x20\
    \x01(\tR\x0bphoneNumber\"\xf4\x01\n\x16HydratedTemplateButton\x12\x14\n\
    \x05index\x18\x04\x20\x01(\rR\x05index\x12G\n\x10quickReplyButton\x18\
    \x01\x20\x01(\x0b2\x19.HydratedQuickReplyButtonH\0R\x10quickReplyButton\
    \x122\n\turlButton\x18\x02\x20\x01(\x0b2\x12.HydratedURLButtonH\0R\turlB\
    utton\x125\n\ncallButton\x18\x03\x20\x01(\x0b2\x13.HydratedCallButtonH\0\
    R\ncallButtonB\x10\n\x0ehydratedButton\"^\n\x10QuickReplyButton\x12:\n\
    \x0bdisplayText\x18\x01\x20\x01(\x0b2\x18.HighlyStructuredMessageR\x0bdi\
    splayText\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"s\n\tURLButton\x12:\
    \n\x0bdisplayText\x18\x01\x20\x01(\x0b2\x18.HighlyStructuredMessageR\x0b\
    displayText\x12*\n\x03url\x18\x02\x20\x01(\x0b2\x18.HighlyStructuredMess\
    ageR\x03url\"\x84\x01\n\nCallButton\x12:\n\x0bdisplayText\x18\x01\x20\
    \x01(\x0b2\x18.HighlyStructuredMessageR\x0bdisplayText\x12:\n\x0bphoneNu\
    mber\x18\x02\x20\x01(\x0b2\x18.HighlyStructuredMessageR\x0bphoneNumber\"\
    \xcc\x01\n\x0eTemplateButton\x12\x14\n\x05index\x18\x04\x20\x01(\rR\x05i\
    ndex\x12?\n\x10quickReplyButton\x18\x01\x20\x01(\x0b2\x11.QuickReplyButt\
    onH\0R\x10quickReplyButton\x12*\n\turlButton\x18\x02\x20\x01(\x0b2\n.URL\
    ButtonH\0R\turlButton\x12-\n\ncallButton\x18\x03\x20\x01(\x0b2\x0b.CallB\
    uttonH\0R\ncallButtonB\x08\n\x06button\"t\n\x08Location\x12(\n\x0fdegree\
    sLatitude\x18\x01\x20\x01(\x01R\x0fdegreesLatitude\x12*\n\x10degreesLong\
    itude\x18\x02\x20\x01(\x01R\x10degreesLongitude\x12\x12\n\x04name\x18\
    \x03\x20\x01(\tR\x04name\"g\n\x05Point\x12\x20\n\x0bxDeprecated\x18\x01\
    \x20\x01(\x05R\x0bxDeprecated\x12\x20\n\x0byDeprecated\x18\x02\x20\x01(\
    \x05R\x0byDeprecated\x12\x0c\n\x01x\x18\x03\x20\x01(\x01R\x01x\x12\x0c\n\
    \x01y\x18\x04\x20\x01(\x01R\x01y\"\xfe\x02\n\x0eCompanionProps\x12\x0e\n\
    \x02os\x18\x01\x20\x01(\tR\x02os\x12%\n\x07version\x18\x02\x20\x01(\x0b2\
    \x0b.AppVersionR\x07version\x12N\n\x0cplatformType\x18\x03\x20\x01(\x0e2\
    *.CompanionProps.CompanionPropsPlatformTypeR\x0cplatformType\x12(\n\x0fr\
    equireFullSync\x18\x04\x20\x01(\x08R\x0frequireFullSync\"\xba\x01\n\x1aC\
    ompanionPropsPlatformType\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06CHROME\
    \x10\x01\x12\x0b\n\x07FIREFOX\x10\x02\x12\x06\n\x02IE\x10\x03\x12\t\n\
    \x05OPERA\x10\x04\x12\n\n\x06SAFARI\x10\x05\x12\x08\n\x04EDGE\x10\x06\
    \x12\x0b\n\x07DESKTOP\x10\x07\x12\x08\n\x04IPAD\x10\x08\x12\x12\n\x0eAND\
    ROID_TABLET\x10\t\x12\t\n\x05OHANA\x10\n\x12\t\n\x05ALOHA\x10\x0b\x12\
    \x0c\n\x08CATALINA\x10\x0c\"K\n\x1bADVSignedDeviceIdentityHMAC\x12\x18\n\
    \x07details\x18\x01\x20\x01(\x0cR\x07details\x12\x12\n\x04hmac\x18\x02\
    \x20\x01(\x0cR\x04hmac\"\xbb\x01\n\x17ADVSignedDeviceIdentity\x12\x18\n\
    \x07details\x18\x01\x20\x01(\x0cR\x07details\x120\n\x13accountSignatureK\
    ey\x18\x02\x20\x01(\x0cR\x13accountSignatureKey\x12*\n\x10accountSignatu\
    re\x18\x03\x20\x01(\x0cR\x10accountSignature\x12(\n\x0fdeviceSignature\
    \x18\x04\x20\x01(\x0cR\x0fdeviceSignature\"c\n\x11ADVDeviceIdentity\x12\
    \x14\n\x05rawId\x18\x01\x20\x01(\rR\x05rawId\x12\x1c\n\ttimestamp\x18\
    \x02\x20\x01(\x04R\ttimestamp\x12\x1a\n\x08keyIndex\x18\x03\x20\x01(\rR\
    \x08keyIndex\"]\n\x15ADVSignedKeyIndexList\x12\x18\n\x07details\x18\x01\
    \x20\x01(\x0cR\x07details\x12*\n\x10accountSignature\x18\x02\x20\x01(\
    \x0cR\x10accountSignature\"\x91\x01\n\x0fADVKeyIndexList\x12\x14\n\x05ra\
    wId\x18\x01\x20\x01(\rR\x05rawId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\
    \x04R\ttimestamp\x12\"\n\x0ccurrentIndex\x18\x03\x20\x01(\rR\x0ccurrentI\
    ndex\x12&\n\x0cvalidIndexes\x18\x04\x20\x03(\rR\x0cvalidIndexesB\x02\x10\
    \x01\"t\n\nMessageKey\x12\x1c\n\tremoteJid\x18\x01\x20\x01(\tR\tremoteJi\
    d\x12\x16\n\x06fromMe\x18\x02\x20\x01(\x08R\x06fromMe\x12\x0e\n\x02id\
    \x18\x03\x20\x01(\tR\x02id\x12\x20\n\x0bparticipant\x18\x04\x20\x01(\tR\
    \x0bparticipant\"\xa5\x01\n\x08Reaction\x12\x1d\n\x03key\x18\x01\x20\x01\
    (\x0b2\x0b.MessageKeyR\x03key\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04t\
    ext\x12\x20\n\x0bgroupingKey\x18\x03\x20\x01(\tR\x0bgroupingKey\x12,\n\
    \x11senderTimestampMs\x18\x04\x20\x01(\x03R\x11senderTimestampMs\x12\x16\
    \n\x06unread\x18\x05\x20\x01(\x08R\x06unread\"\xff\x01\n\x0bUserReceipt\
    \x12\x18\n\x07userJid\x18\x01\x20\x02(\tR\x07userJid\x12*\n\x10receiptTi\
    mestamp\x18\x02\x20\x01(\x03R\x10receiptTimestamp\x12$\n\rreadTimestamp\
    \x18\x03\x20\x01(\x03R\rreadTimestamp\x12(\n\x0fplayedTimestamp\x18\x04\
    \x20\x01(\x03R\x0fplayedTimestamp\x12*\n\x10pendingDeviceJid\x18\x05\x20\
    \x03(\tR\x10pendingDeviceJid\x12.\n\x12deliveredDeviceJid\x18\x06\x20\
    \x03(\tR\x12deliveredDeviceJid\"m\n\tStatusPSA\x12\x1e\n\ncampaignId\x18\
    ,\x20\x02(\tR\ncampaignId\x12@\n\x1bcampaignExpirationTimestamp\x18-\x20\
    \x01(\x04R\x1bcampaignExpirationTimestamp\"e\n\x0bPhotoChange\x12\x1a\n\
    \x08oldPhoto\x18\x01\x20\x01(\x0cR\x08oldPhoto\x12\x1a\n\x08newPhoto\x18\
    \x02\x20\x01(\x0cR\x08newPhoto\x12\x1e\n\nnewPhotoId\x18\x03\x20\x01(\rR\
    \nnewPhotoId\")\n\tMediaData\x12\x1c\n\tlocalPath\x18\x01\x20\x01(\tR\tl\
    ocalPath\"\xfb\x1a\n\x0bWebFeatures\x12B\n\rlabelsDisplay\x18\x01\x20\
    \x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\rlabelsDisplay\x12T\n\x16voi\
    pIndividualOutgoing\x18\x02\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFla\
    gR\x16voipIndividualOutgoing\x128\n\x08groupsV3\x18\x03\x20\x01(\x0e2\
    \x1c.WebFeatures.WebFeaturesFlagR\x08groupsV3\x12D\n\x0egroupsV3Create\
    \x18\x04\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x0egroupsV3Creat\
    e\x12D\n\x0echangeNumberV2\x18\x05\x20\x01(\x0e2\x1c.WebFeatures.WebFeat\
    uresFlagR\x0echangeNumberV2\x12T\n\x16queryStatusV3Thumbnail\x18\x06\x20\
    \x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x16queryStatusV3Thumbnail\
    \x12B\n\rliveLocations\x18\x07\x20\x01(\x0e2\x1c.WebFeatures.WebFeatures\
    FlagR\rliveLocations\x12<\n\nqueryVname\x18\x08\x20\x01(\x0e2\x1c.WebFea\
    tures.WebFeaturesFlagR\nqueryVname\x12T\n\x16voipIndividualIncoming\x18\
    \t\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x16voipIndividualIncom\
    ing\x12J\n\x11quickRepliesQuery\x18\n\x20\x01(\x0e2\x1c.WebFeatures.WebF\
    eaturesFlagR\x11quickRepliesQuery\x128\n\x08payments\x18\x0b\x20\x01(\
    \x0e2\x1c.WebFeatures.WebFeaturesFlagR\x08payments\x12H\n\x10stickerPack\
    Query\x18\x0c\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x10stickerP\
    ackQuery\x12L\n\x12liveLocationsFinal\x18\r\x20\x01(\x0e2\x1c.WebFeature\
    s.WebFeaturesFlagR\x12liveLocationsFinal\x12<\n\nlabelsEdit\x18\x0e\x20\
    \x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\nlabelsEdit\x12>\n\x0bmediaU\
    pload\x18\x0f\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x0bmediaUpl\
    oad\x12^\n\x1bmediaUploadRichQuickReplies\x18\x12\x20\x01(\x0e2\x1c.WebF\
    eatures.WebFeaturesFlagR\x1bmediaUploadRichQuickReplies\x126\n\x07vnameV\
    2\x18\x13\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x07vnameV2\x12H\
    \n\x10videoPlaybackUrl\x18\x14\x20\x01(\x0e2\x1c.WebFeatures.WebFeatures\
    FlagR\x10videoPlaybackUrl\x12B\n\rstatusRanking\x18\x15\x20\x01(\x0e2\
    \x1c.WebFeatures.WebFeaturesFlagR\rstatusRanking\x12N\n\x13voipIndividua\
    lVideo\x18\x16\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x13voipInd\
    ividualVideo\x12L\n\x12thirdPartyStickers\x18\x17\x20\x01(\x0e2\x1c.WebF\
    eatures.WebFeaturesFlagR\x12thirdPartyStickers\x12\\\n\x1afrequentlyForw\
    ardedSetting\x18\x18\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x1af\
    requentlyForwardedSetting\x12T\n\x16groupsV4JoinPermission\x18\x19\x20\
    \x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x16groupsV4JoinPermission\
    \x12D\n\x0erecentStickers\x18\x1a\x20\x01(\x0e2\x1c.WebFeatures.WebFeatu\
    resFlagR\x0erecentStickers\x126\n\x07catalog\x18\x1b\x20\x01(\x0e2\x1c.W\
    ebFeatures.WebFeaturesFlagR\x07catalog\x12F\n\x0fstarredStickers\x18\x1c\
    \x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x0fstarredStickers\x12B\
    \n\rvoipGroupCall\x18\x1d\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\
    \rvoipGroupCall\x12F\n\x0ftemplateMessage\x18\x1e\x20\x01(\x0e2\x1c.WebF\
    eatures.WebFeaturesFlagR\x0ftemplateMessage\x12`\n\x1ctemplateMessageInt\
    eractivity\x18\x1f\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x1ctem\
    plateMessageInteractivity\x12J\n\x11ephemeralMessages\x18\x20\x20\x01(\
    \x0e2\x1c.WebFeatures.WebFeaturesFlagR\x11ephemeralMessages\x12N\n\x13e2\
    ENotificationSync\x18!\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\
    \x13e2ENotificationSync\x12H\n\x10recentStickersV2\x18\"\x20\x01(\x0e2\
    \x1c.WebFeatures.WebFeaturesFlagR\x10recentStickersV2\x12H\n\x10recentSt\
    ickersV3\x18$\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x10recentSt\
    ickersV3\x12<\n\nuserNotice\x18%\x20\x01(\x0e2\x1c.WebFeatures.WebFeatur\
    esFlagR\nuserNotice\x126\n\x07support\x18'\x20\x01(\x0e2\x1c.WebFeatures\
    .WebFeaturesFlagR\x07support\x12F\n\x0fgroupUiiCleanup\x18(\x20\x01(\x0e\
    2\x1c.WebFeatures.WebFeaturesFlagR\x0fgroupUiiCleanup\x12^\n\x1bgroupDog\
    foodingInternalOnly\x18)\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\
    \x1bgroupDogfoodingInternalOnly\x12@\n\x0csettingsSync\x18*\x20\x01(\x0e\
    2\x1c.WebFeatures.WebFeaturesFlagR\x0csettingsSync\x12:\n\tarchiveV2\x18\
    +\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\tarchiveV2\x12\\\n\x1ae\
    phemeralAllowGroupMembers\x18,\x20\x01(\x0e2\x1c.WebFeatures.WebFeatures\
    FlagR\x1aephemeralAllowGroupMembers\x12P\n\x14ephemeral24HDuration\x18-\
    \x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x14ephemeral24HDuration\
    \x12D\n\x0emdForceUpgrade\x18.\x20\x01(\x0e2\x1c.WebFeatures.WebFeatures\
    FlagR\x0emdForceUpgrade\x12H\n\x10disappearingMode\x18/\x20\x01(\x0e2\
    \x1c.WebFeatures.WebFeaturesFlagR\x10disappearingMode\x12X\n\x18external\
    MdOptInAvailable\x180\x20\x01(\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x18\
    externalMdOptInAvailable\x12X\n\x18noDeleteMessageTimeLimit\x181\x20\x01\
    (\x0e2\x1c.WebFeatures.WebFeaturesFlagR\x18noDeleteMessageTimeLimit\"V\n\
    \x0fWebFeaturesFlag\x12\x0f\n\x0bNOT_STARTED\x10\0\x12\x11\n\rFORCE_UPGR\
    ADE\x10\x01\x12\x0f\n\x0bDEVELOPMENT\x10\x02\x12\x0e\n\nPRODUCTION\x10\
    \x03\"\xaa\x01\n\x17NotificationMessageInfo\x12\x1d\n\x03key\x18\x01\x20\
    \x01(\x0b2\x0b.MessageKeyR\x03key\x12\"\n\x07message\x18\x02\x20\x01(\
    \x0b2\x08.MessageR\x07message\x12*\n\x10messageTimestamp\x18\x03\x20\x01\
    (\x04R\x10messageTimestamp\x12\x20\n\x0bparticipant\x18\x04\x20\x01(\tR\
    \x0bparticipant\"\xbf\x01\n\x14WebNotificationsInfo\x12\x1c\n\ttimestamp\
    \x18\x02\x20\x01(\x04R\ttimestamp\x12\x20\n\x0bunreadChats\x18\x03\x20\
    \x01(\rR\x0bunreadChats\x12.\n\x12notifyMessageCount\x18\x04\x20\x01(\rR\
    \x12notifyMessageCount\x127\n\x0enotifyMessages\x18\x05\x20\x03(\x0b2\
    \x0f.WebMessageInfoR\x0enotifyMessages\"\xf8\x0b\n\x0bPaymentInfo\x12P\n\
    \x12currencyDeprecated\x18\x01\x20\x01(\x0e2\x20.PaymentInfo.PaymentInfo\
    CurrencyR\x12currencyDeprecated\x12\x1e\n\namount1000\x18\x02\x20\x01(\
    \x04R\namount1000\x12\x20\n\x0breceiverJid\x18\x03\x20\x01(\tR\x0breceiv\
    erJid\x126\n\x06status\x18\x04\x20\x01(\x0e2\x1e.PaymentInfo.PaymentInfo\
    StatusR\x06status\x122\n\x14transactionTimestamp\x18\x05\x20\x01(\x04R\
    \x14transactionTimestamp\x129\n\x11requestMessageKey\x18\x06\x20\x01(\
    \x0b2\x0b.MessageKeyR\x11requestMessageKey\x12(\n\x0fexpiryTimestamp\x18\
    \x07\x20\x01(\x04R\x0fexpiryTimestamp\x12$\n\rfutureproofed\x18\x08\x20\
    \x01(\x08R\rfutureproofed\x12\x1a\n\x08currency\x18\t\x20\x01(\tR\x08cur\
    rency\x12?\n\ttxnStatus\x18\n\x20\x01(\x0e2!.PaymentInfo.PaymentInfoTxnS\
    tatusR\ttxnStatus\x12,\n\x11useNoviFiatFormat\x18\x0b\x20\x01(\x08R\x11u\
    seNoviFiatFormat\x12,\n\rprimaryAmount\x18\x0c\x20\x01(\x0b2\x06.MoneyR\
    \rprimaryAmount\x12.\n\x0eexchangeAmount\x18\r\x20\x01(\x0b2\x06.MoneyR\
    \x0eexchangeAmount\"4\n\x13PaymentInfoCurrency\x12\x14\n\x10UNKNOWN_CURR\
    ENCY\x10\0\x12\x07\n\x03INR\x10\x01\"\xd7\x01\n\x11PaymentInfoStatus\x12\
    \x12\n\x0eUNKNOWN_STATUS\x10\0\x12\x0e\n\nPROCESSING\x10\x01\x12\x08\n\
    \x04SENT\x10\x02\x12\x12\n\x0eNEED_TO_ACCEPT\x10\x03\x12\x0c\n\x08COMPLE\
    TE\x10\x04\x12\x16\n\x12COULD_NOT_COMPLETE\x10\x05\x12\x0c\n\x08REFUNDED\
    \x10\x06\x12\x0b\n\x07EXPIRED\x10\x07\x12\x0c\n\x08REJECTED\x10\x08\x12\
    \r\n\tCANCELLED\x10\t\x12\x15\n\x11WAITING_FOR_PAYER\x10\n\x12\x0b\n\x07\
    WAITING\x10\x0b\"\xe4\x04\n\x14PaymentInfoTxnStatus\x12\x0b\n\x07UNKNOWN\
    \x10\0\x12\x11\n\rPENDING_SETUP\x10\x01\x12\x1a\n\x16PENDING_RECEIVER_SE\
    TUP\x10\x02\x12\x08\n\x04INIT\x10\x03\x12\x0b\n\x07SUCCESS\x10\x04\x12\r\
    \n\tCOMPLETED\x10\x05\x12\n\n\x06FAILED\x10\x06\x12\x0f\n\x0bFAILED_RISK\
    \x10\x07\x12\x15\n\x11FAILED_PROCESSING\x10\x08\x12\x1e\n\x1aFAILED_RECE\
    IVER_PROCESSING\x10\t\x12\r\n\tFAILED_DA\x10\n\x12\x13\n\x0fFAILED_DA_FI\
    NAL\x10\x0b\x12\x10\n\x0cREFUNDED_TXN\x10\x0c\x12\x11\n\rREFUND_FAILED\
    \x10\r\x12\x1c\n\x18REFUND_FAILED_PROCESSING\x10\x0e\x12\x14\n\x10REFUND\
    _FAILED_DA\x10\x0f\x12\x0f\n\x0bEXPIRED_TXN\x10\x10\x12\x11\n\rAUTH_CANC\
    ELED\x10\x11\x12!\n\x1dAUTH_CANCEL_FAILED_PROCESSING\x10\x12\x12\x16\n\
    \x12AUTH_CANCEL_FAILED\x10\x13\x12\x10\n\x0cCOLLECT_INIT\x10\x14\x12\x13\
    \n\x0fCOLLECT_SUCCESS\x10\x15\x12\x12\n\x0eCOLLECT_FAILED\x10\x16\x12\
    \x17\n\x13COLLECT_FAILED_RISK\x10\x17\x12\x14\n\x10COLLECT_REJECTED\x10\
    \x18\x12\x13\n\x0fCOLLECT_EXPIRED\x10\x19\x12\x14\n\x10COLLECT_CANCELED\
    \x10\x1a\x12\x16\n\x12COLLECT_CANCELLING\x10\x1b\x12\r\n\tIN_REVIEW\x10\
    \x1c\"\xbf1\n\x0eWebMessageInfo\x12\x1d\n\x03key\x18\x01\x20\x02(\x0b2\
    \x0b.MessageKeyR\x03key\x12\"\n\x07message\x18\x02\x20\x01(\x0b2\x08.Mes\
    sageR\x07message\x12*\n\x10messageTimestamp\x18\x03\x20\x01(\x04R\x10mes\
    sageTimestamp\x12<\n\x06status\x18\x04\x20\x01(\x0e2$.WebMessageInfo.Web\
    MessageInfoStatusR\x06status\x12\x20\n\x0bparticipant\x18\x05\x20\x01(\t\
    R\x0bparticipant\x120\n\x13messageC2STimestamp\x18\x06\x20\x01(\x04R\x13\
    messageC2STimestamp\x12\x16\n\x06ignore\x18\x10\x20\x01(\x08R\x06ignore\
    \x12\x18\n\x07starred\x18\x11\x20\x01(\x08R\x07starred\x12\x1c\n\tbroadc\
    ast\x18\x12\x20\x01(\x08R\tbroadcast\x12\x1a\n\x08pushName\x18\x13\x20\
    \x01(\tR\x08pushName\x124\n\x15mediaCiphertextSha256\x18\x14\x20\x01(\
    \x0cR\x15mediaCiphertextSha256\x12\x1c\n\tmulticast\x18\x15\x20\x01(\x08\
    R\tmulticast\x12\x18\n\x07urlText\x18\x16\x20\x01(\x08R\x07urlText\x12\
    \x1c\n\turlNumber\x18\x17\x20\x01(\x08R\turlNumber\x12P\n\x0fmessageStub\
    Type\x18\x18\x20\x01(\x0e2&.WebMessageInfo.WebMessageInfoStubTypeR\x0fme\
    ssageStubType\x12\x1e\n\nclearMedia\x18\x19\x20\x01(\x08R\nclearMedia\
    \x124\n\x15messageStubParameters\x18\x1a\x20\x03(\tR\x15messageStubParam\
    eters\x12\x1a\n\x08duration\x18\x1b\x20\x01(\rR\x08duration\x12\x16\n\
    \x06labels\x18\x1c\x20\x03(\tR\x06labels\x12.\n\x0bpaymentInfo\x18\x1d\
    \x20\x01(\x0b2\x0c.PaymentInfoR\x0bpaymentInfo\x12B\n\x11finalLiveLocati\
    on\x18\x1e\x20\x01(\x0b2\x14.LiveLocationMessageR\x11finalLiveLocation\
    \x12:\n\x11quotedPaymentInfo\x18\x1f\x20\x01(\x0b2\x0c.PaymentInfoR\x11q\
    uotedPaymentInfo\x128\n\x17ephemeralStartTimestamp\x18\x20\x20\x01(\x04R\
    \x17ephemeralStartTimestamp\x12,\n\x11ephemeralDuration\x18!\x20\x01(\rR\
    \x11ephemeralDuration\x12*\n\x10ephemeralOffToOn\x18\"\x20\x01(\x08R\x10\
    ephemeralOffToOn\x12.\n\x12ephemeralOutOfSync\x18#\x20\x01(\x08R\x12ephe\
    meralOutOfSync\x12Z\n\x10bizPrivacyStatus\x18$\x20\x01(\x0e2..WebMessage\
    Info.WebMessageInfoBizPrivacyStatusR\x10bizPrivacyStatus\x12(\n\x0fverif\
    iedBizName\x18%\x20\x01(\tR\x0fverifiedBizName\x12(\n\tmediaData\x18&\
    \x20\x01(\x0b2\n.MediaDataR\tmediaData\x12.\n\x0bphotoChange\x18'\x20\
    \x01(\x0b2\x0c.PhotoChangeR\x0bphotoChange\x12.\n\x0buserReceipt\x18(\
    \x20\x03(\x0b2\x0c.UserReceiptR\x0buserReceipt\x12'\n\treactions\x18)\
    \x20\x03(\x0b2\t.ReactionR\treactions\x128\n\x11quotedStickerData\x18*\
    \x20\x01(\x0b2\n.MediaDataR\x11quotedStickerData\x12(\n\x0ffutureproofDa\
    ta\x18+\x20\x01(\x0cR\x0ffutureproofData\x12(\n\tstatusPsa\x18,\x20\x01(\
    \x0b2\n.StatusPSAR\tstatusPsa\"f\n\x14WebMessageInfoStatus\x12\t\n\x05ER\
    ROR\x10\0\x12\x0b\n\x07PENDING\x10\x01\x12\x0e\n\nSERVER_ACK\x10\x02\x12\
    \x10\n\x0cDELIVERY_ACK\x10\x03\x12\x08\n\x04READ\x10\x04\x12\n\n\x06PLAY\
    ED\x10\x05\"\xe7#\n\x16WebMessageInfoStubType\x12\x0b\n\x07UNKNOWN\x10\0\
    \x12\n\n\x06REVOKE\x10\x01\x12\x0e\n\nCIPHERTEXT\x10\x02\x12\x0f\n\x0bFU\
    TUREPROOF\x10\x03\x12\x1b\n\x17NON_VERIFIED_TRANSITION\x10\x04\x12\x19\n\
    \x15UNVERIFIED_TRANSITION\x10\x05\x12\x17\n\x13VERIFIED_TRANSITION\x10\
    \x06\x12\x18\n\x14VERIFIED_LOW_UNKNOWN\x10\x07\x12\x11\n\rVERIFIED_HIGH\
    \x10\x08\x12\x1c\n\x18VERIFIED_INITIAL_UNKNOWN\x10\t\x12\x18\n\x14VERIFI\
    ED_INITIAL_LOW\x10\n\x12\x19\n\x15VERIFIED_INITIAL_HIGH\x10\x0b\x12#\n\
    \x1fVERIFIED_TRANSITION_ANY_TO_NONE\x10\x0c\x12#\n\x1fVERIFIED_TRANSITIO\
    N_ANY_TO_HIGH\x10\r\x12#\n\x1fVERIFIED_TRANSITION_HIGH_TO_LOW\x10\x0e\
    \x12'\n#VERIFIED_TRANSITION_HIGH_TO_UNKNOWN\x10\x0f\x12&\n\"VERIFIED_TRA\
    NSITION_UNKNOWN_TO_LOW\x10\x10\x12&\n\"VERIFIED_TRANSITION_LOW_TO_UNKNOW\
    N\x10\x11\x12#\n\x1fVERIFIED_TRANSITION_NONE_TO_LOW\x10\x12\x12'\n#VERIF\
    IED_TRANSITION_NONE_TO_UNKNOWN\x10\x13\x12\x10\n\x0cGROUP_CREATE\x10\x14\
    \x12\x18\n\x14GROUP_CHANGE_SUBJECT\x10\x15\x12\x15\n\x11GROUP_CHANGE_ICO\
    N\x10\x16\x12\x1c\n\x18GROUP_CHANGE_INVITE_LINK\x10\x17\x12\x1c\n\x18GRO\
    UP_CHANGE_DESCRIPTION\x10\x18\x12\x19\n\x15GROUP_CHANGE_RESTRICT\x10\x19\
    \x12\x19\n\x15GROUP_CHANGE_ANNOUNCE\x10\x1a\x12\x19\n\x15GROUP_PARTICIPA\
    NT_ADD\x10\x1b\x12\x1c\n\x18GROUP_PARTICIPANT_REMOVE\x10\x1c\x12\x1d\n\
    \x19GROUP_PARTICIPANT_PROMOTE\x10\x1d\x12\x1c\n\x18GROUP_PARTICIPANT_DEM\
    OTE\x10\x1e\x12\x1c\n\x18GROUP_PARTICIPANT_INVITE\x10\x1f\x12\x1b\n\x17G\
    ROUP_PARTICIPANT_LEAVE\x10\x20\x12#\n\x1fGROUP_PARTICIPANT_CHANGE_NUMBER\
    \x10!\x12\x14\n\x10BROADCAST_CREATE\x10\"\x12\x11\n\rBROADCAST_ADD\x10#\
    \x12\x14\n\x10BROADCAST_REMOVE\x10$\x12\x18\n\x14GENERIC_NOTIFICATION\
    \x10%\x12\x18\n\x14E2E_IDENTITY_CHANGED\x10&\x12\x11\n\rE2E_ENCRYPTED\
    \x10'\x12\x15\n\x11CALL_MISSED_VOICE\x10(\x12\x15\n\x11CALL_MISSED_VIDEO\
    \x10)\x12\x1c\n\x18INDIVIDUAL_CHANGE_NUMBER\x10*\x12\x10\n\x0cGROUP_DELE\
    TE\x10+\x12&\n\"GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE\x10,\x12\x1b\n\x17CAL\
    L_MISSED_GROUP_VOICE\x10-\x12\x1b\n\x17CALL_MISSED_GROUP_VIDEO\x10.\x12\
    \x16\n\x12PAYMENT_CIPHERTEXT\x10/\x12\x17\n\x13PAYMENT_FUTUREPROOF\x100\
    \x12,\n(PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED\x101\x12.\n*PAYMENT_TRA\
    NSACTION_STATUS_UPDATE_REFUNDED\x102\x123\n/PAYMENT_TRANSACTION_STATUS_U\
    PDATE_REFUND_FAILED\x103\x125\n1PAYMENT_TRANSACTION_STATUS_RECEIVER_PEND\
    ING_SETUP\x104\x12<\n8PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_\
    HICCUP\x105\x12)\n%PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER\x106\x12(\n$PAY\
    MENT_ACTION_SEND_PAYMENT_REMINDER\x107\x12*\n&PAYMENT_ACTION_SEND_PAYMEN\
    T_INVITATION\x108\x12#\n\x1fPAYMENT_ACTION_REQUEST_DECLINED\x109\x12\"\n\
    \x1ePAYMENT_ACTION_REQUEST_EXPIRED\x10:\x12$\n\x20PAYMENT_ACTION_REQUEST\
    _CANCELLED\x10;\x12)\n%BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM\x10<\x12)\n\
    %BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP\x10=\x12\x11\n\rBIZ_INTRO_TOP\x10\
    >\x12\x14\n\x10BIZ_INTRO_BOTTOM\x10?\x12\x13\n\x0fBIZ_NAME_CHANGE\x10@\
    \x12\x1c\n\x18BIZ_MOVE_TO_CONSUMER_APP\x10A\x12\x1e\n\x1aBIZ_TWO_TIER_MI\
    GRATION_TOP\x10B\x12!\n\x1dBIZ_TWO_TIER_MIGRATION_BOTTOM\x10C\x12\r\n\tO\
    VERSIZED\x10D\x12(\n$GROUP_CHANGE_NO_FREQUENTLY_FORWARDED\x10E\x12\x1c\n\
    \x18GROUP_V4_ADD_INVITE_SENT\x10F\x12&\n\"GROUP_PARTICIPANT_ADD_REQUEST_\
    JOIN\x10G\x12\x1c\n\x18CHANGE_EPHEMERAL_SETTING\x10H\x12\x16\n\x12E2E_DE\
    VICE_CHANGED\x10I\x12\x0f\n\x0bVIEWED_ONCE\x10J\x12\x15\n\x11E2E_ENCRYPT\
    ED_NOW\x10K\x12\"\n\x1eBLUE_MSG_BSP_FB_TO_BSP_PREMISE\x10L\x12\x1e\n\x1a\
    BLUE_MSG_BSP_FB_TO_SELF_FB\x10M\x12#\n\x1fBLUE_MSG_BSP_FB_TO_SELF_PREMIS\
    E\x10N\x12\x1e\n\x1aBLUE_MSG_BSP_FB_UNVERIFIED\x10O\x127\n3BLUE_MSG_BSP_\
    FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED\x10P\x12\x1c\n\x18BLUE_MSG_BSP_FB\
    _VERIFIED\x10Q\x127\n3BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIE\
    D\x10R\x12(\n$BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE\x10S\x12#\n\x1fBLUE_M\
    SG_BSP_PREMISE_UNVERIFIED\x10T\x12<\n8BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO\
    _SELF_PREMISE_VERIFIED\x10U\x12!\n\x1dBLUE_MSG_BSP_PREMISE_VERIFIED\x10V\
    \x12<\n8BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED\x10W\
    \x12*\n&BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED\x10X\x12/\n+BLUE_MSG_CONS\
    UMER_TO_BSP_PREMISE_UNVERIFIED\x10Y\x12+\n'BLUE_MSG_CONSUMER_TO_SELF_FB_\
    UNVERIFIED\x10Z\x120\n,BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED\x10[\
    \x12#\n\x1fBLUE_MSG_SELF_FB_TO_BSP_PREMISE\x10\\\x12$\n\x20BLUE_MSG_SELF\
    _FB_TO_SELF_PREMISE\x10]\x12\x1f\n\x1bBLUE_MSG_SELF_FB_UNVERIFIED\x10^\
    \x128\n4BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED\x10_\x12\
    \x1d\n\x19BLUE_MSG_SELF_FB_VERIFIED\x10`\x128\n4BLUE_MSG_SELF_FB_VERIFIE\
    D_TO_SELF_PREMISE_UNVERIFIED\x10a\x12(\n$BLUE_MSG_SELF_PREMISE_TO_BSP_PR\
    EMISE\x10b\x12$\n\x20BLUE_MSG_SELF_PREMISE_UNVERIFIED\x10c\x12\"\n\x1eBL\
    UE_MSG_SELF_PREMISE_VERIFIED\x10d\x12\x16\n\x12BLUE_MSG_TO_BSP_FB\x10e\
    \x12\x18\n\x14BLUE_MSG_TO_CONSUMER\x10f\x12\x17\n\x13BLUE_MSG_TO_SELF_FB\
    \x10g\x12*\n&BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED\x10h\x12/\n+BLUE_MSG\
    _UNVERIFIED_TO_BSP_PREMISE_VERIFIED\x10i\x12+\n'BLUE_MSG_UNVERIFIED_TO_S\
    ELF_FB_VERIFIED\x10j\x12#\n\x1fBLUE_MSG_UNVERIFIED_TO_VERIFIED\x10k\x12*\
    \n&BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED\x10l\x12/\n+BLUE_MSG_VERIFIED_\
    TO_BSP_PREMISE_UNVERIFIED\x10m\x12+\n'BLUE_MSG_VERIFIED_TO_SELF_FB_UNVER\
    IFIED\x10n\x12#\n\x1fBLUE_MSG_VERIFIED_TO_UNVERIFIED\x10o\x126\n2BLUE_MS\
    G_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED\x10p\x122\n.BLUE_MSG_BSP_FB_\
    UNVERIFIED_TO_SELF_FB_VERIFIED\x10q\x126\n2BLUE_MSG_BSP_FB_VERIFIED_TO_B\
    SP_PREMISE_UNVERIFIED\x10r\x122\n.BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UN\
    VERIFIED\x10s\x127\n3BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED\
    \x10t\x127\n3BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED\x10u\
    \x12\x1c\n\x18E2E_IDENTITY_UNAVAILABLE\x10v\x12\x12\n\x0eGROUP_CREATING\
    \x10w\x12\x17\n\x13GROUP_CREATE_FAILED\x10x\x12\x11\n\rGROUP_BOUNCED\x10\
    y\x12\x11\n\rBLOCK_CONTACT\x10z\x12!\n\x1dEPHEMERAL_SETTING_NOT_APPLIED\
    \x10{\x12\x0f\n\x0bSYNC_FAILED\x10|\x12\x0b\n\x07SYNCING\x10}\x12\x1c\n\
    \x18BIZ_PRIVACY_MODE_INIT_FB\x10~\x12\x1d\n\x19BIZ_PRIVACY_MODE_INIT_BSP\
    \x10\x7f\x12\x1b\n\x16BIZ_PRIVACY_MODE_TO_FB\x10\x80\x01\x12\x1c\n\x17BI\
    Z_PRIVACY_MODE_TO_BSP\x10\x81\x01\x12\x16\n\x11DISAPPEARING_MODE\x10\x82\
    \x01\x12\x1c\n\x17E2E_DEVICE_FETCH_FAILED\x10\x83\x01\x12\x11\n\x0cADMIN\
    _REVOKE\x10\x84\x01\x12$\n\x1fGROUP_INVITE_LINK_GROWTH_LOCKED\x10\x85\
    \x01\"K\n\x1eWebMessageInfoBizPrivacyStatus\x12\x08\n\x04E2EE\x10\0\x12\
    \x06\n\x02FB\x10\x02\x12\x07\n\x03BSP\x10\x01\x12\x0e\n\nBSP_AND_FB\x10\
    \x03*/\n\x0fMediaVisibility\x12\x0b\n\x07DEFAULT\x10\0\x12\x07\n\x03OFF\
    \x10\x01\x12\x06\n\x02ON\x10\x02b\x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(180);
            messages.push(AppVersion::generated_message_descriptor_data());
            messages.push(UserAgent::generated_message_descriptor_data());
            messages.push(WebdPayload::generated_message_descriptor_data());
            messages.push(WebInfo::generated_message_descriptor_data());
            messages.push(DNSSource::generated_message_descriptor_data());
            messages.push(CompanionRegData::generated_message_descriptor_data());
            messages.push(ClientPayload::generated_message_descriptor_data());
            messages.push(NoiseCertificateDetails::generated_message_descriptor_data());
            messages.push(NoiseCertificate::generated_message_descriptor_data());
            messages.push(ClientHello::generated_message_descriptor_data());
            messages.push(ServerHello::generated_message_descriptor_data());
            messages.push(ClientFinish::generated_message_descriptor_data());
            messages.push(HandshakeMessage::generated_message_descriptor_data());
            messages.push(BizIdentityInfo::generated_message_descriptor_data());
            messages.push(BizAccountLinkInfo::generated_message_descriptor_data());
            messages.push(BizAccountPayload::generated_message_descriptor_data());
            messages.push(VerifiedNameDetails::generated_message_descriptor_data());
            messages.push(VerifiedNameCertificate::generated_message_descriptor_data());
            messages.push(LocalizedName::generated_message_descriptor_data());
            messages.push(SyncActionData::generated_message_descriptor_data());
            messages.push(StarAction::generated_message_descriptor_data());
            messages.push(ContactAction::generated_message_descriptor_data());
            messages.push(MuteAction::generated_message_descriptor_data());
            messages.push(PinAction::generated_message_descriptor_data());
            messages.push(SecurityNotificationSetting::generated_message_descriptor_data());
            messages.push(PushNameSetting::generated_message_descriptor_data());
            messages.push(LocaleSetting::generated_message_descriptor_data());
            messages.push(QuickReplyAction::generated_message_descriptor_data());
            messages.push(LabelAssociationAction::generated_message_descriptor_data());
            messages.push(LabelEditAction::generated_message_descriptor_data());
            messages.push(RecentStickerWeightsAction::generated_message_descriptor_data());
            messages.push(RecentStickerMetadata::generated_message_descriptor_data());
            messages.push(RecentEmojiWeightsAction::generated_message_descriptor_data());
            messages.push(FavoriteStickerAction::generated_message_descriptor_data());
            messages.push(ArchiveChatAction::generated_message_descriptor_data());
            messages.push(DeleteMessageForMeAction::generated_message_descriptor_data());
            messages.push(MarkChatAsReadAction::generated_message_descriptor_data());
            messages.push(ClearChatAction::generated_message_descriptor_data());
            messages.push(DeleteChatAction::generated_message_descriptor_data());
            messages.push(UnarchiveChatsSetting::generated_message_descriptor_data());
            messages.push(SyncActionMessageRange::generated_message_descriptor_data());
            messages.push(SyncActionMessage::generated_message_descriptor_data());
            messages.push(KeyExpiration::generated_message_descriptor_data());
            messages.push(PrimaryFeature::generated_message_descriptor_data());
            messages.push(AndroidUnsupportedActions::generated_message_descriptor_data());
            messages.push(SyncActionValue::generated_message_descriptor_data());
            messages.push(RecentEmojiWeight::generated_message_descriptor_data());
            messages.push(RecentStickerWeight::generated_message_descriptor_data());
            messages.push(SyncdPatch::generated_message_descriptor_data());
            messages.push(SyncdMutation::generated_message_descriptor_data());
            messages.push(SyncdMutations::generated_message_descriptor_data());
            messages.push(SyncdSnapshot::generated_message_descriptor_data());
            messages.push(ExternalBlobReference::generated_message_descriptor_data());
            messages.push(SyncdRecord::generated_message_descriptor_data());
            messages.push(KeyId::generated_message_descriptor_data());
            messages.push(SyncdValue::generated_message_descriptor_data());
            messages.push(SyncdIndex::generated_message_descriptor_data());
            messages.push(ExitCode::generated_message_descriptor_data());
            messages.push(SyncdVersion::generated_message_descriptor_data());
            messages.push(ServerErrorReceipt::generated_message_descriptor_data());
            messages.push(MediaRetryNotification::generated_message_descriptor_data());
            messages.push(MsgOpaqueData::generated_message_descriptor_data());
            messages.push(MsgRowOpaqueData::generated_message_descriptor_data());
            messages.push(GlobalSettings::generated_message_descriptor_data());
            messages.push(WallpaperSettings::generated_message_descriptor_data());
            messages.push(GroupParticipant::generated_message_descriptor_data());
            messages.push(Pushname::generated_message_descriptor_data());
            messages.push(HistorySyncMsg::generated_message_descriptor_data());
            messages.push(Conversation::generated_message_descriptor_data());
            messages.push(HistorySync::generated_message_descriptor_data());
            messages.push(EphemeralSetting::generated_message_descriptor_data());
            messages.push(InteractiveAnnotation::generated_message_descriptor_data());
            messages.push(DeviceListMetadata::generated_message_descriptor_data());
            messages.push(MessageContextInfo::generated_message_descriptor_data());
            messages.push(AdReplyInfo::generated_message_descriptor_data());
            messages.push(ExternalAdReplyInfo::generated_message_descriptor_data());
            messages.push(ContextInfo::generated_message_descriptor_data());
            messages.push(SenderKeyDistributionMessage::generated_message_descriptor_data());
            messages.push(ImageMessage::generated_message_descriptor_data());
            messages.push(InvoiceMessage::generated_message_descriptor_data());
            messages.push(ContactMessage::generated_message_descriptor_data());
            messages.push(LocationMessage::generated_message_descriptor_data());
            messages.push(ExtendedTextMessage::generated_message_descriptor_data());
            messages.push(DocumentMessage::generated_message_descriptor_data());
            messages.push(AudioMessage::generated_message_descriptor_data());
            messages.push(VideoMessage::generated_message_descriptor_data());
            messages.push(Call::generated_message_descriptor_data());
            messages.push(Chat::generated_message_descriptor_data());
            messages.push(ProtocolMessage::generated_message_descriptor_data());
            messages.push(HistorySyncNotification::generated_message_descriptor_data());
            messages.push(AppStateSyncKey::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyId::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyFingerprint::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyData::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyShare::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyRequest::generated_message_descriptor_data());
            messages.push(AppStateFatalExceptionNotification::generated_message_descriptor_data());
            messages.push(InitialSecurityNotificationSettingSync::generated_message_descriptor_data());
            messages.push(ContactsArrayMessage::generated_message_descriptor_data());
            messages.push(HSMCurrency::generated_message_descriptor_data());
            messages.push(HSMDateTimeComponent::generated_message_descriptor_data());
            messages.push(HSMDateTimeUnixEpoch::generated_message_descriptor_data());
            messages.push(HSMDateTime::generated_message_descriptor_data());
            messages.push(HSMLocalizableParameter::generated_message_descriptor_data());
            messages.push(HighlyStructuredMessage::generated_message_descriptor_data());
            messages.push(SendPaymentMessage::generated_message_descriptor_data());
            messages.push(RequestPaymentMessage::generated_message_descriptor_data());
            messages.push(DeclinePaymentRequestMessage::generated_message_descriptor_data());
            messages.push(CancelPaymentRequestMessage::generated_message_descriptor_data());
            messages.push(PaymentInviteMessage::generated_message_descriptor_data());
            messages.push(LiveLocationMessage::generated_message_descriptor_data());
            messages.push(StickerMessage::generated_message_descriptor_data());
            messages.push(FourRowTemplate::generated_message_descriptor_data());
            messages.push(HydratedFourRowTemplate::generated_message_descriptor_data());
            messages.push(TemplateMessage::generated_message_descriptor_data());
            messages.push(TemplateButtonReplyMessage::generated_message_descriptor_data());
            messages.push(CatalogSnapshot::generated_message_descriptor_data());
            messages.push(ProductSnapshot::generated_message_descriptor_data());
            messages.push(ProductMessage::generated_message_descriptor_data());
            messages.push(OrderMessage::generated_message_descriptor_data());
            messages.push(Row::generated_message_descriptor_data());
            messages.push(Section::generated_message_descriptor_data());
            messages.push(Product::generated_message_descriptor_data());
            messages.push(ProductSection::generated_message_descriptor_data());
            messages.push(ProductListHeaderImage::generated_message_descriptor_data());
            messages.push(ProductListInfo::generated_message_descriptor_data());
            messages.push(ListMessage::generated_message_descriptor_data());
            messages.push(SingleSelectReply::generated_message_descriptor_data());
            messages.push(ListResponseMessage::generated_message_descriptor_data());
            messages.push(Header::generated_message_descriptor_data());
            messages.push(Body::generated_message_descriptor_data());
            messages.push(Footer::generated_message_descriptor_data());
            messages.push(ShopMessage::generated_message_descriptor_data());
            messages.push(CollectionMessage::generated_message_descriptor_data());
            messages.push(NativeFlowButton::generated_message_descriptor_data());
            messages.push(NativeFlowMessage::generated_message_descriptor_data());
            messages.push(InteractiveMessage::generated_message_descriptor_data());
            messages.push(GroupInviteMessage::generated_message_descriptor_data());
            messages.push(DeviceSentMessage::generated_message_descriptor_data());
            messages.push(FutureProofMessage::generated_message_descriptor_data());
            messages.push(ButtonText::generated_message_descriptor_data());
            messages.push(NativeFlowInfo::generated_message_descriptor_data());
            messages.push(Button::generated_message_descriptor_data());
            messages.push(ButtonsMessage::generated_message_descriptor_data());
            messages.push(ButtonsResponseMessage::generated_message_descriptor_data());
            messages.push(ReactionMessage::generated_message_descriptor_data());
            messages.push(StickerSyncRMRMessage::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            messages.push(ActionLink::generated_message_descriptor_data());
            messages.push(DisappearingMode::generated_message_descriptor_data());
            messages.push(PBMediaData::generated_message_descriptor_data());
            messages.push(PaymentBackground::generated_message_descriptor_data());
            messages.push(Money::generated_message_descriptor_data());
            messages.push(HydratedQuickReplyButton::generated_message_descriptor_data());
            messages.push(HydratedURLButton::generated_message_descriptor_data());
            messages.push(HydratedCallButton::generated_message_descriptor_data());
            messages.push(HydratedTemplateButton::generated_message_descriptor_data());
            messages.push(QuickReplyButton::generated_message_descriptor_data());
            messages.push(URLButton::generated_message_descriptor_data());
            messages.push(CallButton::generated_message_descriptor_data());
            messages.push(TemplateButton::generated_message_descriptor_data());
            messages.push(Location::generated_message_descriptor_data());
            messages.push(Point::generated_message_descriptor_data());
            messages.push(CompanionProps::generated_message_descriptor_data());
            messages.push(ADVSignedDeviceIdentityHMAC::generated_message_descriptor_data());
            messages.push(ADVSignedDeviceIdentity::generated_message_descriptor_data());
            messages.push(ADVDeviceIdentity::generated_message_descriptor_data());
            messages.push(ADVSignedKeyIndexList::generated_message_descriptor_data());
            messages.push(ADVKeyIndexList::generated_message_descriptor_data());
            messages.push(MessageKey::generated_message_descriptor_data());
            messages.push(Reaction::generated_message_descriptor_data());
            messages.push(UserReceipt::generated_message_descriptor_data());
            messages.push(StatusPSA::generated_message_descriptor_data());
            messages.push(PhotoChange::generated_message_descriptor_data());
            messages.push(MediaData::generated_message_descriptor_data());
            messages.push(WebFeatures::generated_message_descriptor_data());
            messages.push(NotificationMessageInfo::generated_message_descriptor_data());
            messages.push(WebNotificationsInfo::generated_message_descriptor_data());
            messages.push(PaymentInfo::generated_message_descriptor_data());
            messages.push(WebMessageInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(50);
            enums.push(MediaVisibility::generated_enum_descriptor_data());
            enums.push(user_agent::UserAgentPlatform::generated_enum_descriptor_data());
            enums.push(user_agent::UserAgentReleaseChannel::generated_enum_descriptor_data());
            enums.push(web_info::WebInfoWebSubPlatform::generated_enum_descriptor_data());
            enums.push(dnssource::DNSSourceDNSResolutionMethod::generated_enum_descriptor_data());
            enums.push(client_payload::ClientPayloadConnectType::generated_enum_descriptor_data());
            enums.push(client_payload::ClientPayloadConnectReason::generated_enum_descriptor_data());
            enums.push(client_payload::ClientPayloadProduct::generated_enum_descriptor_data());
            enums.push(client_payload::ClientPayloadIOSAppExtension::generated_enum_descriptor_data());
            enums.push(biz_identity_info::BizIdentityInfoVerifiedLevelValue::generated_enum_descriptor_data());
            enums.push(biz_identity_info::BizIdentityInfoHostStorageType::generated_enum_descriptor_data());
            enums.push(biz_identity_info::BizIdentityInfoActualActorsType::generated_enum_descriptor_data());
            enums.push(biz_account_link_info::BizAccountLinkInfoHostStorageType::generated_enum_descriptor_data());
            enums.push(biz_account_link_info::BizAccountLinkInfoAccountType::generated_enum_descriptor_data());
            enums.push(syncd_mutation::SyncdMutationSyncdOperation::generated_enum_descriptor_data());
            enums.push(media_retry_notification::MediaRetryNotificationResultType::generated_enum_descriptor_data());
            enums.push(group_participant::GroupParticipantRank::generated_enum_descriptor_data());
            enums.push(conversation::ConversationEndOfHistoryTransferType::generated_enum_descriptor_data());
            enums.push(history_sync::HistorySyncHistorySyncType::generated_enum_descriptor_data());
            enums.push(ad_reply_info::AdReplyInfoMediaType::generated_enum_descriptor_data());
            enums.push(external_ad_reply_info::ExternalAdReplyInfoMediaType::generated_enum_descriptor_data());
            enums.push(invoice_message::InvoiceMessageAttachmentType::generated_enum_descriptor_data());
            enums.push(extended_text_message::ExtendedTextMessageFontType::generated_enum_descriptor_data());
            enums.push(extended_text_message::ExtendedTextMessagePreviewType::generated_enum_descriptor_data());
            enums.push(extended_text_message::ExtendedTextMessageInviteLinkGroupType::generated_enum_descriptor_data());
            enums.push(video_message::VideoMessageAttribution::generated_enum_descriptor_data());
            enums.push(protocol_message::ProtocolMessageType::generated_enum_descriptor_data());
            enums.push(history_sync_notification::HistorySyncNotificationHistorySyncType::generated_enum_descriptor_data());
            enums.push(hsmdate_time_component::HSMDateTimeComponentDayOfWeekType::generated_enum_descriptor_data());
            enums.push(hsmdate_time_component::HSMDateTimeComponentCalendarType::generated_enum_descriptor_data());
            enums.push(payment_invite_message::PaymentInviteMessageServiceType::generated_enum_descriptor_data());
            enums.push(order_message::OrderMessageOrderStatus::generated_enum_descriptor_data());
            enums.push(order_message::OrderMessageOrderSurface::generated_enum_descriptor_data());
            enums.push(list_message::ListMessageListType::generated_enum_descriptor_data());
            enums.push(list_response_message::ListResponseMessageListType::generated_enum_descriptor_data());
            enums.push(shop_message::ShopMessageSurface::generated_enum_descriptor_data());
            enums.push(group_invite_message::GroupInviteMessageGroupType::generated_enum_descriptor_data());
            enums.push(button::ButtonType::generated_enum_descriptor_data());
            enums.push(buttons_message::ButtonsMessageHeaderType::generated_enum_descriptor_data());
            enums.push(buttons_response_message::ButtonsResponseMessageType::generated_enum_descriptor_data());
            enums.push(disappearing_mode::DisappearingModeInitiator::generated_enum_descriptor_data());
            enums.push(payment_background::PaymentBackgroundType::generated_enum_descriptor_data());
            enums.push(companion_props::CompanionPropsPlatformType::generated_enum_descriptor_data());
            enums.push(web_features::WebFeaturesFlag::generated_enum_descriptor_data());
            enums.push(payment_info::PaymentInfoCurrency::generated_enum_descriptor_data());
            enums.push(payment_info::PaymentInfoStatus::generated_enum_descriptor_data());
            enums.push(payment_info::PaymentInfoTxnStatus::generated_enum_descriptor_data());
            enums.push(web_message_info::WebMessageInfoStatus::generated_enum_descriptor_data());
            enums.push(web_message_info::WebMessageInfoStubType::generated_enum_descriptor_data());
            enums.push(web_message_info::WebMessageInfoBizPrivacyStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
